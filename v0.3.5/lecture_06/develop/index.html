<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Package development Â· Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="Julia for Machine Learning logo" class="docs-light-only" src="../../assets/logo.svg"/><img alt="Julia for Machine Learning logo" class="docs-dark-only" src="../../assets/logo-dark.svg"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic programming</a></li></ul></li><li><input checked="" class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../modules/">Files and modules</a></li><li><a class="tocitem" href="../pkg/">Package manager</a></li><li class="is-active"><a class="tocitem" href="">Package development</a><ul class="internal"><li><a class="tocitem" href="#Pkg-templates"><span>Pkg templates</span></a></li><li><a class="tocitem" href="#Development-mode"><span>Development mode</span></a></li><li><a class="tocitem" href="#Adding-content-1"><span>Adding content 1</span></a></li><li><a class="tocitem" href="#unit-testing"><span>Unit testing</span></a></li><li><a class="tocitem" href="#Writing-documentation"><span>Writing documentation</span></a></li><li><a class="tocitem" href="#Adding-content-2"><span>Adding content 2</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Statistics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">6: Code organization</a></li><li class="is-active"><a href="">Package development</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Package development</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_06/develop.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="development"><a class="docs-heading-anchor" href="#development">Package development</a><a id="development-1"></a><a class="docs-heading-anchor-permalink" href="#development" title="Permalink"></a></h1><p>The cool thing about Julia is the simplicity of creating packages and sharing them with others. This section contains a step-by-step tutorial on how to build a package from scratch. Moreover, we will use this package later in the course.</p><h2 id="Pkg-templates"><a class="docs-heading-anchor" href="#Pkg-templates">Pkg templates</a><a id="Pkg-templates-1"></a><a class="docs-heading-anchor-permalink" href="#Pkg-templates" title="Permalink"></a></h2><p>We first generate an empty package <code>PackageName</code> by the built-in function <code>generate</code> in the Pkg REPL.</p><pre><code class="language-julia">(@v1.5) pkg&gt; generate PackageName
 Generating  project PackageName:
    PackageName/Project.toml
    PackageName/src/PackageName.jl</code></pre><p>This way generates the new package in the working directory. However, we may also specify an absolute or relative path to generate it elsewhere. The <code>generate</code> function creates a new folder (with the name matching the package name) with the following content.</p><pre><code class="language-julia">âââ Project.toml
âââ src
    âââ PackageName.jl</code></pre><p>The new package consists of the <code>Project.toml</code> file and the <code>src</code> folder with one <code>.jl</code> file. The <code>src/PackageName.jl</code> file contains a module <code>PackageName</code>. The package, the <code>.jl</code> file, and the module share the same name. <strong>Since we will modify multiple files during this lecture, we will often specify which file we work with.</strong></p><pre><code class="language-julia"># /src/PackageName.jl
module PackageName

greet() = print("Hello World!")

end # module</code></pre><p>Since the <code>generate</code> function creates an empty package, the <code>Project.toml</code> contains only information describing the package name, its unique UUID, version, and author list.</p><pre><code class="language-toml">name = "PackageName"
uuid = "fa38fd22-11d6-48c8-ae38-ef06258216d8"
authors = ["Author Name"]
version = "0.1.0"</code></pre><p>Since the <code>Project.toml</code> file <code>src/*.jl</code> files are sufficient for determining a  package, packages are modules with their own environment.</p><p>The built-in <code>generate</code> function provides only basic functionality for generating packages. Even though it is sufficient in many cases, the <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates</a> package offers a straightforward and customizable way for creating packages.</p><div class="exercise-body"><header class="exercise-header">Exercise:</header><p></p><p>The goal of this exercise is to create a new package by the PkgTemplates package. Install PkgTemplates and then use the following code to generate a new package template.</p><pre><code class="language-julia">using PkgTemplates

template = Template(;
    user = "GithubUserName",            # github user name
    authors = ["Author1", "Author2"],   # list of authors
    dir = "/Path/To/Dir/",              # dir in which the package will be created
    julia = v"1.5",                     # compat version of Julia
    plugins = [
        !CompatHelper,                  # disable CompatHelper
        !TagBot,                        # disable TagBot
        Readme(; inline_badges = true), # added readme file with badges
        Tests(; project = true),        # added Project.toml file for unit tests
        Git(; manifest = false),        # add manifest.toml to .gitignore
        License(; name = "MIT")         # addedMIT licence
    ],
)</code></pre><p>Do not forget to change <code>user</code>, <code>authors</code> and <code>dir</code>.</p><p>In the rest of the lecture, we will write code to visualize grayscale and colour images. Come up with a proper package name and use the following code to generate a new package.</p><pre><code class="language-julia">template("PackageName")</code></pre><p>For naming conventions, see the official <a href="https://julialang.github.io/Pkg.jl/v1/creating-packages/#Package-naming-guidelines">package naming guidelines</a>. Finally, create the folder <code>scripts</code> in the main package folder.</p><p></p></div><details class="solution-body"><summary class="solution-header">Solution:</summary><p></p><p>There is no best way to choose the correct package name. We decided to use <code>ImageInspector</code> and create the package by the following code:</p><pre><code class="language-julia">template("ImageInspector")</code></pre><p>After creating the <code>ImageInspector</code> package, we can add the <code>scripts</code> folder manually or use the <code>mkdir</code> function to create it. For the latter, we use the <code>joinpath</code> function to specify the correct path.</p><pre><code class="language-julia">mkdir(joinpath("/Path/To/Dir/", "ImageInspector", "scripts"))</code></pre><p>The generated folder contains more files than the folder generated by the built-in <code>generate</code> function.</p><pre><code class="language-julia">âââ .git
âââ .gitignore
âââ LICENSE
âââ Manifest.toml
âââ Project.toml
âââ README.md
âââ scripts
âââ src
â   âââ ImageInspector.jl
âââ test
    âââ Manifest.toml
    âââ Project.toml
    âââ runtests.jl</code></pre><p></p></details><div class="info-body"><header class="info-header">Interactive package generation</header><p></p><p>PkgTemplate provides an interactive way to generate a new package. The template can be created interactively by the following command:</p><pre><code class="language-julia">Template(; interactive=true)</code></pre><p>The exercise above used a simple template. However, PkgTemplates provides many additional features to simplify the package generation process. Some plugins add documentation or integration with GitHub features. See the official <a href="https://invenia.github.io/PkgTemplates.jl/stable/">PkgTemplates documentation</a> for more information.</p><p></p></div><h2 id="Development-mode"><a class="docs-heading-anchor" href="#Development-mode">Development mode</a><a id="Development-mode-1"></a><a class="docs-heading-anchor-permalink" href="#Development-mode" title="Permalink"></a></h2><p>In the previous section, we created a new empty package. In this section, we will fill the package with content. <strong>Before we continue, open the main folder of the ImageInspector package in a new VS Code window.</strong> One can access it from <code>File -&gt; Open folder</code>.</p><p>The content of the <code>ImageInspector</code> folder can be divided into four parts:</p><ul><li><em>Root folder</em> contains information about the package and git.</li><li><em>Folder src</em> contains the package source code.</li><li><em>Folder tests</em> contains the testing scripts for verifying the code correctness.</li><li><em>Folder scripts</em> is used to run scripts.</li></ul><p>The first three are standard, while we added the last folder manually. We can add more folders, such as <code>data</code>.</p><p>We first activate a new environment in the <code>script</code> folder.</p><pre><code class="language-julia">(ImageInspector) pkg&gt; activate ./scripts

(scripts) pkg&gt;</code></pre><p>Then we use the <code>dev</code> (or <code>develop</code>) command to tell Julia that the <code>ImageInspector</code> folder is a package, and we want to start its development. The important thing to realize is that the <em>working directory</em> is <code>.../ImageInspector</code>, while the <em>working environment</em> is <code>.../ImageInspector/scripts</code>. Since the dot in <code>dev .</code> specifies the working directory, this command will add the package from the working directory into the working environment.</p><pre><code class="language-julia">julia&gt; pwd()
.../ImageInspector

(scripts) pkg&gt; dev . # or dev /absolute/or/relative/path/ImageInspector/

(scripts) pkg&gt; st
Status `.../ImageInspector/scripts/Project.toml`
  [5c9991e7] ImageInspector v0.1.0 `..`</code></pre><p>Like the <code>add</code> command, the <code>dev</code> command allows us to load the package by <code>using</code> or <code>import</code>. The difference between <code>add</code> and <code>dev</code> is that the <code>dev</code> command tracks the package current state and not a concrete git commit in some branch.</p><div class="admonition is-warning"><header class="admonition-header">Default Julia enviroment in VS Code</header><div class="admonition-body"><p>The VS Code allows setting a default Julia environment that is activated when Julia REPL is opened. We can do this by pressing <code>Julia env:</code> located at the bottom info bar and selecting the desired environment.</p></div></div><p>We now create a script <code>/scripts/example.jl</code> for testing the package functionality. In the rest of the lecture, we will use relative paths from the main folder of the <code>ImageInspector</code> package to specify the code location.</p><pre><code class="language-julia"># /scripts/example.jl
using ImageInspector</code></pre><p>Julia can load a package only once per Julia session. If we load a package by the <code>using</code> or <code>import</code> commands and then make changes in the code, these changes will not be reloaded. This holds even if we try to reload the package by running <code>using</code> or <code>import</code> again. For example, we add the <code>greet</code> function to the <code>ImageInspector</code> package.</p><pre><code class="language-julia"># /src/ImageInspector.jl
module ImageInspector

export greet

greet() = print("Hello World!")

end</code></pre><p>Since we have already loaded the package, this change is not reloaded. If we call the <code>greet</code> function, we get the <code>UndefVarError</code> error.</p><pre><code class="language-julia">julia&gt; greet()
ERROR: UndefVarError: greet not defined</code></pre><p>In this case, we have to restart Julia. There are two ways how to exit Julia interactive session: using keyword shortcut <code>ctrl + D</code> or using the <code>exit()</code> function. Even though we can use the <code>greet()</code> function after the restart, we will not do it yet. The reason is that we would have to restart Julia again after making any changes to the package. Since this is not a convenient way to code, we will use the <a href="https://github.com/timholy/Revise.jl">Revise</a> package. Even though it provides lots of convenient features, we will present only its basic use. First, we install it.</p><pre><code class="language-julia">(scripts) pkg&gt; add Revise</code></pre><p>If we develop a package and load the Revise package first, all package changes will be reloaded without restarting Julia.</p><pre><code class="language-julia"># /scripts/example.jl
using Revise # this must come before `using ImageInspector`
using ImageInspector

greet()</code></pre><pre><code class="language-julia">Hello World!</code></pre><p>We now add the <code>greet2</code> function.</p><pre><code class="language-julia"># /src/ImageInspector.jl
module ImageInspector

export greet, greet2

greet() = print("Hello World!")
greet2() = print("Hello World!!!!")

end</code></pre><p>Since we are using the <code>Revise</code> package, it should be possible to call the <code>greet2</code> function without restarting Julia session.</p><pre><code class="language-julia">julia&gt; greet2()
Hello World!!!!</code></pre><h2 id="Adding-content-1"><a class="docs-heading-anchor" href="#Adding-content-1">Adding content 1</a><a id="Adding-content-1-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-content-1" title="Permalink"></a></h2><p>This section adds content to the package.</p><div class="exercise-body"><header class="exercise-header">Exercise:</header><p></p><p>This exercise defines the <code>image</code> function that converts a matrix of real numbers to a matrix of Gray points. Real numbers can be converted to Gray points by the <code>Gray</code> constructor from the Colors package. Use the following code to test the function.</p><pre><code class="language-julia"># /scripts/example.jl
using Revise # this must come before `using ImageInspector`
using ImageInspector, MLDatasets, Plots

x = FashionMNIST.traintensor(1);
plot(image(x); axis = nothing, border = :none)</code></pre><p><strong>Hint:</strong> Each Julia package contains its environment for tracking package dependencies. Use proper commands in the Pkg REPL to add <code>Colors</code> as a dependency of the ImageInspector package. Do not forget to add <code>MLDataset</code> and <code>Plots</code> to the <code>scripts</code> environment.</p><p></p></div><details class="solution-body"><summary class="solution-header">Solution:</summary><p></p><p>First, we need to install all necessary packages. Since we set the <code>scripts</code> environment as the default one for this project, we first install <code>MLDataset</code> and <code>Plots</code>.</p><pre><code class="language-julia">(scripts) pkg&gt; add MLDatasets Plots</code></pre><p>Since we want to add the <code>image</code> function to the ImageInspector package, we have to install the Colors package. However, we do not want to add it to <code>scripts</code> but to <code>ImageInspector</code>. Printing the working directory by <code>pwd()</code>, we realize that we are in the correct folder and activate the working environment by <code>activate .</code> The dot represents the current working directory.</p><pre><code class="language-julia">julia&gt; pwd()
".../ImageInspector"

(scripts) pkg&gt; activate .
 Activating environment at `/path/ImageInspector/Project.toml`</code></pre><p>Now we use <code>add Colors</code> to install the Colors package.</p><pre><code class="language-julia">(ImageInspector) pkg&gt; add Colors</code></pre><p>Since we want to work in <code>scripts</code>, we change the environment back.</p><pre><code class="language-julia">(ImageInspector) pkg&gt; activate /scripts

(scripts)</code></pre><p>With the Colors package installed, we have to add <code>using Colors</code> into the ImageInspector module. Then we can define the <code>image</code> function and <code>export</code> it.</p><pre><code class="language-julia"># /src/ImageInspector.jl
module ImageInspector

using Colors

export image

image(x::AbstractMatrix{&lt;:Real}) = Gray.(x)

end</code></pre><p></p></details><p><img alt="" src="../image_1.svg"/></p><p>The previous exercise used the MLDatasets package that provides many well-known datasets used in machine learning. One of them is the <code>FashionMNIST</code> dataset of gray images of clothes. However, the resulting image is rotated 90 degrees. The reason is that images in the FashionMNIST dataset are stored in the <strong>width x height</strong> format, but the Plots package assumes the <strong>height x width</strong> format. We solve this issue by redefining the <code>image</code> function.</p><pre><code class="language-julia">function image(x::AbstractMatrix{T}; flip = true) where {T &lt;: Real}
    xx = flip ? PermutedDimsArray(x, (2, 1)) : x
    return Gray.(xx)
end</code></pre><p>In the definition of <code>image</code>, we use <code>PermutedDimsArray</code> that creates a permuted view without making a copy. There is also the <code>permutedims</code> function that does the same but creates a copy. Now we plot both images.</p><pre><code class="language-julia"># /scripts/example.jl
plot(
    plot(image(x; flip = true); title = "flip = true"),
    plot(image(x; flip = false); title = "flip = false");
    axis = nothing,
    border = :none,
)</code></pre><p><img alt="" src="../image_2.svg"/></p><p>The <code>image</code> function also used <code>AbstractMatrix</code> to specify that the input must be a matrix. In general, we can specify the types of multi-dimensional input arrays in multiple ways:</p><ul><li><code>AbstractArray</code> specifies that the input must be an array.</li><li><code>AbstractArray{T}</code> specifies that the input must be an array with elements of type <code>T</code>.</li><li><code>AbstractArray{T, N}</code> specifies that the input must be an array of dimension <code>N</code> with elements of type <code>T</code>.</li><li><code>AbstractMatrix</code> or <code>AbstractMatrix{T}</code> is equivalent to  <code>AbstractArray</code> with <code>N=2</code>.</li><li><code>AbstractVector</code> or <code>AbstractVector{T}</code> is equivalent to  <code>AbstractArray</code> with <code>N=1</code>.</li></ul><p>We will now extend the <code>image</code> function to three-dimensional inputs. The third dimension represents the colour channels.</p><div class="exercise-body"><header class="exercise-header">Exercise:</header><p></p><p>Write a method for the <code>image</code> function that converts a 3D array of real numbers to its image representation. Assume that the third dimension represents the colour channels. Three channels should be converted to an RGB point extracting the RGB channels and <code>RGB.(r, g, b)</code>. If the size of the third dimension is:</p><ul><li><code>1</code> the function should return a grayscale image,</li><li><code>3</code> the function should return a colour image,</li><li>otherwise, the function should throw an error.</li></ul><p>Use the following code to test the <code>image</code> function.</p><pre><code class="language-julia"># /scripts/example.jl
x1 = FashionMNIST.traintensor(1);
x2 = CIFAR10.traintensor(2);
plot(
    plot(image(x1)),
    plot(image(x2));
    axis = nothing,
    border = :none
)</code></pre><p><strong>Hint:</strong> use the <code>eachslice</code> function to split the array along the third dimension and the <code>dropdims</code> function to drop a dimension slice.</p><p></p></div><details class="solution-body"><summary class="solution-header">Solution:</summary><p></p><p>The functionality depends on the size of the third dimension.</p><ul><li>If the size of the third dimension is 1, we use the <code>dropdims</code> to remove the third dimension. Then we call the <code>image</code> method from the previous exercise.</li><li>If the dimension size is 3, we use <code>PermutedDimsArray</code> if <code>flip</code> is true. We can extract the three channels manually, or we can use the <code>eachslice</code> function.</li><li>Otherwise, we throw an <code>ArgumentError</code>.</li></ul><p>Altogether, the new method can be defined as follows.</p><pre><code class="language-julia"># /src/ImageInspector.jl
function image(x::AbstractArray{T,3}; flip = true) where {T &lt;: Real}
    s = size(x, 3)
    if s == 1
        return image(dropdims(x; dims = 3); flip)
    elseif s == 3
        xx = flip ? PermutedDimsArray(x, (2, 1, 3)) : x
        r, g, b = eachslice(xx; dims=3)
        return RGB.(r, g, b)
    else
        throw(ArgumentError("unsupported size of the third dimension $(s) â [1,3]."))
    end
end</code></pre><p></p></details><p><img alt="" src="../image_3.svg"/></p><p>Multiple images are usually stored in multi-dimensional arrays. For example, grayscale images are stored as 3D or 4D arrays, where the last dimension represents individual images. Similarly, colour images are stored as a 4D array.</p><div class="exercise-body"><header class="exercise-header">Exercise:</header><p></p><p>Add new methods for the <code>image</code> function with the following properties:</p><ul><li>New methods should accept two arguments:<ul><li><code>x</code>: 3D or 4D array of real numbers that represents images,</li><li><code>inds</code>: one or more image indices to extract and convert to Gray/RGB representation.</li></ul></li><li>If only one index is provided, the method should return a single image in its representation.</li><li>If more indices are provided, the method should return an array of images.</li></ul><p>Use the following code to test the <code>image</code> function.</p><pre><code class="language-julia"># /scripts/example.jl
x = FashionMNIST.traintensor(1:10);
plot(plot.(image(x, [1,2]))...; axis = nothing, border = :none)</code></pre><p></p></div><details class="solution-body"><summary class="solution-header">Solution:</summary><p></p><p>We have four possible combinations of the input arguments:</p><ol><li>3D array and one index,</li><li>3D array and multiple indices,</li><li>4D array and one index,</li><li>4D array and multiple indices.</li></ol><p>We should, therefore, define a method for each combination of input arguments. We can do this in the following way:</p><pre><code class="language-julia"># /src/ImageInspector.jl
image(x::AbstractArray{T,3}, inds; flip = true) where {T &lt;: Real} = [image(x[:,:,i]; flip) for i in inds]
image(x::AbstractArray{T,4}, inds; flip = true) where {T &lt;: Real} = [image(x[:,:,:,i]; flip) for i in inds]
image(x::AbstractArray{T,3}, ind::Int; flip = true) where {T &lt;: Real} = image(x, [ind]; flip)[1]
image(x::AbstractArray{T,4}, ind::Int; flip = true) where {T &lt;: Real} = image(x, [ind]; flip)[1]</code></pre><p>Since <code>x[:,:,i]</code> creates a new copy, it can be replaced by <code>selectdim(x, 3, i)</code>, which creates a view.</p><p></p></details><p><img alt="" src="../image_4.svg"/></p><h2 id="unit-testing"><a class="docs-heading-anchor" href="#unit-testing">Unit testing</a><a id="unit-testing-1"></a><a class="docs-heading-anchor-permalink" href="#unit-testing" title="Permalink"></a></h2><p>The previous section added the <code>image</code> function with multiple methods. We also manually tested if these methods work correctly. Even though this practice works for small projects, it is not optimal for code testing and should be automized by <a href="https://en.wikipedia.org/wiki/Unit_testing">unit testing</a>. The <code>Test</code> package from the standard library provides utility functions to simplify writing unit tests. Its core is the <code>@test</code> macro that tests if an expression evaluates as <code>true</code>.</p><pre><code class="language-julia-repl">julia&gt; using Test

julia&gt; @test 1 == 1
Test Passed

julia&gt; @test 1 == 3
Test Failed at none:1
  Expression: 1 == 3
   Evaluated: 1 == 3
ERROR: There was an error during testing</code></pre><p>It is possible to pass additional arguments to the <code>@test</code> macro.</p><pre><code class="language-julia-repl">julia&gt; @test Ï â 3.14 atol=0.01
Test Passed</code></pre><p>If we go back to our package, we can start writing tests for the methods of the <code>image</code> function. All tests should be located in the <code>/test</code> folder with its own environment. First, we have to import all necessary packages: <code>Test</code>, <code>ImageInspector</code> and <code>Colors</code>. Since we used <code>PkgTemplates</code> to generate the package, the <code>test</code> folder and the environment are both already generated. Moreover, the environment already contains the <code>Test</code> package. We do not have to add the <code>ImageInspector</code> package because it is added automatically. For simplicity, we use the environment from the <code>scripts</code> folder.</p><pre><code class="language-julia"># /test/runtests.jl
using ImageInspector
using Test
using ImageInspector.Colors</code></pre><p>We import <code>Colors</code> from the <code>ImageInspector</code> to use the same version. Now we define inputs and expected outputs for the <code>image</code> function.</p><pre><code class="language-julia"># /test/runtests.jl
x = [0.1 0.2; 0.3 0.4];
img = Gray.(x);
img_flipped = Gray.(x');</code></pre><p>Since the input to the <code>image</code> function is a matrix, we test the first method of the <code>image</code> function that creates grayscale images.</p><pre><code class="language-julia">julia&gt; @test image(x) == img_flipped
Test Passed

julia&gt; @test image(x; flip = false) == img
Test Passed

julia&gt; @test image(x; flip = true) == img_flipped
Test Passed</code></pre><p>Since all tests passed correctly, the message <code>Test Passed</code> is printed after each test. It is a good idea to group tests logically by the <code>@testset</code> macro.</p><pre><code class="language-julia"># /test/runtests.jl
julia&gt; @testset "image function" begin
           @test image(x) == img_flipped
           @test image(x; flip = false) == img
           @test image(x; flip = true) == img_flipped
       end
Test Summary:  | Pass  Total
image function |    3      3</code></pre><p>We use the <code>begin ... end</code> block to specify which tests should be grouped. Moreover, it is possible to combine the <code>@testset</code> macro and the <code>for</code> loop to perform multiple tests at once. For example, we may want to test the <code>image</code> function for different input images.</p><pre><code class="language-julia"># /test/runtests.jl
x1 = [0.1 0.2];
x2 = [0.1 0.2; 0.3 0.4];
x3 = [0.1 0.2 0.3; 0.4 0.5 0.6];
x4 = [0.1 0.2; 0.3 0.4; 0.5 0.6];
x5 = [0.1, 0.2];</code></pre><p>In such a case, we use nested test sets to group all tests. This approach has the advantage that each iteration of the loop is treated as a separate test set.</p><pre><code class="language-julia">julia&gt; @testset "image function" begin
           @testset "size(x) = $(size(x))" for x in [x1, x2, x3, x4, x5]
               img = Gray.(x);
               img_flipped = Gray.(x');
               @test image(x) == img_flipped
               @test image(x; flip = false) == img
               @test image(x; flip = true) == img_flipped
           end
       end
size(x) = (2,): Error During Test
[...]
Test Summary:      | Pass  Error  Total
image function     |   12      3     15
  size(x) = (1, 2) |    3             3
  size(x) = (2, 2) |    3             3
  size(x) = (2, 3) |    3             3
  size(x) = (3, 2) |    3             3
  size(x) = (2,)   |           3      3
ERROR: Some tests did not pass: 12 passed, 0 failed, 3 errored, 0 broken.</code></pre><p>Not all tests passed. The reason is that the variable <code>x5</code> is a vector. From the list of all methods defined for the <code>image</code> function, we see that there is no method for a vector.</p><pre><code class="language-julia">julia&gt; methods(image)
# 6 methods for generic function "image":
[1] image(x::AbstractArray{var"#s1",2} where var"#s1"&lt;:Real) in ImageInspector at [...]
[2] image(x::AbstractArray{T,3}; flip) where T&lt;:Real in ImageInspector at [...]
[3] image(x::AbstractArray{T,3}, ind::Int64; flip) where T&lt;:Real in ImageInspector at [...]
[4] image(x::AbstractArray{T,3}, inds; flip) where T&lt;:Real in ImageInspector at [...]
[5] image(x::AbstractArray{T,4}, ind::Int64; flip) where T&lt;:Real in ImageInspector at [...]
[6] image(x::AbstractArray{T,4}, inds; flip) where T&lt;:Real in ImageInspector at [...]</code></pre><p>If we pass a vector as an argument, the <code>MethodError</code> will appear. The <code>Test</code> package provides the <code>@test_throw</code> macro to test if the expression throws the correct exception.</p><pre><code class="language-julia">julia&gt; @test_throws MethodError image(x5)
Test Passed
      Thrown: MethodError</code></pre><p>The final testing file should be similar to the following one.</p><pre><code class="language-julia"># /test/runtests.jl
using ImageInspector
using ImageInspector.Colors
using Test

@testset "ImageInspector.jl" begin
    x1 = [0.1 0.2]
    x2 = [0.1 0.2; 0.3 0.4]
    x3 = [0.1 0.2 0.3; 0.4 0.5 0.6]
    x4 = [0.1 0.2; 0.3 0.4; 0.5 0.6]
    x5 = [0.1, 0.2]

    @testset "size(x) = $(size(x))" for x in [x1, x2, x3, x4]
        img = Gray.(x);
        img_flipped = Gray.(x');
        @test image(x) == img_flipped
        @test image(x; flip = false) == img
        @test image(x; flip = true) == img_flipped
    end

    @test_throws MethodError image(x5)
end</code></pre><p>There is <code>Project.toml</code> and <code>Manifest.toml</code> files in the <code>test</code> folder. Creating a different environment has the advantage that it may contain packages needed only for testing. We can run tests directly from the Pkg REPL by the <code>test</code> command.</p><pre><code class="language-julia">(scripts) pkg&gt; test ImageInspector
    Testing ImageInspector
Status `.../Project.toml`
  [...]
Status `.../Manifest.toml`
  [...]
Test Summary:     | Pass  Total
ImageInspector.jl |   13     13
    Testing ImageInspector tests passed</code></pre><h2 id="Writing-documentation"><a class="docs-heading-anchor" href="#Writing-documentation">Writing documentation</a><a id="Writing-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-documentation" title="Permalink"></a></h2><p>Writing documentation is a good coding practice. It helps others to understand your code. It may even help the author after working on the code after an extended break. The most used documentation type is the <a href="https://docs.julialang.org/en/v1/manual/documentation/">docstring</a>, a multiline string describing the functionality.</p><pre><code class="language-julia"># /src/ImageInspector.jl
"""
    image(x::AbstractMatrix{T}; flip = true)

Converts a matrix of real numbers to a matrix of `Gray` points. If the keyword argument
`flip` is true, the matrix is transposed.

# Example

```julia-repl
julia&gt; x = [0.1 0.25; 0.4 0.6]
2Ã2 Array{Float64,2}:
 0.1  0.25
 0.4  0.6

julia&gt; image(x)
2Ã2 Array{Gray{Float64},2} with eltype Gray{Float64}:
 Gray{Float64}(0.1)   Gray{Float64}(0.4)
 Gray{Float64}(0.25)  Gray{Float64}(0.6)

julia&gt; image(x; flip = false)
2Ã2 Array{Gray{Float64},2} with eltype Gray{Float64}:
 Gray{Float64}(0.1)  Gray{Float64}(0.25)
 Gray{Float64}(0.4)  Gray{Float64}(0.6)
```
"""
function image(x::AbstractMatrix{T}; flip = true) where {T &lt;: Real}
    xx = flip ? PermutedDimsArray(x, (2, 1)) : x
    return Gray.(xx)
end</code></pre><p>We first wrote a function header, and then we used one tab as an indentation. Then we wrote a short description of the function. Finally, we wrote usage examples. To get a well-looking format of the docstring, we use <a href="https://en.wikipedia.org/wiki/Markdown">markdown</a><code># Example</code> to represents a title. We use the <code>julia-repl</code> block to write code. Now we type the function name into the Julia help.</p><pre><code class="language-julia">help?&gt; image
search: image imag

  image(x::AbstractMatrix{T}; flip = true)

  Converts a matrix of real numbers to a matrix of `Gray` points. If the keyword argument
  `flip` is true, the matrix is transposed.

  Example
  â¡â¡â¡â¡â¡â¡â¡â¡â¡

  julia&gt; x = [0.1 0.25; 0.4 0.6]
  2Ã2 Array{Float64,2}:
   0.1  0.25
   0.4  0.6

  julia&gt; image(x)
  2Ã2 Array{Gray{Float64},2} with eltype Gray{Float64}:
   Gray{Float64}(0.1)   Gray{Float64}(0.4)
   Gray{Float64}(0.25)  Gray{Float64}(0.6)

  julia&gt; image(x; flip = false)
  2Ã2 Array{Gray{Float64},2} with eltype Gray{Float64}:
   Gray{Float64}(0.1)  Gray{Float64}(0.25)
   Gray{Float64}(0.4)  Gray{Float64}(0.6)</code></pre><div class="info-body"><header class="info-header">Creating reports</header><p></p><p>Reports may be written externally in Latex. However, when we want to show some code, it may be advantageous to write them directly in Julia and export them to <a href="https://jupyter.org/">Jupyter notebooks</a>. The <a href="https://fredrikekre.github.io/Literate.jl/v2/">Literate</a> package allows combining Julia code with the <a href="https://www.markdownguide.org/cheat-sheet">Markdown syntax</a> in a script. We mention the following code, which should be read with the soft wrapping on, as an example:</p><pre><code class="language-julia"># # ImageInspector

# ImageInspector is a small package for educational purposes. Its main goal is not presenting functionality, but presenting package structure. This is its short documentation created in the package [Literate](https://fredrikekre.github.io/Literate.jl/v2) which uses the [Markdown](https://www.markdownguide.org/cheat-sheet) syntax.

# To use the package, we need to load first the required packages.

using ImageInspector
using Plots

# ## Grayscale images

# As a test example, we create the real matrix `img1` representing a circle. We first discretize the domain $[-1,1]$ in `xs`. We assign black colour whenever $x^2 + y^2 \le 1$. Since the white colour is represented by `[1; 1; 1]` and the black colour by `[0; 0; 0]`, we can do it by the following code:

xs = -1:0.001:1
img1 = [x^2+y^2&gt;1 for x in xs, y in xs];

# This is a two-dimensional matrix, which represents a grayscale image. We convert it to an image by calling `image` and then we plot it.

plot(image(img1); axis = nothing, border = :none)
</code></pre><p>The Markdown syntax starts with <code>#</code>. Among others, it allows to use:</p><ul><li>Links such as <code>[Literate](https://fredrikekre.github.io/Literate.jl/v2)</code>.</li><li>Variables or latex syntax such as <code>$[-1,1]$</code>.</li></ul><p>Exporting the script into a notebook is simple.</p><pre><code class="language-julia">julia&gt; Literate.notebook("report.jl"; execute=false)</code></pre><p>The resulting notebook can be found at our <a href="https://github.com/JuliaTeachingCTU/ImageInspector.jl/blob/master/report/report.ipynb">Github</a>. All required data are in the <a href="https://github.com/JuliaTeachingCTU/ImageInspector.jl/tree/master/report">report folder</a>.</p><p></p></div><h2 id="Adding-content-2"><a class="docs-heading-anchor" href="#Adding-content-2">Adding content 2</a><a id="Adding-content-2-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-content-2" title="Permalink"></a></h2><p>We will add more functions to the <code>ImageInspector</code> package. To plot multiple images at once, we will define two functions. The first one computes an optimal grid size for a given number of images.</p><pre><code class="language-julia"># /src/ImageInspector.jl
function gridsize(n::Int; nrows::Int = -1, ncols::Int = - 1)
    if nrows &lt; 1
        if ncols &lt; 1
            nrows = round(Int, sqrt(n))
            ncols = ceil(Int, n / nrows)
        else
            nrows = ceil(Int, n / ncols)
        end
    else
        ncols = ceil(Int, n / nrows)
    end
    return nrows, ncols
end</code></pre><p>The second function consists of two methods and converts an array of real numbers to one big image of the appropriate colour type.</p><pre><code class="language-julia"># /src/ImageInspector.jl
imagegrid(x, ind::Int; flip = true, kwargs...) = image(x, ind; flip)

function imagegrid(x, inds; flip = true, sep = 1, kwargs...)
    imgs = image(x, inds; flip)
    n = length(imgs)
    nrows, ncols = gridsize(n; kwargs...)

    h, w = size(imgs[1])
    A = fill(
        eltype(imgs[1])(1), # white color in proper color type
        nrows*h + (nrows + 1)*sep, # height of the reculting image
        ncols*w + (ncols + 1)*sep, # width of the reculting image
    )

    for i in 1:nrows, j in 1:ncols
        k = j + (i - 1) * ncols
        k &gt; n &amp;&amp; break

        rows = (1:h) .+ (i - 1)*h .+ i*sep
        cols = (1:w) .+ (j - 1)*w .+ j*sep
        A[rows, cols] = imgs[k]
    end
    return A
end</code></pre><p>We use the <code>sep</code> keyword argument to specify the separator width between images. With all functions defined, we can test them.</p><pre><code class="language-julia"># /scripts/example.jl
x = FashionMNIST.traintensor(1:10);
plot(imagegrid(x, 1:10; nrows = 2, sep = 2); axis = nothing, border = :none)</code></pre><p><img alt="" src="../image_5.svg"/></p><div class="info-body"><header class="info-header">Optional dependencies</header><p></p><p>We used the same settings for the <code>plot</code> function in all previous examples. Therefore, it makes sense to write an auxiliary function setting attributes for the <code>plot</code> function. However, this function will depend on the <code>Plots</code> package, and if we add <code>Plots</code> to <code>ImageInspector</code>, it will significantly slow the loading time. The <code>Requires</code> package prevents explicit dependencies (and long load times) by allowing conditional code loading. In our case, we first add <code>Requires</code> to the <code>ImageInspector</code>.</p><pre><code class="language-julia">julia&gt; pwd()
".../ImageInspector"

(scripts) pkg&gt; activate .
 Activating environment at `/path/ImageInspector/Project.toml`

(ImageInspector) pkg&gt; add Requires
[...]

(ImageInspector) pkg&gt; activate

(scripts)</code></pre><p>Then we create a new file <code>/src/imageplot.jl</code> with the following content:</p><pre><code class="language-julia"># /src/imageplot.jl
using .Plots

export imageplot

imageplot(x; flip = true, kwargs...) =  imageplot(image(x; flip); kwargs...)

function imageplot(x, ind; flip = true, nrows = -1, ncols = -1, sep = 1, kwargs...)
    img = imagegrid(x, ind; flip, nrows, ncols, sep)
    return imageplot(img; kwargs...)
end

function imageplot(
    x::AbstractMatrix{&lt;:Color};
    legend = false,
    axis = nothing,
    border = :none,
    kwargs...
)
    return plot(x; legend, axis, border, kwargs...)
end</code></pre><p>We only defined a wrapper function for the <code>plot</code> function and exported this function. We use a relative path to the <code>Plots</code> package. Then we specify on which package the code depends by defining the <code>__init__()</code> function in the <code>/src/ImageInspector.jl</code> file.</p><pre><code class="language-julia"># /src/ImageInspector.jl
using Requires

function __init__()
    @require Plots="91a5bcdd-55d7-5caf-9e0b-520d859cae80" include("imageplot.jl")
end</code></pre><p>The <code>__init__</code> function has to contain the <code>@require</code> macro followed by the package name and its unique UUID (can be found in the <a href="https://github.com/JuliaRegistries/General">JuliaRegistries</a> for public packages) and the code that should be included.</p><p>Now we can start a new Julia session and test if the loading works properly. If we do not load <code>Plots</code>, the <code>imageplot</code> function will not be available, as can be seen below.</p><pre><code class="language-julia">julia&gt; x = CIFAR10.traintensor(1:10);

julia&gt; imageplot(x, 1:10; nrows = 2, sep = 2)
ERROR: UndefVarError: imageplot not defined</code></pre><p>After loading the <code>Plots</code> package, the <code>imageplot</code> function will start working.</p><pre><code class="language-julia">julia&gt; using Plots

julia&gt; imageplot(x, 1:10; nrows = 2, sep = 1, background = RGB(184/255, 223/255, 250/255))</code></pre><p><img alt="" src="../image_6.svg"/></p><p></p></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pkg/">Â« Package manager</a><a class="docs-footer-nextpage" href="../../final_project/homeworks/">Homework Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 26 April 2021 20:33">Monday 26 April 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>