<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scope of variables · Julia for Optimization and Learning</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Optimization and Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Optimization and Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Julia for Optimization and Learning</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Data structures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_02/tuples/">Tuples and named tuples</a></li><li><a class="tocitem" href="../../lecture_02/dictionaries/">Dictionaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_03/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li class="is-active"><a class="tocitem" href>Scope of variables</a><ul class="internal"><li><a class="tocitem" href="#Local-scope"><span>Local scope</span></a></li><li><a class="tocitem" href="#Global-scope"><span>Global scope</span></a></li></ul></li><li><a class="tocitem" href="../exceptions/">Exception handling</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_05/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_05/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_05/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_05/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_06/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_07/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_07/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_08/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_08/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../../lecture_09/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_09/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">11: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_11/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../../lecture_11/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_11/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">12: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/sparse/">Linear regression with sparse constraints</a></li><li><a class="tocitem" href="../../lecture_12/monte/">Monte Carlo sampling</a></li><li><a class="tocitem" href="../../lecture_12/glm/">Linear regression revisited</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">13: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_13/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_13/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_13/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_13/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">4: Functions and methods</a></li><li class="is-active"><a href>Scope of variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scope of variables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Julia-for-Optimization-and-Learning/blob/master/docs/src/lecture_04/scope.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scope-of-variables"><a class="docs-heading-anchor" href="#Scope-of-variables">Scope of variables</a><a id="Scope-of-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Scope-of-variables" title="Permalink"></a></h1><p>The scope of a variable is the region of a code where the variable is visible. There are two main scopes in Julia: <strong>global</strong> and <strong>local</strong>. The global scope can contain multiple local scope blocks. Local scope blocks can be nested. There is also a distinction in Julia between constructs which introduce a <em>hard scope</em> and those which only introduce a <em>soft scope</em>. This affects whether shadowing a global variable by the same name is allowed.</p><p>The following table shows constructs that introduce scope blocks.</p><table><tr><th style="text-align: left">Construct</th><th style="text-align: left">Scope type</th><th style="text-align: center">Allowed within local</th></tr><tr><td style="text-align: left"><code>module</code>, <code>baremodule</code></td><td style="text-align: left">global</td><td style="text-align: center">✗</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left">local (soft)</td><td style="text-align: center">✗</td></tr><tr><td style="text-align: left"><code>macro</code></td><td style="text-align: left">local (hard)</td><td style="text-align: center">✗</td></tr><tr><td style="text-align: left"><code>for</code>, <code>while</code>, <code>try</code></td><td style="text-align: left">local (soft)</td><td style="text-align: center">✔</td></tr><tr><td style="text-align: left"><code>let</code>, <code>functions</code>, <code>comprehensions</code>, <code>generators</code></td><td style="text-align: left">local (hard)</td><td style="text-align: center">✔</td></tr></table><p>This table contains several constructs which we have not introduced yet. Modules and structures will be discussed later in the course. The rest is described in the official <a href="https://docs.julialang.org/">documentation</a>.</p><h2 id="Local-scope"><a class="docs-heading-anchor" href="#Local-scope">Local scope</a><a id="Local-scope-1"></a><a class="docs-heading-anchor-permalink" href="#Local-scope" title="Permalink"></a></h2><p>A function declaration introduces a new (hard) local scope. It means that all variables defined inside a function body can be accessed and modified inside the function body. Moreover, it is impossible to access these variables from outside the function.</p><pre><code class="language-julia-repl hljs">julia&gt; function f()
           z = 42
           return
       end
f (generic function with 1 method)

julia&gt; f()

julia&gt; z
ERROR: UndefVarError: z not defined</code></pre><p>Thanks to this property, we can use the names most suitable for our variables (i, x, y, etc.) without the risk of clashing with declarations elsewhere. It is possible to specify a global variable inside a function by the <code>global</code> keyword.</p><pre><code class="language-julia-repl hljs">julia&gt; function f()
           global z = 42
           return
       end
f (generic function with 1 method)

julia&gt; f()

julia&gt; z
42</code></pre><p>However, this is not recommended.  If we need a variable defined inside a function, we should probably return that variable as an output of the function</p><pre><code class="language-julia-repl hljs">julia&gt; function f()
           z = 42
           return z
       end
f (generic function with 1 method)

julia&gt; z = f()
42

julia&gt; z
42</code></pre><p>In the example above, the <code>z</code> variable in the function is local, and the <code>z</code> variable outside of the function is global. These two variables are not the same.</p><h2 id="Global-scope"><a class="docs-heading-anchor" href="#Global-scope">Global scope</a><a id="Global-scope-1"></a><a class="docs-heading-anchor-permalink" href="#Global-scope" title="Permalink"></a></h2><p>Each module introduces a new global scope, separate from the global scope of all other modules. The interactive prompt (aka REPL) is in the global scope of the module <code>Main</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; module A
           a = 1 # a global in A&#39;s scope
           b = 2 # b global in A&#39;s scope
       end
A

julia&gt; a # errors as Main&#39;s global scope is separate from A&#39;s
ERROR: UndefVarError: a not defined</code></pre><p>Modules can introduce variables of other modules into their scope through the <code>using</code> (or <code>import</code>)  keyword. Variables can be accessed by the dot-notation.</p><pre><code class="language-julia-repl hljs">julia&gt; using .A: b # make variable b from module A available

julia&gt; A.a
1

julia&gt; b
2</code></pre><p>While variables can be read externally, they can only be changed within the module they belong to.</p><pre><code class="language-julia-repl hljs">julia&gt; b = 4
ERROR: cannot assign a value to variable A.b from module Main</code></pre><p>Global scope variables can be accessed anywhere inside the global scope, even in the local scopes defined in that global scope. In the following example, we define a variable <code>c</code> in the <code>Main</code> global scope, and then we define a function <code>foo</code> (that introduces a new local scope inside the <code>Main</code> global scope), and inside this function, we use the variable <code>c</code>,</p><pre><code class="language-julia-repl hljs">julia&gt; c = 10
10

julia&gt; foo(x) = x + c
foo (generic function with 1 method)

julia&gt; foo(1)
11</code></pre><p>However, it is not recommended to use global variables in this way. The reason is that global variables can change their type and value at any time, and therefore they cannot be properly optimized by the compiler. We can see the performance drop in a simple test.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = rand(10);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = rand(10);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_global() = x .+ y</code><code class="nohighlight hljs ansi" style="display:block;">f_global (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_local(x, y) = x .+ y</code><code class="nohighlight hljs ansi" style="display:block;">f_local (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hcat(f_global(), f_local(x, y))</code><code class="nohighlight hljs ansi" style="display:block;">10×2 Matrix{Float64}:
 1.89616   1.89616
 0.284349  0.284349
 0.456247  0.456247
 0.759255  0.759255
 0.790209  0.790209
 0.818517  0.818517
 0.66298   0.66298
 1.05148   1.05148
 0.874654  0.874654
 0.762087  0.762087</code></pre><p>In the example above, we defined two functions that do the same thing. The first function has no arguments and returns a sum of two global variables, <code>x</code> and <code>y</code>. The second function also returns a sum of variables <code>x</code> and <code>y</code>. However, in this case, these variables are local since they are introduced as the inputs to the function. If we use the <code>@time</code> macro, we can measure the time needed to call these two functions.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time f_global();</code><code class="nohighlight hljs ansi" style="display:block;">  0.000025 seconds (3 allocations: 224 bytes)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time f_local(x, y);</code><code class="nohighlight hljs ansi" style="display:block;">  0.000009 seconds (1 allocation: 160 bytes)</code></pre><p>The second function is faster and also needs fewer allocations. The reason is that when we call the <code>f_local</code> function for the first time, the function is optimized for the given arguments. Each time a function is called for the first time with new types of arguments, it is compiled. This can be seen in the following example: the first call is slower due to the compilation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a, b = 1:10, 11:20;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time f_local(a, b);</code><code class="nohighlight hljs ansi" style="display:block;">  0.023893 seconds (38.13 k allocations: 2.367 MiB, 99.88% compilation time)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time f_local(a, b);</code><code class="nohighlight hljs ansi" style="display:block;">  0.000007 seconds (1 allocation: 32 bytes)</code></pre><p>On the other hand, the <code>f_global</code> function cannot be optimized because it contains two global variables, and these two variables can change at any time.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../methods/">« Methods</a><a class="docs-footer-nextpage" href="../exceptions/">Exception handling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Wednesday 29 September 2021 16:09">Wednesday 29 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
