<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elementary functions Â· Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../variables/">Variables</a></li><li class="is-active"><a class="tocitem" href>Elementary functions</a><ul class="internal"><li><a class="tocitem" href="#Arithmetic-operators"><span>Arithmetic operators</span></a></li><li><a class="tocitem" href="#Promotion-system"><span>Promotion system</span></a></li><li><a class="tocitem" href="#Updating-operators"><span>Updating operators</span></a></li><li><a class="tocitem" href="#Numeric-comparison"><span>Numeric comparison</span></a></li><li><a class="tocitem" href="#Rounding-functions"><span>Rounding functions</span></a></li><li><a class="tocitem" href="#Numerical-conversions"><span>Numerical conversions</span></a></li></ul></li><li><a class="tocitem" href="../strings/">Strings</a></li><li><a class="tocitem" href="../arrays/">Arrays</a></li><li><a class="tocitem" href="../data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composit types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_06/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_06/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Statistics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">1: Variables and basic operators</a></li><li class="is-active"><a href>Elementary functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Elementary functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_01/operators.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Arithmetic-operators"><a class="docs-heading-anchor" href="#Arithmetic-operators">Arithmetic operators</a><a id="Arithmetic-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operators" title="Permalink"></a></h2><p>Basic arithmetic operations are defined in Julia standard libraries, and all these operators are supported on all primitive <a href="../variables/#Primitive-numeric-types">numeric types</a></p><table><tr><th style="text-align: left">Expression</th><th style="text-align: left">Name</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>x + y</code></td><td style="text-align: left">binary plus</td><td style="text-align: left">performs addition</td></tr><tr><td style="text-align: left"><code>x - y</code></td><td style="text-align: left">binary minus</td><td style="text-align: left">performs subtraction</td></tr><tr><td style="text-align: left"><code>x * y</code></td><td style="text-align: left">times</td><td style="text-align: left">performs multiplication</td></tr><tr><td style="text-align: left"><code>x / y</code></td><td style="text-align: left">divide</td><td style="text-align: left">performs division</td></tr><tr><td style="text-align: left"><code>x Ã· y</code></td><td style="text-align: left">integer divide</td><td style="text-align: left"><code>x / y</code>, truncated to an integer</td></tr><tr><td style="text-align: left"><code>x \ y</code></td><td style="text-align: left">inverse divide</td><td style="text-align: left">equivalent to <code>y / x</code></td></tr><tr><td style="text-align: left"><code>x ^ y</code></td><td style="text-align: left">power</td><td style="text-align: left">raises <code>x</code> to the <code>y</code>th power</td></tr><tr><td style="text-align: left"><code>x % y</code></td><td style="text-align: left">remainder</td><td style="text-align: left">equivalent to <code>rem(x,y)</code></td></tr></table><p>Here are some simple examples using arithmetic operators</p><pre><code class="language-julia-repl">julia&gt; 1 + 2
3

julia&gt; 2*3
6

julia&gt; 4/3
1.3333333333333333</code></pre><p>All of these operators can also be applied directly to any variable that represents a numeric value</p><pre><code class="language-julia-repl">julia&gt; x = 1;

julia&gt; y = 3;

julia&gt; (x + 2)/(y - 1) - 4*(x - 2)^2
-2.5</code></pre><p>Note that we use a semicolon after some expressions. In the REPL, if we evaluate any expression, its result is printed. If we use the semicolon, the output is omitted. It is similar behaviour as in Matlab, but in Julia, the printing is automatic only in the REPL.</p><p>A numeric literal placed directly before an identifier or parentheses is treated as multiplication</p><pre><code class="language-julia-repl">julia&gt; 2(3 + 4) # equivalent to 2*(3 + 4)
14</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Determine the value and type of <code>y</code> given by the following expression</p><p class="math-container">\[y = \frac{(x + 2)^2 - 4}{(x - 2)^{p - 2}},\]</p><p>where <code>x = 4</code> and <code>p = 5</code>.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we define variables <code>x</code> and <code>p</code></p><pre><code class="language-julia-repl">julia&gt; x = 4
4

julia&gt; p = 5
5</code></pre><p>then we can use the combination of basic arithmetic operators to compute the value of <code>y</code></p><pre><code class="language-julia-repl">julia&gt; y = ((x + 2)^2 - 4)/(x - 2)^(p - 2)
4.0</code></pre><p>The type of <code>y</code> can be determined using the <code>typeof</code> function</p><pre><code class="language-julia-repl">julia&gt; typeof(y)
Float64</code></pre><p>Note that the resulting type of <code>y</code> is <code>Float64</code> even though the result can be represented as an integer. The reason is that we divide two integers</p><pre><code class="language-julia-repl">julia&gt; typeof((x + 2)^2 - 4)
Int64

julia&gt; typeof((x - 2)^(p - 2))
Int64</code></pre><p>Because this operation generally does not result in an integer, dividing two integers always returns a floating-point number. If we want to get an integer, we can use the integer division operator <code>Ã·</code> (can be typed as <code>\div&lt;tab&gt;</code>)</p><pre><code class="language-julia-repl">julia&gt; y_int = ((x + 2)^2 - 4)Ã·(x - 2)^(p - 2)
4

julia&gt; typeof(y_int)
Int64</code></pre></p></details><h2 id="Promotion-system"><a class="docs-heading-anchor" href="#Promotion-system">Promotion system</a><a id="Promotion-system-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion-system" title="Permalink"></a></h2><p>The section about <a href="../variables/#Primitive-numeric-types">variables</a> showed that there are many numeric types in Julia. To ensure that the correct type is always used, Julia has a promotion system that converts input values of mixed types to a type that can correctly represent all values. The promotion of mixed type variables can be done manually using the <code>promote</code> function. As an example, we can mention the promotion of multiple numeric types</p><pre><code class="language-julia-repl">julia&gt; x = 1.0 # Float64
1.0

julia&gt; y = 2 # Int64
2

julia&gt; xp, yp = promote(x, y)
(1.0, 2.0)</code></pre><p>In this case, the resulting type of variables <code>xp</code> and <code>yp</code> is <code>Float64</code> as can be checked using the <code>typeof</code> function</p><pre><code class="language-julia-repl">julia&gt; typeof(xp)
Float64

julia&gt; typeof(yp)
Float64</code></pre><p>Strictly speaking, not all <code>Int64</code> values can be represented exactly as <code>Float64</code> values. The promotion system generally tries to return a type that approximates well most values of either input type.</p><p>The <code>promote</code> function accepts any number of input arguments</p><pre><code class="language-julia-repl">julia&gt; promote(1, 2f0, true, 4.5, Int32(1))
(1.0, 2.0, 1.0, 4.5, 1.0)</code></pre><p>The resulting type of promotion can be determined by the <code>promotion_type</code> function. This function is similar to the <code>promote</code> function and will accept any number of input arguments, but the inputs have to be types and not values</p><pre><code class="language-julia-repl">julia&gt; promote_type(Float64, Int64, Bool, Int32)
Float64</code></pre><p>Although this may seem complicated, type promotion is done automatically in most cases, and the user does not have to worry about it. To demonstrate the promotion system in practice, consider the following example: we sum the value of type <code>Int64</code> with the value of type <code>Float32</code></p><pre><code class="language-julia-repl">julia&gt; x = 1 # Int64
1

julia&gt; y = 2f0 # Float32
2.0f0</code></pre><p>Since the &quot;smallest&quot; type that can represent both values correctly is <code>Float32</code>, the result is of type <code>Float32</code></p><pre><code class="language-julia-repl">julia&gt; z = x + y
3.0f0

julia&gt; typeof(z)
Float32</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>All of these values represent number <span>$1$</span>. Determine the smallest type which can represent them.</p><pre><code class="language-julia">x = 1
y = 1f0
z = true
w = Int32(1)</code></pre></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>To get the correct promotion type, we can use a combination of the <code>promote</code> and <code>typeof</code> functions</p><pre><code class="language-julia-repl">julia&gt; xp, yp, zp, wp = promote(x, y, z, w)
(1.0f0, 1.0f0, 1.0f0, 1.0f0)

julia&gt; typeof(xp)
Float32</code></pre><p>or the <code>promote_type</code> and <code>typeof</code> functions</p><pre><code class="language-julia-repl">julia&gt; promote_type(typeof(x), typeof(y), typeof(z), typeof(w))
Float32</code></pre></p></details><h2 id="Updating-operators"><a class="docs-heading-anchor" href="#Updating-operators">Updating operators</a><a id="Updating-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-operators" title="Permalink"></a></h2><p>Every binary arithmetic operator also has an updating version that assigns the operation&#39;s result back into its left operand. The updating version of the binary operator is formed by placing a <code>=</code> symbol immediately after the operator. For example, writing <code>x += 3</code> is equivalent to writing <code>x = x + 3</code></p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3 # x = x + 3
4

julia&gt; x *= 4 # x = x * 4
16

julia&gt; x /= 2 # x = x / 2
8.0

julia&gt; x \= 16 # x = x \ 16 = 16 / x
2.0</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Compute the value of <code>y</code> given by the following expression</p><p class="math-container">\[y = \frac{(x + 4)^{\frac{3}{2}}}{(x + 1)^{p - 1}},\]</p><p>where <code>x = 5</code> and <code>p = 3</code>. Then multiply the result by <code>8</code>, add <code>3</code>, divide by <code>3</code>, and subtract <code>1</code>. What are all the intermediate results and the final result?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we calculate the value of <code>y</code></p><pre><code class="language-julia-repl">julia&gt; x = 5;

julia&gt; p = 3;

julia&gt; y = (x + 4)^(3/2)/(x + 1)^(p - 1)
0.75</code></pre><p>Then we can use the update operators to get all the intermediate results as well as the final result</p><pre><code class="language-julia-repl">julia&gt; y *= 8
6.0

julia&gt; y += 3
9.0

julia&gt; y /= 3
3.0

julia&gt; y -= 1
2.0</code></pre></p></details><h2 id="Numeric-comparison"><a class="docs-heading-anchor" href="#Numeric-comparison">Numeric comparison</a><a id="Numeric-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-comparison" title="Permalink"></a></h2><p>In addition to arithmetic and updating operators, basic comparison operators are also defined in Julia&#39;s standard libraries.</p><table><tr><th style="text-align: left">Operator</th><th style="text-align: left">Name</th></tr><tr><td style="text-align: left"><code>==</code></td><td style="text-align: left">equality</td></tr><tr><td style="text-align: left"><code>!=</code>, <code>â </code></td><td style="text-align: left">inequality</td></tr><tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">less than</td></tr><tr><td style="text-align: left"><code>&lt;=</code>, <code>â¤</code></td><td style="text-align: left">less than or equal to</td></tr><tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">greater than</td></tr><tr><td style="text-align: left"><code>&gt;=</code>, <code>â¥</code></td><td style="text-align: left">greater than or equal to</td></tr><tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left">bitwise and</td></tr><tr><td style="text-align: left"><code>|</code></td><td style="text-align: left">bitwise or</td></tr></table><p>All these operators always return a boolean value (<code>true</code> or <code>false</code>) as the following example shows</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 â¥ 1
false</code></pre><p>In most programming languages, comparison operators are strictly binary, i.e., they can be used to compare only two values at a time. As an example, we can use a comparison of three numbers in Matlab</p><pre><code class="language-matlab">&gt;&gt; 3 &gt; 2 &gt; 1

ans =

  logical

   0</code></pre><p>Even though the condition holds, the result is <code>false</code> (logical <code>0</code>). The correct way to write such a condition in Matlab is as follows</p><pre><code class="language-matlab">&gt;&gt; 3 &gt; 2 &amp; 2 &gt; 1

ans =

  logical

   1</code></pre><p>In Julia (and Python, for example), both ways of writing conditions are correct and lead to the same result</p><pre><code class="language-julia-repl">julia&gt; 3 &gt; 2 &gt; 1
true

julia&gt; 3 &gt; 2 &amp; 2 &gt; 1
true</code></pre><p>In fact, comparison operators can be arbitrarily chained as in the following example</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>In general, the user should always try to write code that is easy to read. Even though writing expressions as in the example above is possible, the user should always consider if it is necessary.</p><p>Comparison of special values such as <code>NaN</code> can lead to unexpected behaviour</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false</code></pre><p>To avoid unexpected result, Julia provides additional functions to compare numbers for special values</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Tests if</th></tr><tr><td style="text-align: left"><code>isequal(x, y)</code></td><td style="text-align: left"><code>x</code> and <code>y</code> are identical</td></tr><tr><td style="text-align: left"><code>isfinite(x)</code></td><td style="text-align: left"><code>x</code> is a finite number</td></tr><tr><td style="text-align: left"><code>isinf(x)</code></td><td style="text-align: left"><code>x</code> is infinite</td></tr><tr><td style="text-align: left"><code>isnan(x)</code></td><td style="text-align: left"><code>x</code> is not a number</td></tr></table><p>Function <code>isequal</code> considers <code>NaN</code>s equal to each other</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; !isequal(NaN, NaN)
false</code></pre><p>We used the operator <code>!</code> to negate the output of the <code>isequal</code> function in the example above. This operator is called boolean not and can be used to negate boolean values</p><pre><code class="language-julia-repl">julia&gt; !true
false

julia&gt; !false
true</code></pre><h2 id="Rounding-functions"><a class="docs-heading-anchor" href="#Rounding-functions">Rounding functions</a><a id="Rounding-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding-functions" title="Permalink"></a></h2><p>Julia provides several functions for rounding numbers, as can be seen in the following table</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>round(x)</code></td><td style="text-align: left">round <code>x</code> to the nearest integer</td></tr><tr><td style="text-align: left"><code>floor(x)</code></td><td style="text-align: left">round <code>x</code> towards <code>-Inf</code></td></tr><tr><td style="text-align: left"><code>ceil(x)</code></td><td style="text-align: left">round <code>x</code> towards <code>+Inf</code></td></tr><tr><td style="text-align: left"><code>trunc(x)</code></td><td style="text-align: left">round <code>x</code> towards <code>zero</code></td></tr></table><p>These functions can be used without specifying output types. In such a case, the output has the same type as the input variable</p><pre><code class="language-julia-repl">julia&gt; x = 3141.5926
3141.5926

julia&gt; round(x)
3142.0

julia&gt; floor(x)
3141.0

julia&gt; ceil(x)
3142.0</code></pre><p>However, in many cases, it makes sense to convert the rounded value to a different type. For example, if the rounded value can be represented as an integer, it makes sense to convert the rounded value to an integer. The output type (only subtypes of <code>Integer</code> with the exception of <code>Bool</code>) can be passed as the first argument to all rounding functions from the table above</p><pre><code class="language-julia-repl">julia&gt; round(Int64, x)
3142

julia&gt; floor(Int32, x)
3141

julia&gt; ceil(Int16, x)
3142</code></pre><p>All rounding functions also support additional keyword arguments:</p><ul><li>If the <code>digits</code> keyword argument is provided, it rounds to the specified number of digits after the decimal place in the base specified by the <code>base</code> keyword argument.</li></ul><pre><code class="language-julia-repl">julia&gt; round(x; digits = 3)
3141.593</code></pre><ul><li>If the <code>sigdigits</code> keyword argument is provided, it rounds to the specified number of significant digits in the base specified by the <code>base</code> keyword argument.</li></ul><pre><code class="language-julia-repl">julia&gt; round(x; sigdigits = 3)
3140.0</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use rounding functions to solve the following tasks:</p><ul><li>Round <code>1252.1518</code> to the nearest larger integer and convert the resulting value to <code>Int64</code>.</li><li>Round <code>1252.1518</code> to the nearest smaller integer and convert the resulting value to <code>Int16</code>.</li><li>Round <code>1252.1518</code> to <code>2</code> digits after the decimal point.</li><li>Round <code>1252.1518</code> to <code>3</code> significant digits.</li></ul></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The <code>ceil</code> function rounds numbers to the nearest larger value, and since we want the result to be of type <code>Int64</code>, we have to pass this type as a first argument</p><pre><code class="language-julia-repl">julia&gt; x = 1252.1518
1252.1518

julia&gt; ceil(Int64, x)
1253</code></pre><p>Similarly, the floor function rounds numbers to the nearest smaller value</p><pre><code class="language-julia-repl">julia&gt; floor(Int16, x)
1252</code></pre><p>The number of digits after the decimal point can be controlled using the <code>digits</code> keyword</p><pre><code class="language-julia-repl">julia&gt; round(x; digits = 2)
1252.15</code></pre><p>and the number of significant digits using the <code>sigdigits</code> keyword</p><pre><code class="language-julia-repl">julia&gt; round(x; sigdigits = 3)
1250.0</code></pre></p></details><h2 id="Numerical-conversions"><a class="docs-heading-anchor" href="#Numerical-conversions">Numerical conversions</a><a id="Numerical-conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-conversions" title="Permalink"></a></h2><p>The previous section showed that numerical conversions could be done by using rounding functions with a specified type of output variable. This works only for converting floating-point numbers to integers. Julia also provides a more general way of how to perform conversions between different (not only numerical) types: notation <code>T(x)</code> or <code>convert(T,x)</code> converts <code>x</code> to a value of type <code>T</code>.</p><ul><li>If <code>T</code> is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity</li></ul><pre><code class="language-julia-repl">julia&gt; convert(Float32, 1.234)
1.234f0

julia&gt; Float32(1.234)
1.234f0</code></pre><ul><li>If <code>T</code> is an integer type, an <code>InexactError</code> is raised if <code>x</code> is not representable by <code>T</code></li></ul><pre><code class="language-julia-repl">julia&gt; convert(Int64, 1.0)
1

julia&gt; Int64(1.0)
1

julia&gt; convert(Int64, 1.234)
ERROR: InexactError: Int64(1.234)
[...]

julia&gt; Int64(1.234)
ERROR: InexactError: Int64(1.234)
[...]</code></pre><p>Conversion to other types works in a similar way.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use the proper numeric conversion to get the correct result (not approximate) of summing the following two numbers</p><pre><code class="language-julia">x = 1//3
y = 0.5</code></pre><p><strong>Hint:</strong> rational numbers can be summed without approximation.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Firstly, we can try just to sum the given numbers</p><pre><code class="language-julia-repl">julia&gt; x + y
0.8333333333333333</code></pre><p>The result of this operation is a floating-point number. However, in this specific case, we have a rational number and a floating-point number that can also be represented as a rational number. The exact result can be obtained by converting the variable <code>y</code> to a rational number</p><pre><code class="language-julia-repl">julia&gt; x + Rational(y)
5//6</code></pre></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variables/">Â« Variables</a><a class="docs-footer-nextpage" href="../strings/">Strings Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 21 March 2021 11:12">Sunday 21 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
