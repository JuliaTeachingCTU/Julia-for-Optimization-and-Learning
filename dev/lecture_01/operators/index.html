<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical operations and Elementary functions · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why_julia/">Why Julia?</a></li><li><a class="tocitem" href="../../howto/">How to...</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../variables/">Variables</a></li><li class="is-active"><a class="tocitem" href>Mathematical operations and Elementary functions</a><ul class="internal"><li><a class="tocitem" href="#Arithmetic-operators"><span>Arithmetic operators</span></a></li><li><a class="tocitem" href="#Promotion-system"><span>Promotion system</span></a></li><li><a class="tocitem" href="#Updating-operators"><span>Updating operators</span></a></li><li><a class="tocitem" href="#Numeric-comparison"><span>Numeric comparison</span></a></li><li><a class="tocitem" href="#Rounding-functions"><span>Rounding functions</span></a></li><li><a class="tocitem" href="#Numerical-Conversions"><span>Numerical Conversions</span></a></li></ul></li><li><a class="tocitem" href="../arrays/">Arrays</a></li><li><a class="tocitem" href="../data_structures/">Data structures</a></li><li><a class="tocitem" href="../strings/">Strings</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluation</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">4: Composite types and constructors</span></li><li><span class="tocitem">5: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Useful packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_06/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_06/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Theory of optimization</a></li><li><a class="tocitem" href="../../lecture_07/gradients/">Visualization of gradients</a></li><li><a class="tocitem" href="../../lecture_07/numerical_methods/">Numerical methods</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">10: Neural networks II.</span></li><li><span class="tocitem">11: Ordinary differential equations</span></li><li><span class="tocitem">12: Statistics I.</span></li><li><span class="tocitem">13: Statistics II.</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">1: Variables and basic operators</a></li><li class="is-active"><a href>Mathematical operations and Elementary functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical operations and Elementary functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_01/operators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-operations-and-Elementary-functions"><a class="docs-heading-anchor" href="#Mathematical-operations-and-Elementary-functions">Mathematical operations and Elementary functions</a><a id="Mathematical-operations-and-Elementary-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-operations-and-Elementary-functions" title="Permalink"></a></h1><h2 id="Arithmetic-operators"><a class="docs-heading-anchor" href="#Arithmetic-operators">Arithmetic operators</a><a id="Arithmetic-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operators" title="Permalink"></a></h2><p>Basic arithmetic operations are defined in Julia standard libraries and all these operators are supported on all primitive <a href="../variables/#Primitive-numeric-types">numeric types</a></p><table><tr><th style="text-align: left">Expression</th><th style="text-align: left">Name</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>x + y</code></td><td style="text-align: left">binary plus</td><td style="text-align: left">performs addition</td></tr><tr><td style="text-align: left"><code>x - y</code></td><td style="text-align: left">binary minus</td><td style="text-align: left">performs subtraction</td></tr><tr><td style="text-align: left"><code>x * y</code></td><td style="text-align: left">times</td><td style="text-align: left">performs multiplication</td></tr><tr><td style="text-align: left"><code>x / y</code></td><td style="text-align: left">divide</td><td style="text-align: left">performs division</td></tr><tr><td style="text-align: left"><code>x ÷ y</code></td><td style="text-align: left">integer divide</td><td style="text-align: left"><code>x / y</code>, truncated to an integer</td></tr><tr><td style="text-align: left"><code>x \ y</code></td><td style="text-align: left">inverse divide</td><td style="text-align: left">equivalent to <code>y / x</code></td></tr><tr><td style="text-align: left"><code>x ^ y</code></td><td style="text-align: left">power</td><td style="text-align: left">raises <code>x</code> to the <code>y</code>th power</td></tr><tr><td style="text-align: left"><code>x % y</code></td><td style="text-align: left">remainder</td><td style="text-align: left">equivalent to <code>rem(x,y)</code></td></tr></table><p>Here are some simple examples using arithmetic operators</p><pre><code class="language-julia-repl">julia&gt; 1 + 2
3

julia&gt; 2*3
6

julia&gt; 4/3
1.3333333333333333</code></pre><p>All of these operators can be also applied directly to any variable that represents numeric value</p><pre><code class="language-julia-repl">julia&gt; x = 1;

julia&gt; y = 3;

julia&gt; (x + 2)/(y - 1) - 4*(x - 2)^2
-2.5</code></pre><p>A numeric literal placed directly before an identifier or parentheses is treated as a multiplication (except with higher precedence than other binary operations):</p><pre><code class="language-julia-repl">julia&gt; 2(3 + 4) # equivalent to 2*(3 + 4)
14</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>What is the value and type of <code>y</code> given by the following expression</p><p class="math-container">\[y = \frac{(x + 2)^2 - 4}{(x - 2)^{p - 2}},\]</p><p>where <code>x = 4</code> and <code>p = 5</code>.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we define variables <code>x</code> and <code>p</code></p><pre><code class="language-julia-repl">julia&gt; x = 4
4

julia&gt; p = 5
5</code></pre><p>and then we can simply use the combination of basic arithmetic operators to compute the value of <code>y</code></p><pre><code class="language-julia-repl">julia&gt; y = ((x + 2)^2 - 4)/(x - 2)^(p - 2)
4.0</code></pre><p>The type of <code>y</code> can be determined using <code>typeof</code> function</p><pre><code class="language-julia-repl">julia&gt; typeof(y)
Float64</code></pre><p>Note that the resulting type of <code>y</code> is <code>Float64</code> even though the result can be represented as an integer. The reason is, that we divide two integers</p><pre><code class="language-julia-repl">julia&gt; typeof((x + 2)^2 - 4)
Int64

julia&gt; typeof((x - 2)^(p - 2))
Int64</code></pre><p>Because this operation generally does not result in an integer, dividing two integers always returns a floating-point number.</p></p></details><h2 id="Promotion-system"><a class="docs-heading-anchor" href="#Promotion-system">Promotion system</a><a id="Promotion-system-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion-system" title="Permalink"></a></h2><p>As said in the section about <a href="../variables/#Primitive-numeric-types">variables</a>, there are many numeric types in Julia. To ensure that the correct type is always used, Julia has a promotion system that converts input values of mixed types to a type that can correctly represent all values. This can be done by <code>promote</code> function. As an example, we can mention the conversion of multiple numeric types</p><pre><code class="language-julia-repl">julia&gt; x = 1.0 # Float64
1.0

julia&gt; y = 2 # Int64
2

julia&gt; xp, yp = promote(x, y)
(1.0, 2.0)</code></pre><p>In this case, the resulting type of variables <code>xp</code> and <code>yp</code> is <code>Float64</code> as can be chcked using <code>typeof</code> function</p><pre><code class="language-julia-repl">julia&gt; typeof(xp)
Float64

julia&gt; typeof(yp)
Float64</code></pre><p>even though strictly, not all <code>Int64</code> values can be represented exactly as <code>Float64</code> values. The promotion system generally tries to return a type that can at least approximate most values of either input type without excessively widening.</p><p>Note, that <code>promotion</code> function will accept any number of input arguments</p><pre><code class="language-julia-repl">julia&gt; promote(1, 2f0, true, 4.5, Int32(1))
(1.0, 2.0, 1.0, 4.5, 1.0)</code></pre><p>The resulting type of promotion can be determined by <code>promotion_type</code> function. This function is similar to <code>promote</code> function and will accept any number of input arguments, but the inputs have to be types and not values.</p><pre><code class="language-julia-repl">julia&gt; promote_type(Float64, Int64, Bool, Int32)
Float64</code></pre><p>Although this may seem complicated, type promotion is done automatically in most cases and the user does not have to worry about it. This can be demonstrated in the following example, where we sum two values. The first one is of type <code>Int64</code> and the second one of type <code>Float32</code>.</p><pre><code class="language-julia-repl">julia&gt; x = 1 # Int64
1

julia&gt; y = 2f0 # Float32
2.0f0</code></pre><p>Since the &quot;smallest&quot; type that can represent both values correctly is <code>Float32</code>, the result is of type <code>Float32</code></p><pre><code class="language-julia-repl">julia&gt; z = x + y
3.0f0

julia&gt; typeof(z)
Float32</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>What is the smallest type, that can represent the following values</p><pre><code class="language-julia">x = 1
y = 2f0
z = true
w = Int32(1)</code></pre></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>To get the smallest promotion type, we can use a combination of <code>promote</code> and <code>typeof</code> function</p><pre><code class="language-julia-repl">julia&gt; xp, yp, zp, wp = promote(x, y, z, w)
(1.0f0, 2.0f0, 1.0f0, 1.0f0)

julia&gt; typeof(xp)
Float32</code></pre><p>or a combination of <code>promote_type</code> and <code>typeof</code> function</p><pre><code class="language-julia-repl">julia&gt; promote_type(typeof(x), typeof(y), typeof(z), typeof(w))
Float32</code></pre></p></details><h2 id="Updating-operators"><a class="docs-heading-anchor" href="#Updating-operators">Updating operators</a><a id="Updating-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-operators" title="Permalink"></a></h2><p>Every binary arithmetic operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a <code>=</code> immediately after the operator. For example, writing <code>x += 3</code> is equivalent to writing <code>x = x + 3</code>:</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3 # x = x + 3
4

julia&gt; x *= 4 # x = x * 4
16

julia&gt; x /= 2 # x = x / 2
8.0

julia&gt; x \= 16 # x = x \ 16 = 16 / x
2.0</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Compute the value of <code>y</code> given by the following expression</p><p class="math-container">\[y = \frac{(x + 4)^{\frac{3}{2}}}{(x + 1)^{p - 1}},\]</p><p>where <code>x = 5</code> and <code>p = 3</code>. Then multiply the result by <code>8</code>, add <code>3</code>, divide by <code>3</code>, and subtract <code>1</code>. What are all the intermediate results and the final result?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we calculate the value of <code>y</code></p><pre><code class="language-julia-repl">julia&gt; x = 5;

julia&gt; p = 3;

julia&gt; y = (x + 4)^(3/2)/(x + 1)^(p - 1)
0.75</code></pre><p>Then we can use the update operators to get all the intermediate results as well as the final result</p><pre><code class="language-julia-repl">julia&gt; y *= 8
6.0

julia&gt; y += 3
9.0

julia&gt; y /= 3
3.0

julia&gt; y -= 1
2.0</code></pre></p></details><h2 id="Numeric-comparison"><a class="docs-heading-anchor" href="#Numeric-comparison">Numeric comparison</a><a id="Numeric-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-comparison" title="Permalink"></a></h2><p>In addition to arithmetic and updating operators, basic comparison operators are also defined in Julie&#39;s standard libraries.</p><table><tr><th style="text-align: left">Operator</th><th style="text-align: left">Name</th></tr><tr><td style="text-align: left"><code>==</code></td><td style="text-align: left">equality</td></tr><tr><td style="text-align: left"><code>!=</code>, <code>≠</code></td><td style="text-align: left">inequality</td></tr><tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">less than</td></tr><tr><td style="text-align: left"><code>&lt;=</code>, <code>≤</code></td><td style="text-align: left">less than or equal to</td></tr><tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">greater than</td></tr><tr><td style="text-align: left"><code>&gt;=</code>, <code>≥</code></td><td style="text-align: left">greater than or equal to</td></tr></table><p>All these operators always return boolean value (<code>true</code> or <code>false</code>) as can be seen in the following example</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 ≥ 1
false</code></pre><p>In most programming languages, comparison operators are strictly binary, i.e. they can be used to compare with only two values at a time. As an example, we can use a comparison of three numbers in Matlab</p><pre><code class="language-matlab">&gt;&gt; 3 &gt; 2 &gt; 1

ans =

  logical

   0</code></pre><p>Even though the condition holds, the result is <code>false</code> (logical <code>0</code>). The correct way to write such a condition in Matlab is as follows</p><pre><code class="language-matlab">&gt;&gt; 3 &gt; 2 &amp; 2 &gt; 1

ans =

  logical

   1</code></pre><p>In Julia (and Python, for example), both ways of writing conditions are correct and lead to the same result</p><pre><code class="language-julia-repl">julia&gt; 3 &gt; 2 &gt; 1
true

julia&gt; 3 &gt; 2 &amp; 2 &gt; 1
true</code></pre><p>In fact, comparison operators can be arbitrarily chained as in the following example</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>It may be quite convenient in numerical code, however, it can also easily decrease code readability. So if you want to use such syntax, always take code readability in your consideration.</p><p>Comparison of special values such as <code>NaN</code> can lead to unexpected behavior</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false</code></pre><p>To avoid unexpected result, Julia provides additional functions to compare numbers for special values</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Tests if</th></tr><tr><td style="text-align: left"><code>isequal(x, y)</code></td><td style="text-align: left"><code>x</code> and <code>y</code> are identical</td></tr><tr><td style="text-align: left"><code>isfinite(x)</code></td><td style="text-align: left"><code>x</code> is a finite number</td></tr><tr><td style="text-align: left"><code>isinf(x)</code></td><td style="text-align: left"><code>x</code> is infinite</td></tr><tr><td style="text-align: left"><code>isnan(x)</code></td><td style="text-align: left"><code>x</code> is not a number</td></tr></table><p>Function <code>isequal</code> considers <code>NaN</code>s equal to each other</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; !isequal(NaN, NaN)
false</code></pre><h2 id="Rounding-functions"><a class="docs-heading-anchor" href="#Rounding-functions">Rounding functions</a><a id="Rounding-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding-functions" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>round(x)</code></td><td style="text-align: left">round <code>x</code> to the nearest integer</td></tr><tr><td style="text-align: left"><code>floor(x)</code></td><td style="text-align: left">round <code>x</code> towards <code>-Inf</code></td></tr><tr><td style="text-align: left"><code>ceil(x)</code></td><td style="text-align: left">round <code>x</code> towards <code>+Inf</code></td></tr><tr><td style="text-align: left"><code>trunc(x)</code></td><td style="text-align: left">round <code>x</code> towards <code>zero</code></td></tr></table><p>All these functions can be used without a specified output type. In such a case, the output will have the same type as the input variable</p><pre><code class="language-julia-repl">julia&gt; x = 3.1415
3.1415

julia&gt; round(x)
3.0

julia&gt; floor(x)
3.0

julia&gt; ceil(x)
4.0</code></pre><p>However, in many cases, it makes sense to convert the rounded value to an integer. To do this, we can simply pass the appropriate integer type as the first argument</p><pre><code class="language-julia-repl">julia&gt; round(Int64, x)
3

julia&gt; floor(Int32, x)
3

julia&gt; ceil(Int16, x)
4</code></pre><p>All rounding functions also support additional keyword arguments:</p><ul><li>If the <code>digits</code> keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base specifide by <code>base</code> keyword argument.</li><li>If the <code>sigdigits</code> keyword argument is provided, it rounds to the specified number of significant digits, in base specifide by <code>base</code> keyword argument.</li></ul><pre><code class="language-julia-repl">julia&gt; round(x; digits = 3)
3.142

julia&gt; round(x; sigdigits = 3)
3.14</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use rounding operators to solve the following tasks</p><ul><li>Round <code>1252.1518</code> to the nearest larger integer and convert the resulting value to <code>Int64</code>.</li><li>Round <code>1252.1518</code> to the nearest smaller integer and convert the resulting value to <code>Int16</code>.</li><li>Round <code>1252.1518</code> to <code>2</code> digits after the decimal point.</li><li>Round <code>1252.1518</code> to <code>3</code> significant digits.</li></ul></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The <code>ceil</code> function rounds numbers to the nearest larger value and since we want the result to be of type <code>Int64</code>, we have to pass this type as a first argument</p><pre><code class="language-julia-repl">julia&gt; x = 1252.1518
1252.1518

julia&gt; ceil(Int64, x)
1253</code></pre><p>Similarly, the floor function rounds numbers to the nearest smaller value</p><pre><code class="language-julia-repl">julia&gt; floor(Int16, x)
1252</code></pre><p>The number of digits after the decimal point can be controlled using <code>digits</code> keyword</p><pre><code class="language-julia-repl">julia&gt; round(x; digits = 2)
1252.15</code></pre><p>and the number of significant digits using <code>sigdigits</code> keyword</p><pre><code class="language-julia-repl">julia&gt; round(x; sigdigits = 3)
1250.0</code></pre></p></details><h2 id="Numerical-Conversions"><a class="docs-heading-anchor" href="#Numerical-Conversions">Numerical Conversions</a><a id="Numerical-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Conversions" title="Permalink"></a></h2><p>As was shown in the previous section, the numerical conversion can be done using rounding functions with a specified type of output variable. However, it only works for converting floating-point numbers to integers. Julia also provides a more general way how to perform the numerical conversion: the notation <code>T(x)</code> or <code>convert(T,x)</code> converts <code>x</code> to a value of type <code>T</code>.</p><ul><li>If <code>T</code> is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</li><li>If <code>T</code> is an integer type, an <code>InexactError</code> is raised if <code>x</code> is not representable by <code>T</code>.</li></ul><pre><code class="language-julia-repl">julia&gt; convert(Float32, 1.234)
1.234f0

julia&gt; Float32(1.234)
1.234f0

julia&gt; convert(Float64, 1)
1.0

julia&gt; Float64(1)
1.0

julia&gt; convert(Int64, 1.234)
ERROR: InexactError: Int64(1.234)

julia&gt; Int64(1.234)
ERROR: InexactError: Int64(1.234)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variables/">« Variables</a><a class="docs-footer-nextpage" href="../arrays/">Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 30 December 2020 14:47">Wednesday 30 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
