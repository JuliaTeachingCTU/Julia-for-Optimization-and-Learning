<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exercises · Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_06/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_06/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox" checked/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../nn/">Neural networks</a></li><li class="is-active"><a class="tocitem" href>Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/sparse/">Linear regression with sparse constraints</a></li><li><a class="tocitem" href="../../lecture_11/monte/">Monte Carlo sampling</a></li><li><a class="tocitem" href="../../lecture_11/glm/">Linear regression revisited</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">9: Neural networks I.</a></li><li class="is-active"><a href>Exercises</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exercises</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_09/exercises.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="l9-exercises"><a class="docs-heading-anchor" href="#l9-exercises">Exercises</a><a id="l9-exercises-1"></a><a class="docs-heading-anchor-permalink" href="#l9-exercises" title="Permalink"></a></h1><div class = "homework-body">
<header class = "homework-header">Homework: Optimal setting</header><p><p>Perform an analysis of hyperparameters of the neural network from this lecture. Examples may include network architecture, learning rate (stepsize), activation functions or normalization.</p><p>Write a short summary (in LaTeX) of your suggestions.</p></p></div><div class = "exercise-body">
<header class = "exercise-header">Exercise 1: Keyword arguments</header><p><p>Keyword arguments (often denoted as <code>kwargs</code> but any name may be used) specify additional arguments which do not need to be used when the function is called. We recall the <code>prepare_data</code> function written earlier.</p><pre><code class="language-julia">function prepare_data(X, y; do_normal=true, do_onehot=true, kwargs...)
    X_train, y_train, X_test, y_test = split(X, y; kwargs...)

    if do_normal
        X_train, X_test = normalize(X_train, X_test; kwargs...)
    end

    classes = unique(y)

    if do_onehot
        y_train = onehot(y_train, classes)
        y_test = onehot(y_test, classes)
    end

    return X_train, y_train, X_test, y_test, classes
end</code></pre><p>All keyword arguments <code>kwargs</code> will be passed to the <code>split</code> and <code>normalize</code> functions. The benefit is that we do not need to specify the keyword arguments for <code>split</code> in <code>prepare_data</code>.</p><p>Recall that <code>split</code> takes <code>ratio_split</code> as an optional argument. Write a one-line function <code>ratio_train</code> which gets the training and testing sets and computes the ratio of samples in the training set. Then call the <code>prepare_data</code> with:</p><ul><li>no normalization and the default split ratio;</li><li>normalization and the split ratio of 50/50;</li></ul></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The <code>ratio_train</code> function reads:</p><pre><code class="language-julia">ratio_train(X_train, X_test) = size(X_train, 2) / (size(X_train,2) + size(X_test,2))</code></pre><p>The first case uses the default ratio; hence we do not pass <code>ratio_split</code>. Since we do not want to use normalization, we need to pass <code>do_normal=false</code>.</p><pre><code class="language-julia">X_train, y_train, X_test, y_test, classes = prepare_data(X&#39;, y; dims=2, do_normal=false)
println(&quot;Ratio train/test = &quot;, ratio_train(X_train, X_test))</code></pre><pre class="documenter-example-output">Ratio train/test = 0.8</pre><p>The second case behaves the other way round. We use the default normalization; thus, we do not need to specify <code>do_normal=true</code> (even though it may be a good idea). We need to pass <code>ratio_train=0.5</code>.</p><pre><code class="language-julia">X_train, y_train, X_test, y_test, classes = prepare_data(X&#39;, y; dims=2, ratio_train=0.5)
println(&quot;Ratio train/test = &quot;, ratio_train(X_train, X_test))</code></pre><pre class="documenter-example-output">Ratio train/test = 0.5</pre></p></details><p>The goal of the following exercise is to show the prediction function graphically. For this reason, we will consider only two features. All the following exercises use the data with the fixed seed for reproducibility.</p><pre><code class="language-julia">Random.seed!(666)
X_train, y_train, X_test, y_test, classes = prepare_data(X[:,3:4]&#39;, y; dims = 2)</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise 2: Showing the contours</header><p><p>Use the same training procedure for 1000 iterations to train the classifier with the new data. Then plot a graph depicting which classes are predicted at subregions of <span>$[-2,2]\times [-2,2]$</span>. Moreover, depict the testing data in this graph.</p><p><strong>Hint</strong>: use the <code>heatmap</code> function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The procedure for training the network is the same as during the lecture.</p><pre><code class="language-julia">m = SimpleNet(size(X_train,1), 5, size(y_train,1))

α = 1e-1
max_iter = 1000
for iter in 1:max_iter
    grad_all = [grad(m, X_train[:,k], y_train[:,k]) for k in 1:size(X_train,2)]
    grad_mean = mean_tuple(grad_all)

    m.W1 .-= α*grad_mean[2]
    m.b1 .-= α*grad_mean[3]
    m.W2 .-= α*grad_mean[4]
    m.b2 .-= α*grad_mean[5]
end</code></pre><p>The prediction function is <code>m([x;y])</code>. Since this creates a one-hot representation, we need to convert it into a one-cold representation. However, it is not possible to use <code>onecold(m([x; y]), classes)</code>, which would result in one of the three string labels. We need to use <code>onecold(m([x; y]), 1:3)</code> to convert it to a real number. Then we call the <code>heatmap</code> function. Since we will later use plotting in a loop, we assign the graph to <code>plt</code>.</p><pre><code class="language-julia">colours = [:blue, :red, :green]

xs = -2:0.01:2
plt = heatmap(xs, xs, (x, y) -&gt; onecold(m([x; y]), 1:3)[1];
    color = colours,
    opacity = 0.2,
    axis = false,
    ticks = false,
    cbar = false,
    legend = :topleft,
)</code></pre><p>To add the predictions of the testing set, we find the indices <code>inds</code> of samples from each class. Then we add them via the <code>scatter!</code> plot. We keep <code>colours</code> from the previous part to have the same colours. Since we plotted in a loop, we need to <code>display</code> the plot.</p><pre><code class="language-julia">for (i, class) in enumerate(classes)
    inds = findall(onecold(y_test, classes) .== class)
    scatter!(plt, X_test[1, inds], X_test[2, inds];
        label = class,
        marker=(8, 0.8, colours[i]),
    )
end
display(plt)</code></pre></p></details><p><img src="../Separation.svg" alt/></p><div class = "exercise-body">
<header class = "exercise-header">Exercise 3: Overfitting</header><p><p>This exercise shows the well-known effect of overfitting. Since the model sees only the training set, it may fit it too perfectly (overfit it) and generalize poorly to the testing set of unseen examples.</p><p>Consider the same data as in the previous exercise but train a network with 25 hidden neurons for 25000 iterations. Plot the loss function values on the training and testing sets. Then plot the same prediction visualization as in the previous exercise for both testing and training sets. Describe what went wrong.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We first specify the loss function.</p><pre><code class="language-julia">loss(X, y; ϵ = 1e-10) = mean(-sum(y .* log.(m(X) .+ ϵ); dims = 1))</code></pre><p>Then we train the network as before. The only change is that we need to save the training and testing objective.</p><pre><code class="language-julia">m = SimpleNet(size(X_train,1), 25, size(y_train,1))

α = 1e-1
max_iter = 25000
L_train = zeros(max_iter)
L_test = zeros(max_iter)
for iter in 1:max_iter
    grad_all = [grad(m, X_train[:,k], y_train[:,k]) for k in 1:size(X_train,2)]
    grad_mean = mean_tuple(grad_all)

    m.W1 .-= α*grad_mean[2]
    m.b1 .-= α*grad_mean[3]
    m.W2 .-= α*grad_mean[4]
    m.b2 .-= α*grad_mean[5]

    L_train[iter] = loss(X_train, y_train)
    L_test[iter] = loss(X_test, y_test)
end</code></pre><p>Then we plot it. We ignore the first nine iterations, where the loss is large there. We see the classical procedure of overfitting. While the loss function on the training set decreases steadily, on the testing set, it decreases first, and after approximately 100 iterations, it starts increasing. This behaviour may be prevented by several techniques, which we discuss in the following lecture.</p><pre><code class="language-julia">plot(L_train[10:end], xlabel=&quot;Iteration&quot;, label=&quot;Training loss&quot;, legend=:topleft)
plot!(L_test[10:end], label=&quot;Testing loss&quot;)</code></pre><p><img src="../Train_test.svg" alt/></p><p>We create the contour plot in the same way as in the previous exercise.</p><pre><code class="language-julia">plt = heatmap(xs, xs, (x, y) -&gt; onecold(m([x; y]), 1:3)[1];
    color = colours,
    opacity = 0.2,
    axis = false,
    ticks = false,
    cbar = false,
    legend = :topleft,
)

for (i, class) in enumerate(classes)
    inds = findall(onecold(y_test, classes) .== class)
    scatter!(plt, X_test[1, inds], X_test[2, inds];
        label = class,
        marker=(8, 0.8, colours[i]),
    )
end
display(plt)</code></pre><p><img src="../Separation2.svg" alt/></p><pre><code class="language-julia">plt = heatmap(xs, xs, (x, y) -&gt; onecold(m([x; y]), 1:3)[1];
    color = colours,
    opacity = 0.2,
    axis = false,
    ticks = false,
    cbar = false,
    legend = :topleft,
)

for (i, class) in enumerate(classes)
    inds = findall(onecold(y_train, classes) .== class)
    scatter!(plt, X_train[1, inds], X_train[2, inds];
        label = class,
        marker=(8, 0.8, colours[i]),
    )
end
display(plt)</code></pre><p><img src="../Separation3.svg" alt/></p><p>The separation on the testing set is quite good, but it could be better for the two bottommost green circles (iris virginica). The model predicted (in the background) the red colour (iris versicolor) there. This is wrong. The reason is clear from the picture depicting the training set. The classifier tried to perfectly fit the boundary between the green and red points, making an outward-pointing tip. This is precisely overfitting and the reason for the misclassification on the testing set.</p></p></details><p><img src="../Separation2.svg" alt/></p><p><img src="../Separation3.svg" alt/></p><div class = "exercise-body">
<header class = "exercise-header">Exercise 4: Generalization</header><p><p>The contour plots from Exercises 2 and 3 are strikingly different, especially in the top-left and bottom-right corners. Why is that?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Since the dataset does not contain any data in the top-left or bottom-right corners, it does not know what to predict. From its perspective, both separations are very good.</p><div class = "info-body">
<header class = "info-header">Generalization</header><p><p>If a classifier does not have any data in some region, it may predict anything there, including predictions with no sense.</p></p></div></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise 5: Universal approximation of neural networks (theory)</header><p><p>Proof the theorem about universal approximation of neural networks.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Since piecewise linear functions are dense in the set of continuous functions, there is a piecewise linear function <span>$h$</span> such that <span>$\|h-g\|_{\infty}\le \varepsilon$</span>. Assume that <span>$h$</span> has kinks at <span>$x_1&lt;\dots&lt;x_n$</span> with function values <span>$h(x_i)=y_i$</span> for <span>$i=1,\dots,n$</span>. Defining</p><p class="math-container">\[d_i = \frac{y_{i+1}-y_i}{x_{i+1}-x_i},\]</p><p>then <span>$h$</span> has the form</p><p class="math-container">\[h(x) = y_i + d_i(x-x_i) \qquad\text{ for }x\in [x_i,x_{i+1}].\]</p><p>It is not difficult to show that</p><p class="math-container">\[h(x) = y_1 + \sum_{i=1}^n(d_i-d_{i-1})\operatorname{max}\{x-x_i,0\},\]</p><p>where we defined <span>$d_0=0$</span>.</p><p>Then <span>$h$</span> can be represented as the following network with two layers:</p><ul><li>Dense layer with <span>$n$</span> hidden neurons and ReLU activation function. Neuron <span>$i$</span> has weight <span>$1$</span> and bias <span>$-x_i$</span>.</li><li>Dense layer with <span>$1$</span> output neurons and identity activation function. Connection <span>$i$</span> has weight <span>$d_i-d_{i-1}$</span> and the joint bias is <span>$y_1$</span>.</li></ul><p>This finishes the proof.</p></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nn/">« Neural networks</a><a class="docs-footer-nextpage" href="../../lecture_10/theory/">Theory of neural networks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 26 May 2021 10:58">Wednesday 26 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
