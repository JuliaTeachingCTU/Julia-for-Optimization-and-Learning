<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conditional evaluation · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../howto/">How to...</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Mathematical operations and Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Conditional evaluation</a><ul class="internal"><li><a class="tocitem" href="#Ternary-operator"><span>Ternary operator</span></a></li><li><a class="tocitem" href="#Short-circuit-evaluation"><span>Short-circuit evaluation</span></a></li></ul></li><li><a class="tocitem" href="../loops/">Loops and iterators</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/basics/">Package management</a></li><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Ordinary differential equations</span></li><li><span class="tocitem">12: Statistics I.</span></li><li><span class="tocitem">13: Statistics II.</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: Control flow</a></li><li class="is-active"><a href>Conditional evaluation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conditional evaluation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_02/conditions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Conditional-evaluation"><a class="docs-heading-anchor" href="#Conditional-evaluation">Conditional evaluation</a><a id="Conditional-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-evaluation" title="Permalink"></a></h1><p>In many cases, we have to decide what to do, based on some conditions. Julia supports the standard <code>if-elseif-else</code> syntax, which allows you to decide which part of the code will be evaluated depending on the value of the logical expression. For example, the following function compares two numerical values</p><pre><code class="language-julia">function compare(x, y)
    if x &lt; y
        println(&quot;x is less than y&quot;)
    elseif x &gt; y
        println(&quot;x is greater than y&quot;)
    else
        println(&quot;x is equal to y&quot;)
    end
    return
end</code></pre><p>If the expression <code>x &lt; y</code> is true, the functions prints <em>&quot;x is less than y&quot;</em>, otherwise, the expression <code>x &gt; y</code> is evaluated, and if it is true, the functions prints <em>&quot;x is greater than y&quot;</em>.  If neither expression is true, the function prints <em>&quot;x is equal to y&quot;</em>.</p><pre><code class="language-julia-repl">julia&gt; compare(1, 2.3)
x is less than y

julia&gt; compare(4.7, 2.3)
x is greater than y

julia&gt; compare(2.3, 2.3)
x is equal to y</code></pre><div class = "info-body">
<header class = "info-header">Function declaration:</header><p><p>So far, we did not mention how to declare our own functions. However, the above example should suffice to show the basic syntax for defining functions. Note, that the <code>return</code> keyword is used to specify what is returned by a function. In this case, the function returns nothing, since we only want to compare numbers. If we want to define a function that returns one or more variables then the following syntax is used</p><pre><code class="language-julia">return x, y, z</code></pre><p>where <code>x</code>, <code>y</code>, <code>z</code> are the variables. See the <a href="../../lecture_03/functions/#Functions">third lecture</a> for more information about functions.</p></p></div><p>The <code>elseif</code> and <code>else</code> keywords are optional and it is possible to use as many <code>elseif</code> blocks as desired.</p><pre><code class="language-julia-repl">julia&gt; x, y = 2, 1;

julia&gt; if x &lt; y
           println(&quot;x is less than y&quot;)
       elseif x &gt; y
           println(&quot;x is greater than y&quot;)
       end
x is greater than y

julia&gt; if x &lt; y
           println(&quot;x is less than y&quot;)
       end</code></pre><p>The condition expressions in the <code>if-elseif-else</code> construct are evaluated until the first one evaluates to <code>true</code>, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</p><p>In contrast to languages like Python or Matlab, the logical expression in the <code>if</code> statement must always return a boolean value, otherwise an error will occur</p><pre><code class="language-julia-repl">julia&gt; if 1
           println(&quot;Hello&quot;)
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><p>The <code>if</code> blocks do not introduce a <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/">local scope</a>, i.e. it is possible to introduce a new variable inside the <code>if</code> block and used this variable outside the block.</p><pre><code class="language-julia-repl">julia&gt; x, y = 2, 1;

julia&gt; if x &lt; y
           z = y
       else
           z = x
       end
2

julia&gt; z
2</code></pre><p>However, whenever you decide to declare a new variable inside the <code>if</code> block, make sure, that the variable will be always declared in all cases.</p><pre><code class="language-julia">function compare(x, y)
    if x &lt; y
        z = y
    elseif x &gt; y
        z = x
    end
    return z
end</code></pre><p>For example, the function defined above will work only for numbers, that are not equal</p><pre><code class="language-julia-repl">julia&gt; compare(1, 2.3)
2.3

julia&gt; compare(4.7, 2.3)
4.7

julia&gt; compare(2.3, 2.3)
ERROR: UndefVarError: z not defined</code></pre><p>Another a little bit unintuitive thing is that <code>if</code> blocks return values. This value is given by the last expression evaluated in the <code>if</code> block. It is possible to assign this value to a variable as follows</p><pre><code class="language-julia">function compare(x, y)
    z = if x &lt; y
        y
    else
        x
    end
    return z
end</code></pre><p>In this case, the <code>z</code> variable is equal to <code>y</code> if <code>x &lt; y</code> is true and to <code>x</code> otherwise</p><pre><code class="language-julia-repl">julia&gt; compare(1, 2.3)
2.3

julia&gt; compare(4.7, 2.3)
4.7

julia&gt; compare(2.3, 2.3)
2.3</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a simple function <code>fact</code> that computes a factorial of the given number. Use the following function declaration</p><pre><code class="language-julia">function fact(n)
    # some code
end</code></pre><p>Make sure that the input argument is a non-negative integer. If the input argument is negative, the function should throw an error.</p><p><strong>Hint:</strong> use recursion, the <code>isinteger</code> function and the <code>error</code> function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We will split the solution into three cases:</p><ol><li>the given number <code>n</code> is smaller tan zero or is not an integer.</li><li>the given integer <code>n</code> is equal to zero, then the function returns <code>1</code>.</li><li>the given integer <code>n</code> is larger than zero, then we use recursion.</li></ol><pre><code class="language-julia">function fact(n)
    if n &lt; 0 | !isinteger(n)
        error(&quot;argument must be non-negative integer&quot;)
    elseif n == 0
        1
    else
        n * fact(n - 1)
    end
end</code></pre><p>Since the <code>if</code> block returns a value from the latest evaluated expression, it is possible to use it after the <code>return</code> keyword to define the output of a function.</p><pre><code class="language-julia-repl">julia&gt; fact(4)
24

julia&gt; fact(0)
1

julia&gt; fact(-5)
ERROR: argument must be non-negative integer

julia&gt; fact(1.4)
ERROR: argument must be non-negative integer</code></pre></p></details><h2 id="Ternary-operator"><a class="docs-heading-anchor" href="#Ternary-operator">Ternary operator</a><a id="Ternary-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Ternary-operator" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a> <code>?</code> is closely related to the <code>if-else</code> statement and can be used instead if we only want to decide between two options based on one condition. The syntax is following</p><pre><code class="language-julia">a ? b : c</code></pre><p>This expression can be read as follows: <em>if <code>a</code> is true, evaluate <code>b</code> otherwise evaluate <code>c</code></em>. Note that white spaces around <code>?</code> and <code>:</code> are mandatory.</p><pre><code class="language-julia-repl">julia&gt; x, y = 2, 1;

julia&gt; println(x &lt; y ? &quot;x is less than y&quot; : &quot;x is greater than or equal to y&quot;)
x is greater than or equal to y</code></pre><p>In this case, if the condition <code>x &lt; y</code> holds, then the string <code>&quot;x is less than y&quot;</code> is returned, and otherwise <code>&quot;x is greater than or equal to y&quot;</code>. Since we wrapped the whole expression into the <code>println</code> function, the returned string from the ternary operator is printed in the REPL.</p><h2 id="Short-circuit-evaluation"><a class="docs-heading-anchor" href="#Short-circuit-evaluation">Short-circuit evaluation</a><a id="Short-circuit-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Short-circuit-evaluation" title="Permalink"></a></h2><p>Julia provides a so-called Short-circuit evaluation that is similar to the conditional evaluation. The behavior is found in most imperative programming languages having the &amp;&amp; and || boolean operators: in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain:</p><ul><li>In the expression <code>a &amp;&amp; b</code>, the subexpression <code>b</code> is only evaluated if <code>a</code> evaluates to true.</li><li>In the expression <code>a || b</code>, the subexpression <code>b</code> is only evaluated if <code>a</code> evaluates to false.</li></ul><p>Both <code>&amp;&amp;</code> and <code>||</code> associate to the right, but <code>&amp;&amp;</code> has higher precedence than <code>||</code> does.</p><p>To investigate this behavior, let&#39;s define the following two functions</p><pre><code class="language-julia">t(x) = (println(x); true)
f(x) = (println(x); false)</code></pre><p>The <code>t</code> function prints <code>x</code> and returns true. Similarly, the <code>f</code> function prints <code>x</code> and returns false. Using these two functions, we can easily find out which expressions are evaluated when using short-circuit evaluation.</p><pre><code class="language-julia-repl">julia&gt; t(1) &amp;&amp; println(2) # both expressions are evaluated
1
2

julia&gt; f(1) &amp;&amp; println(2) # only the first expression is evaluated
1
false

julia&gt; t(1) || println(2) # only the first expression is evaluated
1
true

julia&gt; f(1) || println(2) # both expressions are evaluated
1
2</code></pre><p>In the same way, we can examine the behavior of various combinations of <code>&amp;&amp;</code> and <code>||</code> operators</p><pre><code class="language-julia-repl">julia&gt; t(1) &amp;&amp; t(2) || println(3) # the first two expressions are evaluated
1
2
true

julia&gt; f(1) &amp;&amp; t(2) || println(3) # the first and the last expressions are evaluated
1
3

julia&gt; f(1) &amp;&amp; f(2) || println(3) # the first and the last expressions are evaluated
1
3

julia&gt; t(1) &amp;&amp; f(2) || println(3) # all expressions are evaluated
1
2
3</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Rewrite the factorial function from the exercises from the first section. Use short-circuit evaluation to check if the given number is a non-negative integer and ternary operator for recursion.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Since we want to check if the input number is a non-negative integer, we need to check two conditions. It can be done separately using short-circuit evaluation in the following way</p><pre><code class="language-julia">function fact(n)
    isinteger(n) || error(&quot;argument must be non-negative integer&quot;)
    n &gt;= 0 || error(&quot;argument must be non-negative integer&quot;)
    return n == 0 ? 1 : n * fact(n - 1)
end</code></pre><p>However, it can be even simplified, if we combine <code>&amp;&amp;</code> and <code>||</code> operators as follows</p><pre><code class="language-julia">function fact(n)
    isinteger(n) &amp;&amp; n &gt;= 0 || error(&quot;argument must be non-negative integer&quot;)
    return n == 0 ? 1 : n * fact(n - 1)
end</code></pre><p>Since <code>&amp;&amp;</code> has higher precedence than <code>||</code>, the first expression that is evaluated is <code>isinteger(n) &amp;&amp; n &gt;= 0</code>. The last expression is evaluated only if the first expression is evaluated to  <code>false</code>. We can easily check, that this function works exactly the same as the <code>fact</code> function from the first section</p><pre><code class="language-julia-repl">julia&gt; fact(4)
24

julia&gt; fact(0)
1

julia&gt; fact(-5)
ERROR: argument must be non-negative integer

julia&gt; fact(1.4)
ERROR: argument must be non-negative integer</code></pre></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_01/data_structures/">« Data structures</a><a class="docs-footer-nextpage" href="../loops/">Loops and iterators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 11 January 2021 16:41">Monday 11 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
