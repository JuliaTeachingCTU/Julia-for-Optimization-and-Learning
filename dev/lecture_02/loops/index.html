<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Loops and Iterators · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary Functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data Structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../conditions/">Conditional Evaluation</a></li><li class="is-active"><a class="tocitem" href>Loops and Iterators</a><ul class="internal"><li><a class="tocitem" href="#for-and-while-loop"><span><code>for</code> and <code>while</code> loop</span></a></li><li><a class="tocitem" href="#List-comprehension"><span>List comprehension</span></a></li><li><a class="tocitem" href="#Generator-expressions"><span>Generator expressions</span></a></li><li><a class="tocitem" href="#Iterators"><span>Iterators</span></a></li></ul></li><li><a class="tocitem" href="../scope/">Soft Local Scope</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/basics/">Package Management</a></li><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard Library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other Useful Packages</a></li><li><a class="tocitem" href="../../lecture_04/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Statistics</span></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: Control flow</a></li><li class="is-active"><a href>Loops and Iterators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Loops and Iterators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_02/loops.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="for-and-while-loop"><a class="docs-heading-anchor" href="#for-and-while-loop"><code>for</code> and <code>while</code> loop</a><a id="for-and-while-loop-1"></a><a class="docs-heading-anchor-permalink" href="#for-and-while-loop" title="Permalink"></a></h2><p>As in other languages, Julia supports two basic constructs for repeated evaluation: the <code>while</code> and<code>for</code> loops. Loops are useful when we want to repeat some computation multiple times with different values. A typical example is performing operations on array elements.</p><p>The <code>while</code> loop evaluates the condition expression, and as long it remains <code>true</code>, keeps also evaluating the body of the <code>while</code> loop. If the condition expression is <code>false</code> when the while loop is first reached, the body is never evaluated</p><pre><code class="language-julia-repl">julia&gt; i = 1
1

julia&gt; while i &lt;= 5
           @show i
           i += 1
       end
i = 1
i = 2
i = 3
i = 4
i = 5</code></pre><p>The <code>@show</code> macro used in the example above takes an expression and prints the expression and its result. It can also be used to print multiple variables at once</p><pre><code class="language-julia-repl">julia&gt; a, b, c = 1, &quot;hello&quot;, :world;

julia&gt; @show (a, b, c);
(a, b, c) = (1, &quot;hello&quot;, :world)</code></pre><p>The <code>for</code> loops can be created similarly as in Matlab. In the following example, we iterate over the range of integers from 1 to 10, and in each iteration, we use the <code>@show</code> macro to print the current value of the variable <code>i</code></p><pre><code class="language-julia-repl">julia&gt; for i in 1:5
           @show i
       end
i = 1
i = 2
i = 3
i = 4
i = 5</code></pre><div class = "info-body">
<header class = "info-header">An alternative notation for <code>for</code> loops</header><p><p>There are two alternative notations for the <code>for</code> loop. It is possible to use  the <code>=</code> or <code>∈</code> symbol instead of the <code>in</code> keyword</p><pre><code class="language-julia-repl">julia&gt; for i = 1:5
           @show i
       end
i = 1
i = 2
i = 3
i = 4
i = 5</code></pre><p>However, it is better to use the <code>in</code> keyword to improve the code&#39;s readability or be consistent and use the same keyword in all <code>for</code> loops.</p></p></div><p>In Julia (similarly to Python), it is possible to loop not only over ranges but over any iterable object. For example, it is possible to loop over arrays or tuples. This possibility is advantageous because it allows us to get elements of iterable objects directly without having to use indexes</p><pre><code class="language-julia-repl">julia&gt; persons = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carla&quot;, &quot;Daniel&quot;];

julia&gt; for name in persons
           println(&quot;Hi, my name is $name.&quot;)
       end
Hi, my name is Alice.
Hi, my name is Bob.
Hi, my name is Carla.
Hi, my name is Daniel.</code></pre><p>It is also possible to iterate over other data structures. For example, we can iterate over dictionaries. In such a case, in each iteration, we get a tuple of the key and corresponding value</p><pre><code class="language-julia-repl">julia&gt; persons = Dict(&quot;Alice&quot; =&gt; 10, &quot;Bob&quot; =&gt; 23, &quot;Carla&quot; =&gt; 14, &quot;Daniel&quot; =&gt; 34);

julia&gt; for (name, age) in persons
           println(&quot;Hi, my name is $name and I am $age old.&quot;)
       end
Hi, my name is Carla and I am 14 old.
Hi, my name is Alice and I am 10 old.
Hi, my name is Daniel and I am 34 old.
Hi, my name is Bob and I am 23 old.</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use <code>for</code> or <code>while</code> loop to print integers from <code>1</code> to <code>100</code>.  Use conditions to print only the integers divisible by <code>3</code> and <code>7</code> simultaneously.</p><p><strong>Hint:</strong> use the <code>mod</code> function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The first thing that we have to do is to check if the given integer is divisible by <code>3</code> and <code>7</code> simultaneously. It can be done using the <code>mod</code> function in combination with the <code>if-else</code> statement as follows</p><pre><code class="language-julia-repl">julia&gt; i = 21
21

julia&gt; if mod(i, 3) == 0 &amp;&amp; mod(i, 7) == 0
           println(&quot;$(i) is divisible by 3 and 7&quot;)
       end
21 is divisible by 3 and 7</code></pre><p>or using the short-circuit evaluation</p><pre><code class="language-julia-repl">julia&gt; i = 21
21

julia&gt; mod(i, 3) == mod(i, 7) == 0 &amp;&amp; println(&quot;$(i) is divisible by 3 and 7&quot;)
21 is divisible by 3 and 7</code></pre><p>When we know how to check the given conditions, it is easy to write a <code>for</code> loop to iterate over integers from <code>1</code> to <code>100</code> as follows</p><pre><code class="language-julia-repl">julia&gt; for i in 1:100
           mod(i, 3) == mod(i, 7) == 0 &amp;&amp; @show i
       end
i = 21
i = 42
i = 63
i = 84</code></pre><p>A <code>while</code> loop can be created in a similar way</p><pre><code class="language-julia-repl">julia&gt; i = 0;

julia&gt; while i &lt; 100
           i += 1
           mod(i, 3) == mod(i, 7) == 0 &amp;&amp; @show i
       end
i = 21
i = 42
i = 63
i = 84</code></pre></p></details><h3 id="break-and-continue"><a class="docs-heading-anchor" href="#break-and-continue"><code>break</code> and <code>continue</code></a><a id="break-and-continue-1"></a><a class="docs-heading-anchor-permalink" href="#break-and-continue" title="Permalink"></a></h3><p>It is sometimes useful to stop the <code>for</code> loop based on some condition. It can be done using the <code>break</code> keyword. In the following example, the loop iterates over the range from 1 to 10 and breaks when <code>i == 4</code>, i.e., only the first four numbers are printed</p><pre><code class="language-julia-repl">julia&gt; for i in 1:10
           i == 4 &amp;&amp; break
           @show i
       end
i = 1
i = 2
i = 3</code></pre><p>Another useful feature is to skip some elements. It can be done using the <code>continue</code> keyword. For example, the following code prints all even numbers from 1 to 10</p><pre><code class="language-julia-repl">julia&gt; for i in 1:10
           mod(i, 2) == 0 || continue
           @show i
       end
i = 2
i = 4
i = 6
i = 8
i = 10</code></pre><p>Note that the code after the <code>continue</code> keyword expression is not evaluated.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Rewrite the code from the exercise in the section above. Use the combination of the <code>while</code> loop and keywords <code>continue</code> to print integers from <code>1</code> to <code>100</code> divisible by by <code>3</code> and <code>7</code> simultaneously. In the declaration of the <code>while</code> loop use the <code>true</code> value instead of a condition. Use the <code>break</code> keyword and proper condition to terminate the loop.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>If we use the <code>true</code> value in the declaration of the<code>while</code> loop, we will create an infinite loop, and it is necessary to end it in the loop with the <code>break</code> keyword. Because the variable <code>i</code> represents an integer and we want to iterate over integers from 1 to 100, the correct termination condition is<code>i&gt; 100</code></p><pre><code class="language-julia-repl">julia&gt; i = 0;

julia&gt; while true
           i += 1
           i &gt; 100 &amp;&amp; break
           mod(i, 3) == mod(i, 7) == 0 || continue
           @show i
       end
i = 21
i = 42
i = 63
i = 84</code></pre><p>Note that we use short-circuit evaluation to break the loop. To check the given integer&#39;s divisibility, we use the same condition as in the exercise above. However, we use <code>||</code> instead of <code>&amp;&amp;</code> because we want to use the <code>continue</code> keyword.</p></p></details><h3 id="Nested-loops"><a class="docs-heading-anchor" href="#Nested-loops">Nested loops</a><a id="Nested-loops-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-loops" title="Permalink"></a></h3><p>In Julia, Nested loops can be created in a standard way as in other languages</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3
           for j in i:3
               @show (i, j)
           end
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)
(i, j) = (2, 2)
(i, j) = (2, 3)
(i, j) = (3, 3)</code></pre><p>Note that the inner loop range depends on the variable <code>i</code> from the outer loop. This style of writing nested loops is typical in other languages and is very useful. However, in Julia, it is possible to use an even shorter syntax</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3, j in i:3
           @show (i, j)
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)
(i, j) = (2, 2)
(i, j) = (2, 3)
(i, j) = (3, 3)</code></pre><p>In this case, the output is the same as in the previous example, but this syntax is not equivalent to the previous one. The main difference is when using the <code>break</code> keyword. If we use the first syntax, the <code>break</code> keyword inside an inner loop exits only the inner loop.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3
           for j in i:10
               j &gt; 3 &amp;&amp; break
               @show (i, j)
           end
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)
(i, j) = (2, 2)
(i, j) = (2, 3)
(i, j) = (3, 3)</code></pre><p>However, if we use the shorter syntax, the <code>break</code> keyword inside an inner loop exits the entire nested loops</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3, j in i:10
           j &gt; 3 &amp;&amp; break
           @show (i, j)
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)</code></pre><p>There are other limitations of the shorter syntax. For example, it is not possible to perform any operation outside the inner loop. Nevertheless, it is still a very useful syntax in many cases.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use nested loops to create a matrix with elements given by the following formula</p><p class="math-container">\[A_{i, j} = \frac{1}{2}\exp\left\{\frac{1}{2} (x_{i}^2 - y_{j}^2) \right\} \quad i \in \{1, 2, 3\}, \; j \in  \{1, 2, 3, 4\}\]</p><p>where <span>$x \in \{0.4, 2.3, 4.6\}$</span>, <span>$y \in \{1.4, -3.1, 2.4, 5.2\}$</span>.</p><p><strong>Bonus:</strong> try to create the same matrix in a more effective way.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Firstly, we have to define vectors <code>x</code> and <code>y</code></p><pre><code class="language-julia">x = [0.4, 2.3, 4.6]
y = [1.4, -3.1, 2.4, 5.2]</code></pre><p>If we want to use nested loops, we have to create an empty array of the proper size and element type</p><pre><code class="language-julia">A = zeros(Float64, length(x), length(y))</code></pre><p>In this case, the element type specification can be omitted since the elements will be of type <code>Float64</code>, which is a default type for the <code>zeros</code> function. Now we have to use proper indexes since we want to fill the <code>A</code> array. In this case, we get the indexes <code>1:3</code> for the vector <code>x</code> and <code>1:4</code> for the vector <code>y</code>. Altogether, we get the following nested <code>for</code> loops</p><pre><code class="language-julia-repl">julia&gt; for i in 1:length(x), j in 1:length(y)
           A[i, j] = exp((x[i]^2 - y[j]^2)/2)/2
       end

julia&gt; A
3×4 Array{Float64,2}:
    0.203285    0.00443536     0.030405  7.27867e-7
    2.64284     0.0576626      0.395285  9.46275e-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>However, there are more efficient ways how to create this array in Julia. The one way is to use broadcasting. It can be done as follows</p><pre><code class="language-julia-repl">julia&gt; y_row = y&#39;
1×4 LinearAlgebra.Adjoint{Float64,Array{Float64,1}}:
 1.4  -3.1  2.4  5.2

julia&gt; A = @. exp((x^2 - y_row^2)/2)/2
3×4 Array{Float64,2}:
    0.203285    0.00443536     0.030405  7.27867e-7
    2.64284     0.0576626      0.395285  9.46275e-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>Note that we use <code>y&#39;</code>, which indicates the transposition of the vector <code>y</code>, i.e.,  the resulting array represents a row vector. Also, note that we use the <code>@ .</code> macro to perform all operations elementwise.  The third way to create the same matrix is to use a list comprehension, and we will discuss it in the next section.</p></p></details><h2 id="List-comprehension"><a class="docs-heading-anchor" href="#List-comprehension">List comprehension</a><a id="List-comprehension-1"></a><a class="docs-heading-anchor-permalink" href="#List-comprehension" title="Permalink"></a></h2><p>As we mentioned in the exercise&#39;s solution above, one way to create an array with prescribed elements is to use list comprehension. Comprehensions provide a general and powerful way to construct arrays, and the syntax is similar to set construction notation in mathematics</p><pre><code class="language-julia">A = [f(x, y, ...) for x in X, y in Y, ...]</code></pre><p>The previous example reads: the function <code>f</code> will be evaluated for each combination of elements of iterable objects  <code>X</code>, <code>Y</code>, etc. The result will be an <code>n</code>-dimensional array of size <code>(length(X), length(Y), ...)</code>. Returning to the previous exercise, we can create the required array as follows</p><pre><code class="language-julia-repl">julia&gt; X = [0.4, 2.3, 4.6];

julia&gt; Y = [1.4, -3.1, 2.4, 5.2];

julia&gt; A = [exp((x^2 - y^2)/2)/2 for x in X, y in Y]
3×4 Array{Float64,2}:
    0.203285    0.00443536     0.030405  7.27867e-7
    2.64284     0.0576626      0.395285  9.46275e-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>Note that the resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension</p><pre><code class="language-julia-repl">julia&gt; A = Float32[exp((x^2 - y^2)/2)/2 for x in X, y in Y]
3×4 Array{Float32,2}:
    0.203285    0.00443536     0.030405  7.27867f-7
    2.64284     0.0576626      0.395285  9.46275f-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>A handy feature is that it is possible to filter values when creating list comprehensions using the <code>if</code> keyword. However, in such a case, the result will always be a vector. In the example below, we create a vector of tuples <code>(x, y, x + y)</code>, where <code>x + y &lt; 5</code></p><pre><code class="language-julia-repl">julia&gt; [(x, y, x + y)  for x in 1:10, y in 1:10 if x + y &lt; 5]
6-element Array{Tuple{Int64,Int64,Int64},1}:
 (1, 1, 2)
 (2, 1, 3)
 (3, 1, 4)
 (1, 2, 3)
 (2, 2, 4)
 (1, 3, 4)</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use the list comprehension to create a vector of all integers from <code>1</code> to <code>100</code> divisible by <code>3</code> and <code>7</code> simultaneously. What is the sum of all these integers?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We can use list comprehension with the same condition that we used in the exercise in the first section</p><pre><code class="language-julia-repl">julia&gt; v = [i for i in 1:100 if mod(i, 3) == mod(i, 7) == 0]
4-element Array{Int64,1}:
 21
 42
 63
 84</code></pre><p>Then we can use the <code>sum</code> function to get their sum</p><pre><code class="language-julia-repl">julia&gt; sum(v)
210</code></pre></p></details><h2 id="Generator-expressions"><a class="docs-heading-anchor" href="#Generator-expressions">Generator expressions</a><a id="Generator-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-expressions" title="Permalink"></a></h2><p>List comprehensions can also be written without enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand instead of allocating an array and storing them in advance. For example, the following expression sums a series without allocating memory.</p><pre><code class="language-julia-repl">julia&gt; sum(1/n^2 for n in 1:1000)
1.6439345666815615</code></pre><p>It is possible to write nested list comprehensions and generators. The syntax is similar to writing nested loops</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i in 1:3 for j in 1:2]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (1, 2)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)

julia&gt; gen = ((i,j) for i in 1:3 for j in 1:2);

julia&gt; collect(gen)
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (1, 2)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)</code></pre><p>Iterables may still refer to outer loop variables. However, in such a case, it is necessary to use the <code>for</code> keyword before each iterable statement, and the result will be a vector</p><pre><code class="language-julia-repl">julia&gt; gen = ((i,j) for i in 1:3 for j in 1:i);

julia&gt; collect(gen)
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>Generated values can also be filtered using the <code>if</code> keyword.  Similarly to list comprehensions, the result in such a case will be a vector</p><pre><code class="language-julia-repl">julia&gt; gen = ((i,j) for i in 1:3 for j in 1:i if i+j == 4);

julia&gt; collect(gen)
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use a generator to sum the square of all integers from <code>1</code> to <code>100</code>, which are divisible by <code>3</code> and <code>7</code> simultaneously.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>There are two ways how to solve the exercise. We can create a generator first and then use the <code>sum</code> function to get the result</p><pre><code class="language-julia-repl">julia&gt; gen = (i^2 for i in 1:100 if mod(i, 3) == mod(i, 7) == 0);

julia&gt; sum(gen)
13230</code></pre><p>or we can use the shorter syntax that allows us to write a generator inside the <code>sum</code> function</p><pre><code class="language-julia-repl">julia&gt; sum(i^2 for i in 1:100 if mod(i, 3) == mod(i, 7) == 0)
13230</code></pre></p></details><h2 id="Iterators"><a class="docs-heading-anchor" href="#Iterators">Iterators</a><a id="Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators" title="Permalink"></a></h2><p>Many structures are iterable in Julia. However, in many cases, it is not sufficient to iterate only over elements of a structure. Imagine the situation that we have the following array and we want to iterate over all its elements</p><pre><code class="language-julia-repl">julia&gt; A = [2.3 4.5; 6.7 7.1]
2×2 Array{Float64,2}:
 2.3  4.5
 6.7  7.1</code></pre><p>Additionally, in each iteration, we want to print the index and the corresponding value. It can be done in the following way</p><pre><code class="language-julia-repl">julia&gt; for i in 1:length(A)
           println(&quot;i = $(i) and A[i] = $(A[i])&quot;)
       end
i = 1 and A[i] = 2.3
i = 2 and A[i] = 6.7
i = 3 and A[i] = 4.5
i = 4 and A[i] = 7.1</code></pre><p>However, there is an even simpler way. We can do the same using the <code>enumerate</code> function that returns an iterator (an iterable object that can be iterated in for loops). It will produce couples of the form <code>(i, x[i])</code></p><pre><code class="language-julia-repl">julia&gt; for (i, val) in enumerate(A)
           println(&quot;i = $(i) and A[i] = $(val)&quot;)
       end
i = 1 and A[i] = 2.3
i = 2 and A[i] = 6.7
i = 3 and A[i] = 4.5
i = 4 and A[i] = 7.1</code></pre><p>Other very useful functions return iterators. For example, the <code>eachcol</code> function returns an iterator that will iterate over columns of the given matrix</p><pre><code class="language-julia-repl">julia&gt; for col in eachcol(A)
           println(&quot;col = $(col)&quot;)
       end
col = [2.3, 6.7]
col = [4.5, 7.1]</code></pre><p>Similarly, the <code>eachrow</code> function returns an iterator that will iterate over the given matrix&#39;s rows. A convenient function is the <code>zip</code> function, which can zip together multiple iterable objects and iterate over them simultaneously</p><pre><code class="language-julia-repl">julia&gt; for (i, j, k) in zip([1, 4, 2, 5], 2:12, (:a, :b, :c))
           @show (i, j, k)
       end
(i, j, k) = (1, 2, :a)
(i, j, k) = (4, 3, :b)
(i, j, k) = (2, 4, :c)</code></pre><p>Note that in this case, the iterable objects can be of different lengths. However, the iterator returned by the <code>zip</code> function will have the same length as the shortest of the input iterable objects</p><p>It is also possible to combine these handy functions to get an even more useful iterator.</p><pre><code class="language-julia-repl">julia&gt; for (i, vals) in enumerate(zip([1, 4, 2, 5], 2:12, (:a, :b, :c)))
           @show (i, vals)
       end
(i, vals) = (1, (1, 2, :a))
(i, vals) = (2, (4, 3, :b))
(i, vals) = (3, (2, 4, :c))</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Create a matrix with elements given by the following formula</p><p class="math-container">\[A_{i, j} = \frac{1}{2}\exp\left\{\frac{1}{2} (x_{i}^2 - y_{j}^2) \right\} \quad i \in \{1, 2, 3\}, \; j \in  \{1, 2, 3, 4\}\]</p><p>where <span>$x \in \{0.4, 2.3, 4.6\}$</span>, <span>$y \in \{1.4, -3.1, 2.4, 5.2\}$</span>. Compute the sum of all elements in each row and print the following message:</p><blockquote><p><em>Sum of all elements in a row <code>i</code> is <code>i_sum</code></em>,</p></blockquote><p>where <code>i</code> represents row&#39;s number and <code>i_sum</code> the sum of all elements in this row. Do the same for each column and print the following message:</p><blockquote><p><em>Sum of all elements in a column <code>i</code> is <code>i_sum</code></em>,</p></blockquote><p><strong>Hint:</strong> use iterators <code>eachcol</code> and <code>eachrow</code>.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Firstly we have to generate the matrix <code>A</code>. It can be done using list comprehension as follows</p><pre><code class="language-julia">X = [0.4, 2.3, 4.6]
Y = [1.4, -3.1, 2.4, 5.2]
A = [exp((x^2 - y^2)/2)/2 for x in X, y in Y]</code></pre><p>To compute the sum of each row and print the appropriate message, we can use a combination of the <code>enumerate</code> and <code>eachrow</code> functions</p><pre><code class="language-julia-repl">julia&gt; for (i, row) in enumerate(eachrow(A))
           println(&quot;Sum of all elements in a row $(i) is $(sum(row))&quot;)
       end
Sum of all elements in a row 1 is 0.2381259460051036
Sum of all elements in a row 2 is 3.0957940729669864
Sum of all elements in a row 3 is 8647.66342895583</code></pre><p>Similarly, to compute the sum of each column and print the appropriate message, we can use a combination of the <code>enumerate</code> and <code>eachcol</code> functions</p><pre><code class="language-julia-repl">julia&gt; for (i, row) in enumerate(eachcol(A))
           println(&quot;Sum of all elements in a column $(i) is $(sum(row))&quot;)
       end
Sum of all elements in a column 1 is 7385.236904243371
Sum of all elements in a column 2 is 161.13431527671185
Sum of all elements in a column 3 is 1104.5996863997295
Sum of all elements in a column 4 is 0.026443054989612996</code></pre></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conditions/">« Conditional Evaluation</a><a class="docs-footer-nextpage" href="../scope/">Soft Local Scope »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 26 January 2021 14:16">Tuesday 26 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
