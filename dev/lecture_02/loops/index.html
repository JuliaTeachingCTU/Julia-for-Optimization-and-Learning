<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Loops and iterators Â· Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../conditions/">Conditional evaluations</a></li><li class="is-active"><a class="tocitem" href>Loops and iterators</a><ul class="internal"><li><a class="tocitem" href="#for-and-while-loops"><span><code>for</code> and <code>while</code> loops</span></a></li><li><a class="tocitem" href="#List-comprehension"><span>List comprehension</span></a></li><li><a class="tocitem" href="#Generator-expressions"><span>Generator expressions</span></a></li><li><a class="tocitem" href="#Iterators"><span>Iterators</span></a></li></ul></li><li><a class="tocitem" href="../scope/">Soft local scope</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_06/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_06/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Statistics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: Control flow</a></li><li class="is-active"><a href>Loops and iterators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Loops and iterators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_02/loops.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Loops"><a class="docs-heading-anchor" href="#Loops">Loops</a><a id="Loops-1"></a><a class="docs-heading-anchor-permalink" href="#Loops" title="Permalink"></a></h1><p>While <code>if</code> conditions are evaluated only once, loops are assessed multiple times.</p><h2 id="for-and-while-loops"><a class="docs-heading-anchor" href="#for-and-while-loops"><code>for</code> and <code>while</code> loops</a><a id="for-and-while-loops-1"></a><a class="docs-heading-anchor-permalink" href="#for-and-while-loops" title="Permalink"></a></h2><p>As in other languages, Julia supports two basic constructs for repeated evaluation: <code>while</code> and<code>for</code> loops. Loops are useful to repeat the same computation multiple times with different values. A typical example is performing operations on array elements.</p><p>The <code>while</code> loop evaluates the condition, and as long it remains <code>true</code>, it evaluates the body of the <code>while</code> loop. If the condition is <code>false</code>, the while loop is terminated. If the condition is <code>false</code> before the first iteration, the whole <code>while</code> loop is skipped.</p><pre><code class="language-julia-repl">julia&gt; i = 1
1

julia&gt; while i &lt;= 5
           @show i
           i += 1
       end
i = 1
i = 2
i = 3
i = 4
i = 5</code></pre><p>The <code>@show</code> macro in this example prints the results of an expression. It can also be used to print multiple variables at once.</p><pre><code class="language-julia-repl">julia&gt; a, b, c = 1, &quot;hello&quot;, :world;

julia&gt; @show (a, b, c);
(a, b, c) = (1, &quot;hello&quot;, :world)</code></pre><p>The <code>for</code> loops are created similarly to Matlab. The following example iterates over all integers from 1 to 5, and in each iteration, we use the <code>@show</code> macro to print the current value of the variable <code>i</code>.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:5
           @show i
       end
i = 1
i = 2
i = 3
i = 4
i = 5</code></pre><div class = "info-body">
<header class = "info-header">An alternative notation for <code>for</code> loops</header><p><p>There are two alternative notations for the <code>for</code> loop. It is possible to use the <code>=</code> or <code>â</code> symbol instead of the <code>in</code> keyword.</p><pre><code class="language-julia-repl">julia&gt; for i = 1:5
           @show i
       end
i = 1
i = 2
i = 3
i = 4
i = 5</code></pre><p>However, it is better to use the <code>in</code> keyword to improve code readability. Regardless of which notation is used, it is essential to be consistent and use the same notation in all <code>for</code> loops.</p></p></div><p>In Julia (similarly to Python), it is possible to loop not only over ranges but over any iterable object such as arrays or tuples. This is advantageous because it allows getting elements of iterable objects directly without using indices.</p><pre><code class="language-julia-repl">julia&gt; persons = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carla&quot;, &quot;Daniel&quot;];

julia&gt; for name in persons
           println(&quot;Hi, my name is $name.&quot;)
       end
Hi, my name is Alice.
Hi, my name is Bob.
Hi, my name is Carla.
Hi, my name is Daniel.</code></pre><p>It is also possible to iterate over other data structures such as dictionaries. In such a case, we get a tuple of the key and the corresponding value in each iteration.</p><pre><code class="language-julia-repl">julia&gt; persons = Dict(&quot;Alice&quot; =&gt; 10, &quot;Bob&quot; =&gt; 23, &quot;Carla&quot; =&gt; 14, &quot;Daniel&quot; =&gt; 34);

julia&gt; for (name, age) in persons
           println(&quot;Hi, my name is $name and I am $age old.&quot;)
       end
Hi, my name is Carla and I am 14 old.
Hi, my name is Alice and I am 10 old.
Hi, my name is Daniel and I am 34 old.
Hi, my name is Bob and I am 23 old.</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use <code>for</code> or <code>while</code> loop to print all integers between <code>1</code> and <code>100</code> which can be divided by both <code>3</code> and <code>7</code>.</p><p><strong>Hint:</strong> use the <code>mod</code> function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we need to check if a given integer is divisible by both <code>3</code> and <code>7</code>. This can be performed using the <code>mod</code> function in combination with the <code>if-else</code> statement as follows:</p><pre><code class="language-julia-repl">julia&gt; i = 21
21

julia&gt; if mod(i, 3) == 0 &amp;&amp; mod(i, 7) == 0
           println(&quot;$(i) is divisible by 3 and 7&quot;)
       end
21 is divisible by 3 and 7</code></pre><p>or using the short-circuit evaluation</p><pre><code class="language-julia-repl">julia&gt; i = 21
21

julia&gt; mod(i, 3) == mod(i, 7) == 0 &amp;&amp; println(&quot;$(i) is divisible by 3 and 7&quot;)
21 is divisible by 3 and 7</code></pre><p>When we know how to check the conditions, it is easy to write a <code>for</code> loop to iterate over integers from <code>1</code> to <code>100</code>.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:100
           mod(i, 3) == mod(i, 7) == 0 &amp;&amp; @show i
       end
i = 21
i = 42
i = 63
i = 84</code></pre><p>A <code>while</code> loop can be created in a similar way</p><pre><code class="language-julia-repl">julia&gt; i = 0;

julia&gt; while i &lt;= 100
           i += 1
           mod(i, 3) == mod(i, 7) == 0 &amp;&amp; @show i
       end
i = 21
i = 42
i = 63
i = 84</code></pre><p>The <code>for</code> loop should be used here because the range is known before-hand and unlike the <code>while</code> loop, it does not require to initialize <code>i</code>.</p></p></details><h3 id="break-and-continue"><a class="docs-heading-anchor" href="#break-and-continue"><code>break</code> and <code>continue</code></a><a id="break-and-continue-1"></a><a class="docs-heading-anchor-permalink" href="#break-and-continue" title="Permalink"></a></h3><p>Sometimes it is useful to stop the loop when some condition is satisfied. This is done by the <code>break</code> keyword. In the following example, the loop iterates over the range from 1 to 10 and breaks when <code>i == 4</code>, i.e., only the first three numbers are printed.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:10
           i == 4 &amp;&amp; break
           @show i
       end
i = 1
i = 2
i = 3</code></pre><p>Another useful feature is to skip elements using the <code>continue</code> keyword. The following code prints all even numbers from 1 to 10.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:10
           mod(i, 2) == 0 || continue
           @show i
       end
i = 2
i = 4
i = 6
i = 8
i = 10</code></pre><p>The code after the <code>continue</code> keyword is not evaluated.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Rewrite the code from the exercise above. Use a combination of the <code>while</code> loop and the keyword <code>continue</code> to print all integers between <code>1</code> and <code>100</code> divisible by both <code>3</code> and <code>7</code>. In the declaration of the <code>while</code> loop use the <code>true</code> value instead of a condition. Use the <code>break</code> keyword and a proper condition to terminate the loop.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The <code>true</code> value creates an infinite loop, i.e., it is necessary to end the loop with the <code>break</code> keyword. Because the variable <code>i</code> represents an integer and we want to iterate over integers between 1 and 100, the correct termination condition is <code>i &gt; 100</code>.</p><pre><code class="language-julia-repl">julia&gt; i = 0;

julia&gt; while true
           i += 1
           i &gt; 100 &amp;&amp; break
           mod(i, 3) == mod(i, 7) == 0 || continue
           @show i
       end
i = 21
i = 42
i = 63
i = 84</code></pre><p>We used the short-circuit evaluation to break the loop. To check that the integer is divisible, we use the same condition as before. However, we must use <code>||</code> instead of <code>&amp;&amp;</code> because we want to use the <code>continue</code> keyword.</p></p></details><h3 id="Nested-loops"><a class="docs-heading-anchor" href="#Nested-loops">Nested loops</a><a id="Nested-loops-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-loops" title="Permalink"></a></h3><p>In Julia, nested loops can be created in a similar way as in other languages.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3
           for j in i:3
               @show (i, j)
           end
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)
(i, j) = (2, 2)
(i, j) = (2, 3)
(i, j) = (3, 3)</code></pre><p>The range of the inner loop depends on the variable <code>i</code> from the outer loop. This style of writing nested loops is typical in other languages. Julia allows for an additional shorter syntax:</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3, j in i:3
           @show (i, j)
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)
(i, j) = (2, 2)
(i, j) = (2, 3)
(i, j) = (3, 3)</code></pre><p>Even though the output is the same, this syntax is not equivalent to the previous one. The main difference is when using the <code>break</code> keyword. If we use the traditional syntax and the <code>break</code> keyword inside the inner loop, it breaks only the inner loop. On the other hand, if we use the shorter syntax, the <code>break</code> keyword breaks both loops.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:3
           for j in i:10
               j &gt; 3 &amp;&amp; break
               @show (i, j)
           end
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)
(i, j) = (2, 2)
(i, j) = (2, 3)
(i, j) = (3, 3)

julia&gt; for i in 1:3, j in i:10
           j &gt; 3 &amp;&amp; break
           @show (i, j)
       end
(i, j) = (1, 1)
(i, j) = (1, 2)
(i, j) = (1, 3)</code></pre><p>There are other limitations of the shorter syntax, such as the impossibility to perform any operation outside the inner loop. Nevertheless, it is a useful syntax in many cases.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use nested loops to create a matrix with elements given by the formula</p><p class="math-container">\[A_{i, j} = \frac{1}{2}\exp\left\{\frac{1}{2} (x_{i}^2 - y_{j}^2) \right\} \quad i \in \{1, 2, 3\}, \quad j \in  \{1, 2, 3, 4\},\]</p><p>where <span>$x \in \{0.4, 2.3, 4.6\}$</span> and <span>$y \in \{1.4, -3.1, 2.4, 5.2\}$</span>.</p><p><strong>Bonus:</strong> try to create the same matrix in a more effective way.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we have to define vectors <code>x</code> and <code>y</code>, and an empty array of the proper size and element type to use in nested loops.</p><pre><code class="language-julia">x = [0.4, 2.3, 4.6]
y = [1.4, -3.1, 2.4, 5.2]
A = zeros(Float64, length(x), length(y))</code></pre><p>The element type specification can be omitted since the default value type is <code>Float64</code>. Now we have to use proper indices to fill <code>A</code>. In this case, we use the indices <code>1:length(x)</code> for <code>x</code> and <code>1:length(y)</code> for <code>y</code>.</p><pre><code class="language-julia-repl">julia&gt; for i in 1:length(x), j in 1:length(y)
           A[i, j] = exp((x[i]^2 - y[j]^2)/2)/2
       end

julia&gt; A
3Ã4 Array{Float64,2}:
    0.203285    0.00443536     0.030405  7.27867e-7
    2.64284     0.0576626      0.395285  9.46275e-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>There are more efficient ways to create this array. The one way is to use broadcasting.</p><pre><code class="language-julia-repl">julia&gt; y_row = y&#39;
1Ã4 LinearAlgebra.Adjoint{Float64,Array{Float64,1}}:
 1.4  -3.1  2.4  5.2

julia&gt; A = @. exp((x^2 - y_row^2)/2)/2
3Ã4 Array{Float64,2}:
    0.203285    0.00443536     0.030405  7.27867e-7
    2.64284     0.0576626      0.395285  9.46275e-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>We use the <code>@ .</code> macro to perform all operations elementwise. Since <code>x</code> is a column vector and <code>y_row</code> is a row vector, <code>x - y_row</code> uses broadcasting to create a matrix.</p><p>The third way to create this matrix is to use list comprehension. Due to its importance, we dedicate a whole section to it.</p></p></details><h2 id="List-comprehension"><a class="docs-heading-anchor" href="#List-comprehension">List comprehension</a><a id="List-comprehension-1"></a><a class="docs-heading-anchor-permalink" href="#List-comprehension" title="Permalink"></a></h2><p>As we mentioned in the last exercise, one way to create an array with prescribed elements is to use list comprehension. Comprehensions provide a general and powerful way to construct arrays, and the syntax is similar to the set construction notation from mathematics.</p><pre><code class="language-julia">A = [f(x, y, ...) for x in X, y in Y, ...]</code></pre><p>The previous example reads: The function <code>f</code> will be evaluated for each combination of elements of iterable objects  <code>X</code>, <code>Y</code>, etc. The result will be an <code>n</code>-dimensional array of size <code>(length(X), length(Y), ...)</code>. Returning to the previous exercise, we can create the required array as follows:</p><pre><code class="language-julia-repl">julia&gt; X = [0.4, 2.3, 4.6];

julia&gt; Y = [1.4, -3.1, 2.4, 5.2];

julia&gt; A = [exp((x^2 - y^2)/2)/2 for x in X, y in Y]
3Ã4 Array{Float64,2}:
    0.203285    0.00443536     0.030405  7.27867e-7
    2.64284     0.0576626      0.395285  9.46275e-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>The resulting array type depends on the types of the computed elements. A type can be prepended to the comprehension to control the type explicitly.</p><pre><code class="language-julia-repl">julia&gt; A = Float32[exp((x^2 - y^2)/2)/2 for x in X, y in Y]
3Ã4 Array{Float32,2}:
    0.203285    0.00443536     0.030405  7.27867f-7
    2.64284     0.0576626      0.395285  9.46275f-6
 7382.39      161.072       1104.17      0.0264329</code></pre><p>A handy feature is the possibility to filter values when creating list comprehensions by the <code>if</code> keyword. In such a case, the result will always be a vector. In the next example, we create a vector of tuples <code>(x, y, x + y)</code>, where <code>x + y &lt; 5</code>.</p><pre><code class="language-julia-repl">julia&gt; [(x, y, x + y)  for x in 1:10, y in 1:10 if x + y &lt; 5]
6-element Array{Tuple{Int64,Int64,Int64},1}:
 (1, 1, 2)
 (2, 1, 3)
 (3, 1, 4)
 (1, 2, 3)
 (2, 2, 4)
 (1, 3, 4)</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use the list comprehension to create a vector of all integers from <code>1</code> to <code>100</code> divisible by <code>3</code> and <code>7</code> simultaneously. What is the sum of all these integers?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We can use list comprehension with the same condition that we used in the exercise in the first section.</p><pre><code class="language-julia-repl">julia&gt; v = [i for i in 1:100 if mod(i, 3) == mod(i, 7) == 0]
4-element Array{Int64,1}:
 21
 42
 63
 84</code></pre><p>Then we can use the <code>sum</code> function to get their sum.</p><pre><code class="language-julia-repl">julia&gt; sum(v)
210</code></pre></p></details><h2 id="Generator-expressions"><a class="docs-heading-anchor" href="#Generator-expressions">Generator expressions</a><a id="Generator-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-expressions" title="Permalink"></a></h2><p>List comprehensions can also be written without the enclosing square brackets. This produces an object known as a generator. When iterating over a generator, the values are generated on demand instead of pre-allocating an array. For example, the following expression sums a series without allocating the full array in memory.</p><pre><code class="language-julia-repl">julia&gt; gen = (1/n^2 for n in 1:1000);

julia&gt; sum(gen)
1.6439345666815615

julia&gt; sum(1/n^2 for n in 1:1000)
1.6439345666815615</code></pre><p>It is possible to write nested list comprehensions and generators. The syntax is similar to writing nested loops.</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i in 1:3, j in 1:2]
3Ã2 Array{Tuple{Int64,Int64},2}:
 (1, 1)  (1, 2)
 (2, 1)  (2, 2)
 (3, 1)  (3, 2)

julia&gt; gen = ((i,j) for i in 1:3, j in 1:2);

julia&gt; collect(gen)
3Ã2 Array{Tuple{Int64,Int64},2}:
 (1, 1)  (1, 2)
 (2, 1)  (2, 2)
 (3, 1)  (3, 2)</code></pre><p>Iterables may refer to outer loop variables. However, in such a case, it is necessary to use the <code>for</code> keyword before each iterable statement, and the result will be a vector.</p><pre><code class="language-julia-repl">julia&gt; gen = ((i,j) for i in 1:3 for j in 1:i);

julia&gt; collect(gen)
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>Generated values can also be filtered using the <code>if</code> keyword.  Similarly to list comprehensions, the result in such a case is a vector.</p><pre><code class="language-julia-repl">julia&gt; gen = ((i,j) for i in 1:3 for j in 1:i if i+j == 4);

julia&gt; collect(gen)
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use a generator to sum the square of all integers from <code>1</code> to <code>100</code>, which are divisible by <code>3</code> and <code>7</code> simultaneously.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>There are two ways how to solve this exercise. The first one creates a generator and then uses the <code>sum</code> function.</p><pre><code class="language-julia">julia&gt; gen = (i^2 for i in 1:100 if mod(i, 3) == mod(i, 7) == 0);

julia&gt; typeof(gen)
Base.Generator{Base.Iterators.Filter{var&quot;#2#4&quot;,UnitRange{Int64}},var&quot;#1#3&quot;}

julia&gt; sum(gen)
13230</code></pre><p>It is worth noting that <code>gen</code> is a <code>Generator</code> object and not an array. The second way uses the shorter syntax that allows us to write a generator inside the <code>sum</code> function.</p><pre><code class="language-julia-repl">julia&gt; sum(i^2 for i in 1:100 if mod(i, 3) == mod(i, 7) == 0)
13230</code></pre></p></details><h2 id="Iterators"><a class="docs-heading-anchor" href="#Iterators">Iterators</a><a id="Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators" title="Permalink"></a></h2><p>Many structures are iterable in Julia. However, it is not sufficient to iterate only over elements of a structure in many cases. Consider the situation when we have the following array, and we want to iterate over all its elements and print all indices and the corresponding values.</p><pre><code class="language-julia-repl">julia&gt; A = [2.3 4.5; 6.7 7.1]
2Ã2 Array{Float64,2}:
 2.3  4.5
 6.7  7.1

julia&gt; for i in 1:length(A)
           println(&quot;i = $(i) and A[i] = $(A[i])&quot;)
       end
i = 1 and A[i] = 2.3
i = 2 and A[i] = 6.7
i = 3 and A[i] = 4.5
i = 4 and A[i] = 7.1</code></pre><p>There is an even more straightforward way. We can do the same using the <code>enumerate</code> function that returns an iterator (an iterable object that can be iterated in <code>for</code> loops). It produces couples of the form <code>(i, x[i])</code>.</p><pre><code class="language-julia-repl">julia&gt; for (i, val) in enumerate(A)
           println(&quot;i = $(i) and A[i] = $(val)&quot;)
       end
i = 1 and A[i] = 2.3
i = 2 and A[i] = 6.7
i = 3 and A[i] = 4.5
i = 4 and A[i] = 7.1</code></pre><p>Other beneficial functions return iterators. For example, the <code>eachcol</code> function returns an iterator that iterates over matrix columns.</p><pre><code class="language-julia-repl">julia&gt; for col in eachcol(A)
           println(&quot;col = $(col)&quot;)
       end
col = [2.3, 6.7]
col = [4.5, 7.1]</code></pre><p>Similarly, <code>eachrow</code> returns an iterator that iterates over matrix rows. Another convenient function is the <code>zip</code> function, which zips together multiple iterable objects and iterates over them simultaneously.</p><pre><code class="language-julia-repl">julia&gt; for (i, j, k) in zip([1, 4, 2, 5], 2:12, (:a, :b, :c))
           @show (i, j, k)
       end
(i, j, k) = (1, 2, :a)
(i, j, k) = (4, 3, :b)
(i, j, k) = (2, 4, :c)</code></pre><p>In this case, the iterable objects were of different lengths. The iterator returned by the <code>zip</code> function will have the same length as the shortest of its inputs. It is also possible to combine these handy functions.</p><pre><code class="language-julia-repl">julia&gt; for (i, vals) in enumerate(zip([1, 4, 2, 5], 2:12, (:a, :b, :c)))
           @show (i, vals)
       end
(i, vals) = (1, (1, 2, :a))
(i, vals) = (2, (4, 3, :b))
(i, vals) = (3, (2, 4, :c))</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Create a matrix with elements given by the following formula</p><p class="math-container">\[A_{i, j} = \frac{1}{2}\exp\left\{\frac{1}{2} (x_{i}^2 - y_{j}^2) \right\} \quad i \in \{1, 2, 3\}, \; j \in  \{1, 2, 3, 4\}\]</p><p>where <span>$x \in \{0.4, 2.3, 4.6\}$</span>, <span>$y \in \{1.4, -3.1, 2.4, 5.2\}$</span>. Compute the sum of all elements in each row and print the following message:</p><blockquote><p><em>Sum of all elements in a row <code>i</code> is <code>i_sum</code></em></p></blockquote><p>where <code>i</code> represents row&#39;s number and <code>i_sum</code> the sum of all elements in this row. Do the same for each column and print the following message:</p><blockquote><p><em>Sum of all elements in a column <code>i</code> is <code>i_sum</code></em></p></blockquote><p><strong>Hint:</strong> use iterators <code>eachcol</code> and <code>eachrow</code>.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we have to generate the matrix <code>A</code>. It can be done using list comprehension as follows:</p><pre><code class="language-julia">X = [0.4, 2.3, 4.6]
Y = [1.4, -3.1, 2.4, 5.2]
A = [exp((x^2 - y^2)/2)/2 for x in X, y in Y]</code></pre><p>To compute the sum of each row and print the appropriate message, we use the combination of <code>enumerate</code> and <code>eachrow</code> functions.</p><pre><code class="language-julia-repl">julia&gt; for (i, row) in enumerate(eachrow(A))
           println(&quot;Sum of all elements in a row $(i) is $(sum(row))&quot;)
       end
Sum of all elements in a row 1 is 0.2381259460051036
Sum of all elements in a row 2 is 3.0957940729669864
Sum of all elements in a row 3 is 8647.66342895583</code></pre><p>Similarly, to compute the sum of each column and print the appropriate message, we use the combination of <code>enumerate</code> and <code>eachcol</code> functions.</p><pre><code class="language-julia-repl">julia&gt; for (i, row) in enumerate(eachcol(A))
           println(&quot;Sum of all elements in a column $(i) is $(sum(row))&quot;)
       end
Sum of all elements in a column 1 is 7385.236904243371
Sum of all elements in a column 2 is 161.13431527671185
Sum of all elements in a column 3 is 1104.5996863997295
Sum of all elements in a column 4 is 0.026443054989612996</code></pre></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conditions/">Â« Conditional evaluations</a><a class="docs-footer-nextpage" href="../scope/">Soft local scope Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 March 2021 10:24">Tuesday 23 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
