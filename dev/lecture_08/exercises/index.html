<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exercises · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why_julia/">Why Julia?</a></li><li><a class="tocitem" href="../../howto/">How to...</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Mathematical operations and Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluation</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/basics/">Package management</a></li><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Theory of optimization</a></li><li><a class="tocitem" href="../../lecture_07/gradients/">Visualization of gradients</a></li><li><a class="tocitem" href="../../lecture_07/numerical_methods/">Numerical methods</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox" checked/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../linear/">Linear regression</a></li><li><a class="tocitem" href="../logistic/">Logistic regression</a></li><li class="is-active"><a class="tocitem" href>Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Ordinary differential equations</span></li><li><span class="tocitem">12: Statistics I.</span></li><li><span class="tocitem">13: Statistics II.</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">8: Regression and classification</a></li><li class="is-active"><a href>Exercises</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exercises</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_08/exercises.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h1><div class = "homework-body">
<header class = "homework-header">Homework: Data normalization</header><p><p>Data are often normalized. Each feature subtracts its mean and then divides the result by its standard deviation. The normalized features have zero mean and unit standard deviation. This may help in several cases:</p><ul><li>It may help when each feature has different order of dimension (such as milimeters and kilometers). Then the gradient would ignore the feature with the smaller values.</li><li>It may help with problems described in Exercise 4.</li></ul><p>Write a function <code>normalize</code> which takes as an input a dataset and normalizes it. Do you see any differences with the input is the original and normalized dataset when</p><ul><li>the linear regression is optimized via the gradient descent?</li><li>the logistic regression is optimized via the Newton&#39;s method?</li></ul><p>Do you have any intuition as to why?</p></p></div><div class = "exercise-body">
<header class = "exercise-header">Exercise 1</header><p><p>Show the details for the derivation of the logistic regression.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Since <span>$\hat y$</span> equals the probability of predicting <span>$1$</span>, we have</p><p class="math-container">\[\hat y = \frac{1}{1+e^{-w^\top x}}\]</p><p>Then the cross-entropy loss reduces to</p><p class="math-container">\[\begin{aligned}
\operatorname{loss}(y,\hat y) &amp;= - y\log \hat y - (1-y)\log(1-\hat y) \\
&amp;= y\log(1+e^{-w^\top x}) - (1-y)\log(e^{-w^\top x}) + (1-y)\log(1+e^{-w^\top x}) \\
&amp;= \log(1+e^{-w^\top x}) + (1-y)w^\top x.
\end{aligned}\]</p><p>Then it remains to sum this term over all samples.</p></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise 2</header><p><p>Show that if the Newton&#39;s method converge for the logistic regression, then it found a point globally minimizing the logistic loss. </p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We derived that the Hessian of the objective function for logistic regression is</p><p class="math-container">\[\nabla^2 L(w) = \frac 1n \sum_{i=1}^n\hat y_i(1-\hat y_i)x_i x_i^\top.\]</p><p>For any vector <span>$a$</span>, we have</p><p class="math-container">\[a^\top x_i x_i^\top a = (x_i^\top a)^\top (x_i^\top a) = \|x_i^\top a\|^2 \ge 0,\]</p><p>which implies that <span>$x_i x_i^\top$</span> is a positive semidefinite matrix (it is known as rank-1 matrix as its rank is always 1 if <span>$x_i$</span> is a non-zero vector). Since <span>$y_i(1-\hat y_i)\ge 0$</span>, it follows that <span>$\nabla^2 L(w)$</span> is a positive semidefinite matrix. If a Hessian of a function is positive semidefinite everywhere, the function is immediately convex.</p></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise 3</header><p><p>The logistic regression on the iris dataset failed in 6 out of 100 samples. But the visualization shows the failure only in 5 cases. How is it possible?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We use the same code as before and find indices of the miclassified samples</p><pre><code class="language-julia">y_hat = 1 ./(1 .+exp.(-X_ext*w))
pred = y_hat .&gt;= 0.5
ii = findall(pred .!= y)</code></pre><p>Then we show the values of the data and labels at these indices. We sort the rows by <code>sortslices</code>. You cannot use <code>sort</code> as it would not sort rows but it would perform the sorting operator on every column independently.</p><pre><code class="language-julia">aux = hcat(X[ii,:], y[ii])
sortslices(aux, dims=1)</code></pre><pre class="documenter-example-output">6×3 Array{Float64,2}:
 4.5  1.7  1.0
 4.8  1.8  0.0
 5.0  1.5  1.0
 5.0  1.7  0.0
 5.1  1.5  1.0
 5.1  1.6  0.0</pre><p>A short look at the image shows that the point <span>$(4.8, 1.8)$</span> is misclassified but the image shows it correctly. Let us show all such points</p><pre><code class="language-julia">ii = findall((X[:,1].==4.8) .&amp; (X[:,2].==1.8))
aux = hcat(X[ii,:], y[ii])</code></pre><pre class="documenter-example-output">3×3 Array{Float64,2}:
 4.8  1.8  0.0
 4.8  1.8  1.0
 4.8  1.8  1.0</pre><p>As we can see, there are three samples with the same data. Two of them have label 1 and one label 0. Since the incorrectly classified sample wa redrawn, it was not possible to see it.</p></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise 4: Why not use sigmoid</header><p><p>Show that the Newton&#39;s method fail when started from the vector <span>$(1,2,3)$</span>. Can you guess why it happened? What are the consequences for optimization? Is gradient descent going to suffer from the same problems?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we run the logistic regression as before, only with a different starting point</p><pre><code class="language-julia">log_reg(X_ext, [1;2;3])</code></pre><pre class="documenter-example-output">3-element Array{Float64,1}:
 NaN
 NaN
 NaN</pre><p>This resulted in NaNs.</p><p>When something fail, it may be a good idea to run a step-by-step analysis. In this case, we will make one iteration of the Newton&#39;s method</p><pre><code class="language-julia-repl">julia&gt; w = [1;2;3];

julia&gt; X = X_ext;

julia&gt; X_mult = [row*row&#39; for row in eachrow(X)];

julia&gt; y_hat = 1 ./(1 .+exp.(-X*w))
100-element Array{Float64,1}:
 0.9999724643088853
 0.9999724643088853
 0.9999815421067044
 0.9999322758503804
 0.9999750846110607
 0.9999589221322353
 0.9999815421067044
 0.9997515449181605
 0.9999628310628971
 0.9999387202603833
 ⋮
 0.9999969488837513
 0.999993209641302
 0.999998629042793
 0.9999988775548947
 0.9999972392350497
 0.9999924954984029
 0.9999949695696981
 0.999997739675702
 0.9999917062496261

julia&gt; grad = X&#39;*(y_hat.-y) / size(X,1)
3-element Array{Float64,1}:
 2.129852089784904
 0.66295432173409
 0.49996260866776915

julia&gt; hess = y_hat.*(1 .-y_hat).*X_mult |&gt; mean
3×3 Array{Float64,2}:
 0.000598417  0.00018514  0.000147894
 0.00018514   5.80682e-5  4.56733e-5
 0.000147894  4.56733e-5  3.73868e-5

julia&gt; w -= hess \ grad
3-element Array{Float64,1}:
 -10764.590886852531
  -1801.6675865928162
  31420.070268736363</code></pre><p>Starting from bottom, we can see that even though we started with relatively small <span>$w$</span>, the next iteration is four degrees of magnitude larger. This happened because the Hessian <code>hess</code> is much smaller than the gradient <code>grad</code>. This indicated that there is some kind of numerical instability. The prediction <code>y_hat</code> should be distribution in the interval <span>$[0,1]$</span> but it seems that it is almost always close to 1. Let us verify this my showing the extrema of <code>y_hat</code></p><pre><code class="language-julia">extrema(y_hat)</code></pre><pre class="documenter-example-output">(0.9997254218438986, 0.9999994956525918)</pre><p>They are indeed too large.</p><p>Now we explain the reaosn. We know that the prediction equals to</p><p class="math-container">\[\hat y_i = \sigma(w^\top x_i),\]</p><p>where <span>$\sigma$</span> is the sigmoid function. Since the mimimum from <span>$w^\top x_i$</span></p><pre><code class="language-julia">minimum(X*[1;2;3])</code></pre><pre class="documenter-example-output">8.2</pre><p>is large, all <span>$w^\top x_i$</span> are large. But plotting the sigmoid funtion</p><pre><code class="language-julia">σ(z) = 1/(1+exp(-z))
xs = -10:0.01:10
plot(xs, σ.(xs), label=&quot;&quot;, ylabel=&quot;Sigmoid function&quot;)</code></pre><p><img src="../sigmoid.svg" alt/></p><p>it is clear that all <span>$w^\top x_i$</span> hit the part of the sigmoid which is flat. This means that derivative is zero and the Hessian is even smaller zero. Then the ratio of the gradient and Hessian is huge as we observed above.</p><p>The gradient descent will probably run into the same difficulty. Since the gradient will be too small, it will take a very large number of iteration for sigmoid to escape the flat region.</p><p>This is a known problem of the sigmoid function. It is also the reason why it was replaced in neural networks by other functions.</p></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../logistic/">« Logistic regression</a><a class="docs-footer-nextpage" href="../../lecture_09/theory/">Theory of neural networks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 January 2021 15:11">Monday 4 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
