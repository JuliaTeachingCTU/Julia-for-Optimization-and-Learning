<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interaction with other languages · Julia for Optimization and Learning</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/ctustyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Optimization and Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Optimization and Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Julia for Optimization and Learning</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/vscode/">Julia + Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Data structures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_02/tuples/">Tuples and named tuples</a></li><li><a class="tocitem" href="../../lecture_02/dictionaries/">Dictionaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_03/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_04/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_04/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_04/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_04/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../Plots/">Plots.jl</a></li><li><a class="tocitem" href="../DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../otherpackages/">Other useful packages</a></li><li class="is-active"><a class="tocitem" href>Interaction with other languages</a><ul class="internal"><li><a class="tocitem" href="#RCall.jl"><span>RCall.jl</span></a></li><li><a class="tocitem" href="#MATLAB.jl"><span>MATLAB.jl</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_06/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_07/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_07/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_08/gradients/">Gradients</a></li><li><a class="tocitem" href="../../lecture_08/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_08/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../../lecture_09/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_09/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">11: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_11/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../../lecture_11/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_11/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">12: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/sparse/">Linear regression with sparse constraints</a></li><li><a class="tocitem" href="../../lecture_12/monte/">Monte Carlo sampling</a></li><li><a class="tocitem" href="../../lecture_12/glm/">Linear regression revisited</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">13: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_13/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_13/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_13/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_13/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">5: Packages</a></li><li class="is-active"><a href>Interaction with other languages</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interaction with other languages</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Julia-for-Optimization-and-Learning/blob/master/docs/src/lecture_05/interaction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interaction-with-other-languages"><a class="docs-heading-anchor" href="#Interaction-with-other-languages">Interaction with other languages</a><a id="Interaction-with-other-languages-1"></a><a class="docs-heading-anchor-permalink" href="#Interaction-with-other-languages" title="Permalink"></a></h1><p>One of the most significant advantages of Julia is its speed. As we discussed in  the section <a href="../../why/#Why-julia?">Why julia?</a>, Julia is fast out-of-box without the necessity to do any additional steps. As a result, Julia solves the so-called Two-Language problem:</p><blockquote><p>Users are programming in a high-level language such as R and Python, but the performance-critical parts of the code have to be rewritten in C/Fortran for performance.</p></blockquote><p>Since Julia is fast enough, most of the libraries are written in pure Julia, and there is no need to use C/Fortran for performance. However, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. It would be a shame if it will not be possible to use them in Julia.</p><p>To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a <strong>no boilerplate</strong> philosophy: functions can be called directly from Julia without any glue code generation or compilation – even from the interactive prompt. This is accomplished just by making an appropriate call with the <code>ccall</code> syntax, which looks like an ordinary function call. Moreover, it is possible to pass Julia functions to native C functions that accept function pointer arguments. This section will show one example of the interaction between Julia and C. Extensive description of all provided functionality can be found in the <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/">official manual</a>.</p><p>The following example is taken from the official manual. Consider the situation that we want to use the <code>qsort</code> function from the standard C library. The <code>qsort</code> function sorts an array and is declared as follows.</p><pre><code class="language-c hljs">void qsort(void *base, size_t nitems, size_t size,
           int (*compare)(const void*, const void*))</code></pre><p>The <code>base</code> is the pointer to the first element of the array to be sorted. The <code>nitems</code> is the number of elements in the array pointed by <code>base</code>.  The <code>size</code> is the size in bytes of each element in the array. Finally, the <code>compare</code> is the function that compares two elements. The <code>compare</code> function should return a negative integer if the first argument is less than the second, a positive integer if the first argument is greater than the second, and otherwise zero. Such a Julia function can be defined as follows.</p><pre><code class="language-julia hljs">mycompare(a, b)::Cint = sign(a - b)</code></pre><p>Since the <code>qsort</code> function expects that the return type of the <code>compare</code> function is C <code>int</code>, we annotate the return type to be <code>Cint</code>. In order to pass this function to C, we obtain its address using the macro <code>@cfunction</code>.</p><pre><code class="language-julia hljs">mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))</code></pre><p>The <code>@cfunction</code> macro requires three arguments: the Julia function, the return type, and the tuple of the input argument types. Finally, we can use the <code>ccall</code> function to call the <code>qsort</code> function.</p><pre><code class="language-julia hljs">julia&gt; A = [1.3, -2.7, 4.4, 3.1];

julia&gt; ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia&gt; A
4-element Vector{Float64}:
 -2.7
  1.3
  3.1
  4.4</code></pre><p>Besides C and Fortran that can be called directly using <code>ccall</code> function, it is possible to interact with other languages using third-party packages. The following table shows an overview of those packages.</p><table><tr><th style="text-align: left">Language</th><th style="text-align: left">Calling from Julia</th><th style="text-align: left">Calling Julia</th></tr><tr><td style="text-align: left">C++</td><td style="text-align: left"><a href="https://github.com/JuliaInterop/Cxx.jl">Cxx.jl package</a></td><td style="text-align: left">???</td></tr><tr><td style="text-align: left">Python</td><td style="text-align: left"><a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a></td><td style="text-align: left"><a href="https://github.com/JuliaPy/pyjulia">PyJulia</a></td></tr><tr><td style="text-align: left">R</td><td style="text-align: left"><a href="https://github.com/JuliaInterop/RCall.jl">RCall.jl</a></td><td style="text-align: left"><a href="https://github.com/Non-Contradiction/JuliaCall">JuliaCall</a></td></tr><tr><td style="text-align: left">Mathematica</td><td style="text-align: left"><a href="https://github.com/JuliaInterop/MathLink.jl">MathLink.jl</a></td><td style="text-align: left"><a href="https://reference.wolfram.com/language/ref/ExternalEvaluate.html">ExternalEvaluate</a></td></tr><tr><td style="text-align: left">MATLAB</td><td style="text-align: left"><a href="https://github.com/JuliaInterop/MATLAB.jl">MATLAB.jl</a></td><td style="text-align: left"><a href="https://github.com/jebej/Mex.jl/">Mex.jl</a></td></tr><tr><td style="text-align: left">Java</td><td style="text-align: left"><a href="https://github.com/JuliaInterop/JavaCall.jl">JavaCall.jl</a></td><td style="text-align: left"><a href="https://github.com/jbytecode/juliacaller">JuliaCaller</a></td></tr></table><p>Moreover, other Julia packages provide Julia interface for some well-known libraries from other languages. As an example, we can mention <a href="https://github.com/cstjean/ScikitLearn.jl">ScikitLear.jl</a>, which provides an interface for the <a href="https://scikit-learn.org/stable/">scikit-learn</a> library from Python or the <a href="https://github.com/JuliaStats/RDatasets.jls">RDatasets.jl</a> that provides an easy way to load famous R datasets.</p><h2 id="RCall.jl"><a class="docs-heading-anchor" href="#RCall.jl">RCall.jl</a><a id="RCall.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RCall.jl" title="Permalink"></a></h2><p>The <a href="https://github.com/JuliaInterop/RCall.jl">RCall.jl</a> package provides an interface for calling R functions from Julia and passing data between these two languages. The package provides an interactive REPL for the R language that can be accessed from the Julia REPL by typing the <code>$</code> symbol. Consequently, it is possible to easily switch between these languages and use functionality provided by both languages simultaneously.</p><pre><code class="language-julia hljs">julia&gt; using RCall, RDatasets

julia&gt; mtcars = dataset(&quot;datasets&quot;, &quot;mtcars&quot;);

R&gt; library(ggplot2)

R&gt; ggplot($mtcars, aes(x = WT, y = MPG)) + geom_point()</code></pre><p><img src="../ggplot.svg" alt/></p><p>The package also provides string syntax that allows non-interactive usage. The previous example can be rewritten as follows.</p><pre><code class="language-julia hljs">using RCall, RDatasets
mtcars = dataset(&quot;datasets&quot;, &quot;mtcars&quot;);

R&quot;&quot;&quot;
library(ggplot2)
ggplot($mtcars, aes(x = WT, y = MPG)) + geom_point()
&quot;&quot;&quot;</code></pre><p>Note that we use multiline string syntax, but it is also possible to use standard string syntax. This multiline string syntax is very useful, especially when we want to perform multiple operations in R at once and then just return the result to Julia.</p><h2 id="MATLAB.jl"><a class="docs-heading-anchor" href="#MATLAB.jl">MATLAB.jl</a><a id="MATLAB.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MATLAB.jl" title="Permalink"></a></h2><p>The <a href="https://github.com/JuliaInterop/MATLAB.jl">MATLAB.jl</a> provides an easy interface for calling Matlab functions and passing data between Julia and Matlab. Consider the situation that you wrote a Matlab function that uses some special functionality that is not available in Julia. MATLAB.jl package provides an interface to call this function directly from Julia, as can be seen in the following example.</p><pre><code class="language-julia hljs">using MATLAB, BSON

X = BSON.load(&quot;data.bson&quot;)[:X]
mxcall(:MakeVideo, 0, X, &quot;video.gif&quot;)</code></pre><p>The <code>mxcall</code> function accepts the name of the function as the first argument and the number of the output variables of that function as the second argument. All other inputs to the <code>mxcall</code> function are the input arguments of the Matlab function. The result is the following animation.</p><p><img src="../../data/Video.gif" alt/></p><p>Like the RCall.jl package, the MATLAB.jl package also provides string syntax that allows for Matlab syntax. The previous example can be rewritten as follows.</p><pre><code class="language-julia hljs">using MATLAB, BSON

X = BSON.load(&quot;data.bson&quot;)[:X]
mat&quot;&quot;&quot;
MakeVideo($(X), 30, &quot;Video2.gif&quot;);
&quot;&quot;&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../otherpackages/">« Other useful packages</a><a class="docs-footer-nextpage" href="../../lecture_06/compositetypes/">Abstract and composite types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 13 December 2022 14:33">Tuesday 13 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
