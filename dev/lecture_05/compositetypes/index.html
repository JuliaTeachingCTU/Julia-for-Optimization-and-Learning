<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Abstract and composite types · Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Abstract and composite types</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Composite-types"><span>Composite types</span></a></li><li><a class="tocitem" href="#Mutable-composite-types"><span>Mutable composite types</span></a></li><li><a class="tocitem" href="#Parametric-types"><span>Parametric types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Default-field-values"><span>Default field values</span></a></li></ul></li><li><a class="tocitem" href="../currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_06/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_06/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Statistics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">5: Type system and generic programming</a></li><li class="is-active"><a href>Abstract and composite types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Abstract and composite types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_05/compositetypes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h1><p>Julia does not allow abstract types to be instantiated. They can only be used to create a logical hierarchy of types. The following figure shows this hierarchy for numeric types introduced in the first lecture.</p><p><img src="../types.svg" alt/></p><p>All types depicted in blue are abstract types, and all green types are concrete types. For example, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code> and <code>Int128</code> are signed integer types, <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code> and <code>UInt128</code> are unsigned integer types, while <code>Float16</code>, <code>Float32</code> and <code>Float64</code> are floating-point types. In many cases, the inputs must be of a specific type. An algorithm to find the greatest common denominator should work any integer types, but it should not work for any floating-point inputs. Abstract types specify these cases and provide a context into which concrete types can fit.</p><p>Abstract types are defined by <code>abstract type</code> followed by the type name. It is possible to specify a type to be a subtype of another abstract type. The definition of abstract numeric types would be:</p><pre><code class="language-julia">abstract type Number end
abstract type Real &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type AbstractIrrational &lt;: Real end
abstract type Integer &lt;: Real end
abstract type Signed &lt;: Integer end
abstract type Unsigned &lt;: Integer end</code></pre><p>When no supertype is specified, such as for <code>Number</code>, the default supertype is <code>Any</code>. The <code>Any</code> type is sometimes called the <em>top</em> type since all types are its subtypes. The <em>bottom</em> type is <code>Union{}</code>, and all types are supertypes of <code>Union{}</code>.</p><p>The <code>&lt;:</code> operator can be used to check if the left operand is a subtype of the right operand.</p><pre><code class="language-julia-repl">julia&gt; Signed &lt;: Integer
true

julia&gt; Signed &lt;: Number
true

julia&gt; Signed &lt;: AbstractFloat
false</code></pre><p>Julia also provides the <code>isa</code> function, which checks if a variable is an instance of a type.</p><pre><code class="language-julia-repl">julia&gt; isa(1, Int64) # equivalent to typeof(1) &lt;: Int64
true

julia&gt; isa(1, Integer) # equivalent to typeof(1) &lt;: Integer
true

julia&gt; isa(1, AbstractFloat) # equivalent to typeof(1) &lt;: AbstractFloat
false</code></pre><p>Other handy functions are <code>isabstracttype</code> and <code>isconcretetype</code> that check whether a type is abstract and concrete, respectively.</p><pre><code class="language-julia-repl">julia&gt; isabstracttype(Real)
true

julia&gt; isabstracttype(Float64)
false

julia&gt; isconcretetype(Real)
false

julia&gt; isconcretetype(Float64)
true</code></pre><h1 id="Composite-types"><a class="docs-heading-anchor" href="#Composite-types">Composite types</a><a id="Composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-types" title="Permalink"></a></h1><p>A composite type is a collection of key-value pairs. In many languages, composite types are the only kind of user-definable type. Even though Julia allows defining other types, composite types are used the most. Their main goal is to collect all information about one object within one structure. We will soon define the <code>Rectangle</code> type containing information about the size and the bottom-left point position of a rectangle. Collecting this information into one structure makes it simple to pass all information about the rectangle as arguments and use it for further computation. Moreover, it is possible to use composite types in combination with multiple-dispatch and define specialized functions for custom types.</p><p>The <code>struct</code> keyword defines composite types. It is followed by the composite type name and field names, where the latter may be annotated with types.</p><pre><code class="language-julia">struct Rectangle
    bottomleft::Vector{Float64}
    width
    height
end</code></pre><p>If the type annotation is omitted, <code>Any</code> is used, and such a field may contain any value. A Julia convention suggests making the first letter in custom type names uppercase. We can create a new instance of the above type by calling <code>Rectangle</code> as a function. Its input arguments represent the fields of the <code>Rectangle</code> type.</p><pre><code class="language-julia-repl">julia&gt; r = Rectangle([1,2], 3, 4)
Rectangle([1.0, 2.0], 3, 4)

julia&gt; isa(r, Rectangle)
true</code></pre><p>A constructor is calling a type as a function. Two constructors are automatically generated when a type is created. One accepts any arguments and converts them to the field types, and the other accepts arguments that match the field types exactly. If all fields are <code>Any</code>, only one constructor is generated. Julia creates these two constructors to make it easier to add new definitions without replacing the default constructor. We can list all constructors by the <code>methods</code> function.</p><pre><code class="language-julia-repl">julia&gt; methods(Rectangle)
# 2 methods for type constructor:
[1] Rectangle(bottomleft::Array{Float64,1}, width, height) in Main at none:2
[2] Rectangle(bottomleft, width, height) in Main at none:2</code></pre><p>The fields of composite types can be accessed via the dot notation similarly to named tuples or via the <code>getproperty</code> function.</p><pre><code class="language-julia-repl">julia&gt; r.width
3

julia&gt; getproperty(r, :width)
3</code></pre><p>The fields can be then accessed anywhere, for example, within a function.</p><pre><code class="language-julia-repl">julia&gt; area(r::Rectangle) = r.width * r.height
area (generic function with 1 method)

julia&gt; function vertices(r::Rectangle)
           x, y = r.bottomleft
           w, h = r.width, r.height
           return [[x, y], [x + w, y], [x + w, y + h], [x, y + h]]
       end
vertices (generic function with 1 method)

julia&gt; area(r)
12

julia&gt; vertices(r)
4-element Array{Array{Float64,1},1}:
 [1.0, 2.0]
 [4.0, 2.0]
 [4.0, 6.0]
 [1.0, 6.0]</code></pre><p>The convenient function <code>fieldnames</code> returns a tuple with names of all structure fields represented as symbols.</p><pre><code class="language-julia-repl">julia&gt; fieldnames(Rectangle)
(:bottomleft, :width, :height)

julia&gt; fieldnames(typeof(r))
(:bottomleft, :width, :height)</code></pre><div class = "info-body">
<header class = "info-header">Comparison with Python</header><p><p>The same object can be defined in Python in the following way:</p><pre><code class="language-python">class Rectangle:
    def __init__(self, bottomleft, width, height):
        self.bottomleft = bottomleft
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def vertices(self):
        x, y = self.bottomleft
        w, h = self.width, self.height
        return [[x, y], [x + w, y], [x + w, y + h], [x, y + h]]</code></pre><p>We can create an instance of this object and call the two functions defined in the class definition.</p><pre><code class="language-python">In [2]: r = Rectangle([1.0, 2.0], 3, 4)

In [3]: r.area()
Out[3]: 12

In [4]: r.vertices()
Out[4]: [[1.0, 2.0], [4.0, 2.0], [4.0, 6.0], [1.0, 6.0]]</code></pre><p>The declaration of the <code>Rectangle</code> class is very similar to the one in Julia. The main difference is that Python defines the functions inside of the class while Julia defines them outside. The Julia approach has several advantages:</p><ol><li>Julia has more options to logically split the code. This may increase readability.</li><li>When working with a class defined in an external package, Julia can simply define additional functions to this class. Python needs to use inheritance to modify the class. When a multiple people use inheritance to the same class, it is not clear how to merge the inherited classes together. Therefore, Julia makes it simpler to create packages which combine and modify multiple existing packages.</li><li>When working with multiple classes, it does not need to be clear to which a function should belong. Python sometimes needs to create an additional class which unites these two classes. Julia does not have this problem as functions are defined externally.</li></ol><p>in Julia functions are defined outside of the declaration of the structure. This is very important since Julia uses multiple-dispatch. It means, that functions consist of methods, and Julia decides which method to use based on the number of input arguments and its types. Since all arguments are used for method selection, it would be inappropriate for functions to &quot;belong&quot; to some composite type. As a consequence, we can modify existing methods or add new ones without the necessity to change the composite type definition. This property significantly improves code extensibility and reusability.</p></p></div><h2 id="Mutable-composite-types"><a class="docs-heading-anchor" href="#Mutable-composite-types">Mutable composite types</a><a id="Mutable-composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-composite-types" title="Permalink"></a></h2><p>Composite types declared with <code>struct</code> keyword are immutable and cannot be modified after being constructed.</p><pre><code class="language-julia-repl">julia&gt; r.bottomleft = [2;2]
ERROR: setfield! immutable struct of type Rectangle cannot be changed</code></pre><p>However, immutability is not recursive. If an immutable object contains a mutable object, such as an array, elements of this mutable object can be modified. Even though <code>Rectangle</code> is an immutable type, its <code>bottomleft</code> field is a mutable array and can be changed.</p><pre><code class="language-julia-repl">julia&gt; r.bottomleft[1] = 5
5

julia&gt; r.bottomleft
2-element Array{Float64,1}:
 5.0
 2.0

julia&gt; area(r)
12

julia&gt; vertices(r)
4-element Array{Array{Float64,1},1}:
 [5.0, 2.0]
 [8.0, 2.0]
 [8.0, 6.0]
 [5.0, 6.0]</code></pre><p>To allow changing their fields, we need to define composite types as mutable by adding the <code>mutable</code> keyword.</p><pre><code class="language-julia">mutable struct MutableRectangle
    bottomleft::Vector{Float64}
    width
    height
end</code></pre><p>We can work with mutable and immutable types in the same way.</p><pre><code class="language-julia-repl">julia&gt; mr = MutableRectangle([1,2], 3, 4)
MutableRectangle([1.0, 2.0], 3, 4)

julia&gt; isa(mr, MutableRectangle)
true</code></pre><p>Similarly to accessing field values, we can change them by the dot notation or the <code>setproperty!</code> function.</p><pre><code class="language-julia-repl">julia&gt; mr.width = 1.5
1.5

julia&gt; setproperty!(mr, :height, 2.5)
2.5

julia&gt; mr
MutableRectangle([1.0, 2.0], 1.5, 2.5)</code></pre><div class = "info-body">
<header class = "info-header">Type unions</header><p><p>The <code>area</code> function defined earlier will only work for <code>Rectangle</code> but not for <code>MutableRectangle</code> types. To define it for both types, we need type unions. The <code>Union</code> keyword creates a supertype of its inputs.</p><pre><code class="language-julia-repl">julia&gt; const AbstractRectangle = Union{Rectangle, MutableRectangle}
Union{MutableRectangle, Rectangle}

julia&gt; Rectangle &lt;: AbstractRectangle
true

julia&gt; MutableRectangle &lt;: AbstractRectangle
true</code></pre><p>We now create the <code>perimeter(r::AbstractRectangle)</code> function. Since we specify that its input is an <code>AbstractRectangle</code>, it will work for both mutable <code>MutableRectangle</code> and immutable <code>Rectangle</code> types.</p><pre><code class="language-julia-repl">julia&gt; perimeter(r::AbstractRectangle) = 2*(r.width + r.height)
perimeter (generic function with 1 method)

julia&gt; perimeter(r)
14

julia&gt; perimeter(mr)
8.0</code></pre></p></div><h2 id="Parametric-types"><a class="docs-heading-anchor" href="#Parametric-types">Parametric types</a><a id="Parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-types" title="Permalink"></a></h2><p>An important and powerful feature of the Julia type system is that it is parametric. Types can take parameters, and type declarations introduce a whole family of new types (one for each possible combination of parameter values). Parametric (abstract) types can be defined as follows:</p><pre><code class="language-julia">abstract type AbstractPoint{T} end

struct Point{T &lt;: Real} &lt;: AbstractPoint{T}
    x::T
    y::T
end</code></pre><p>The example above defines a parametric abstract type <code>AbstractPoint</code> and its parametric subtype <code>Point</code>. The declaration of the concrete type <code>Point{T &lt;: Real}</code> has two fields of type <code>T</code>, where <code>T</code> can be any subtype of <code>Real</code>. This definition ensures that both fields are always of the same type. Note that <code>Point{Float64}</code> is a concrete type equivalent to replacing <code>T</code> in the definition of <code>Point</code> by <code>Float64</code>.</p><pre><code class="language-julia-repl">julia&gt; isconcretetype(Point{Float64})
true</code></pre><p>This single declaration declares a concrete type for each type <code>T</code> that is a subtype of <code>Real</code>.  The <code>Point</code> type itself is also a valid type object, containing all instances <code>Point{Float64}</code>, <code>Point{Int64}</code>, etc., as subtypes.</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point &lt;: AbstractPoint
true

julia&gt; Point{Int64} &lt;: Point &lt;: AbstractPoint
true</code></pre><p>Concrete <code>Point</code> types with different <code>T</code> values are never subtypes of each other. Even though <code>Float64</code> is a subtype of <code>Real</code>, <code>Point{Float64}</code> is not a subtype of  <code>Point{Real}</code>.</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point{Real}
false

julia&gt; Point{Float64} &lt;: AbstractPoint{Float64}
true

julia&gt; Point{Float64} &lt;: AbstractPoint{Real}
false</code></pre><p>This behaviour has important consequences: while any instance of <code>Point{Float64}</code> may be represented as an instance of <code>Point{Real}</code>, these two types have different representations in memory:</p><ul><li>An instance of <code>Point{Float64}</code> can be efficiently represented as a pair of 64-bit values;</li><li>An instance of <code>Point{Real}</code> must be able to hold any pair of <code>Real</code> values. Since instances of <code>Real</code> can have arbitrary size and structure, an instance of <code>Point{Real}</code> must be represented as a pair of pointers to individually allocated <code>Real</code> objects.</li></ul><p>This efficiency gain is magnified for arrays: <code>Array{Float64}</code> can be stored as a contiguous memory block of 64-bit floating-point values, whereas <code>Array{Real}</code> is an array of pointers to <code>Real</code> objects.</p><p>Since <code>Point{Float64}</code> is not a subtype of <code>Point{Real}</code>, the following method cannot be applied to arguments of type <code>Point{Float64}</code>.</p><pre><code class="language-julia">julia&gt; coordinates(p::Point{Real}) = (p.x, p.y)

julia&gt; coordinates(Point(1,2))
ERROR: MethodError: no method matching coordinates(::Point{Int64})
[...]

julia&gt; coordinates(Point(1.0,2.0))
ERROR: MethodError: no method matching coordinates(::Point{Float64})
[...]</code></pre><p>The correct way to define a method that accepts all arguments of type <code>Point{T}</code> where <code>T</code> is a subtype of <code>Real</code> is as follows:</p><pre><code class="language-julia-repl">julia&gt; coordinates(p::Point{&lt;:Real}) = (p.x, p.y)
coordinates (generic function with 1 method)

julia&gt; coordinates(Point(1,2))
(1, 2)

julia&gt; coordinates(Point(1.0,2.0))
(1.0, 2.0)</code></pre><p>It is also possible to define a function for all subtypes of some abstract type.</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, p::AbstractPoint) = print(io, coordinates(p))

julia&gt; Point(4, 2)
(4, 2)

julia&gt; Point(0.2, 1.3)
(0.2, 1.3)</code></pre><p>There are two ways how to instantiate the <code>Point</code> type.  The first one does not specify the <code>T</code> parameter and lets Julia automatically decide the appropriate type. The second one specifies the <code>T</code> parameter manually.</p><pre><code class="language-julia-repl">julia&gt; Point(1, 2)
(1, 2)

julia&gt; Point{Float32}(1, 2)
(1.0f0, 2.0f0)</code></pre><p>The first way works only if the arguments have the same type.</p><pre><code class="language-julia-repl">julia&gt; Point(1, 2.0)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T&lt;:Real at none:3</code></pre><p>This situation can be handled by defining custom constructors, as we will discuss in the next section.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Define a structure that represents 3D-points. Do not forget to define it as a subtype of the AbstractPoint type. Then add a new method to the <code>coordinates</code> function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>There are several possibilities for defining the structure. We define it as a structure with three fields. Another option is to use a tuple to store the point coordinates.</p><pre><code class="language-julia">struct Point3D{T &lt;: Real} &lt;: AbstractPoint{T}
    x::T
    y::T
    z::T
end

coordinates(p::Point3D) = (p.x, p.y, p.z)</code></pre><p>Since the <code>show</code> function was defined for the abstract type <code>AbstractPoint</code> and uses the <code>coordinates</code> function, the custom print is applied to <code>Point3D</code> without the need for further changes.</p><pre><code class="language-julia-repl">julia&gt; Point3D(1, 2, 3)
(1, 2, 3)

julia&gt; Point3D{Float32}(1, 2, 3)
(1.0f0, 2.0f0, 3.0f0)</code></pre></p></details><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>Constructors are functions that create new instances of composite types. When a user defines a new composite type,  Julia creates the default constructors. Sometimes it is helpful to add additional constructors. In the example from the previous section, we may want to create an instance of <code>Point</code> from two numbers with different types. This can be achieved by defining the following constructor.</p><pre><code class="language-julia">Point(x::Real, y::Real) = Point(promote(x, y)...)</code></pre><p>The <code>promote</code> function converts its arguments to the supertype that can represent both inputs. For example, <code>promote(1, 2.3)</code> results in the tuple <code>(1.0, 2.3)</code> because it is possible to represent <code>Int64</code> by <code>Float64</code>, but not the other way round. We can test the new constructor on the example from the end of the previous section. As expected, the result has the type <code>Point{Float64}</code>.</p><pre><code class="language-julia-repl">julia&gt; Point(1, 2.0)
(1.0, 2.0)

julia&gt; typeof(Point(1, 2.0))
Point{Float64}</code></pre><p>The constructor defined above is the outer constructor because it is defined outside of the type definition. A constructor behaves like any other function in Julia and may have multiple methods. We can define new methods to add additional functionality to a constructor. On the other hand, outer constructors cannot construct self-referential objects or instances with some special properties. In such a case, we have to use inner constructors, which differ from outer constructors in two aspects:</p><ol><li>They are declared inside the composite type declaration rather than outside of it.</li><li>They have access to the local function <code>new</code> that creates new instances of the composite type.</li></ol><p>For example, one may want to create a type with two real numbers, where the first number cannot be greater than the second one. The inner constructor can ensure this.</p><pre><code class="language-julia">struct OrderedPair{T &lt;: Real}
    x::T
    y::T

    function OrderedPair(x::Real, y::Real)
        x &gt; y &amp;&amp; error(&quot;the first argument must be less than or equal to the second one&quot;)
        xp, yp = promote(x, y)
        return new{typeof(xp)}(xp, yp)
    end
end</code></pre><p>If an inner constructor method is provided, <strong>no default constructor method is constructed</strong>.  The example above ensures that any instance of the <code>OrderedPair</code> satisfies <code>x &lt;= y</code>.</p><pre><code class="language-julia-repl">julia&gt; OrderedPair(1,2)
OrderedPair{Int64}(1, 2)

julia&gt; OrderedPair(2,1)
ERROR: the first argument must be less than or equal to the second one
[...]</code></pre><p>Inner constructors have an additional advantage. Since outer constructors create the object by calling an appropriate inner constructor, even if we define any number of outer constructors, the resulting instances of the <code>OrderedPair</code> type will always satisfy <code>x &lt;= y</code>.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Define a structure that represents ND-points and stores their coordinates as <code>Tuple</code>. Do not forget to define it as a subtype of the <code>AbstractPoint</code> type. Redefine the default inner constructor to create an instance of <code>PointND</code> from different types. Then add a new method to the <code>coordinates</code> function, and define function <code>dim</code> that returns the dimension of the point.</p><p><strong>Hints:</strong> use the <code>new</code> function in the definition of the new inner constructor.</p><p><strong>Bonus:</strong> Tuples with elements of the same type can be described by the special type <code>NTuple{N, T}</code>, where <code>N</code> is the number of elements and <code>T</code> their type.</p><pre><code class="language-julia-repl">julia&gt; NTuple{2, Int64} &lt;: Tuple{Int64, Int64}
true</code></pre></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>In this case, we can use an inner constructor with the optional number of input arguments. In the definition below, we use type annotation to set these arguments to be real numbers. Since we use the <code>new</code> function and our type is parametric, we have to specify <code>N</code> and type <code>T</code>.</p><pre><code class="language-julia">struct PointND{N, T &lt;: Real} &lt;: AbstractPoint{T}
    x::NTuple{N, T}

    function PointND(args::Real...)
        vals = promote(args...)
        return new{length(args), eltype(vals)}(vals)
    end
end

coordinates(p::PointND) = p.x
dim(p::PointND{N}) where N = N</code></pre><p>Note that we use the parameter <code>N</code> in the definition of the <code>dim</code> function.</p><p>Since the <code>show</code> function was defined for the abstract type <code>AbstractPoint</code> and uses the <code>coordinates</code> function, the custom printing function is immediately applied to the new type. Since we redefined the default constructors, we can create an instance of the <code>PointND</code> type from inputs of mixed types.</p><pre><code class="language-julia-repl">julia&gt; p = PointND(1, 2)
(1, 2)

julia&gt; dim(p)
2

julia&gt; p = PointND(1, 2.2, 3, 4.5)
(1.0, 2.2, 3.0, 4.5)

julia&gt; dim(p)
4</code></pre></p></details><h2 id="Default-field-values"><a class="docs-heading-anchor" href="#Default-field-values">Default field values</a><a id="Default-field-values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-field-values" title="Permalink"></a></h2><p>It may be beneficial to define custom types with default field values. Since a constructor is a function, one way to achieve this is to use optional or keyword arguments in its declaration. Another option is to use the <code>@kwdef</code> macro from <code>Base</code> that automatically defines keyword-based constructors.</p><pre><code class="language-julia">Base.@kwdef struct MyType
    a::Int # required keyword
    b::Float64 = 2.3
    c::String = &quot;hello&quot;
end</code></pre><p>The <code>methods</code> function shows that Julia created three constructors.  The <code>@kwdef</code> macro creates the first constructor; the other two constructors are the default constructors.</p><pre><code class="language-julia-repl">julia&gt; methods(MyType)
# 3 methods for type constructor:
[1] MyType(; a, b, c) in Main at util.jl:438
[2] MyType(a::Int64, b::Float64, c::String) in Main at none:2
[3] MyType(a, b, c) in Main at none:2</code></pre><p>A <code>MyType</code> instance can be created by the default constructors.</p><pre><code class="language-julia-repl">julia&gt; MyType(1, 2.3, &quot;aaa&quot;)
MyType(1, 2.3, &quot;aaa&quot;)</code></pre><p>The other way is to use the constructor with predefined field values. Then all values have to be passed as keyword arguments. The fields without default values are mandatory keyword arguments: we have to specify them.</p><pre><code class="language-julia-repl">julia&gt; MyType(; a = 3)
MyType(3, 2.3, &quot;hello&quot;)

julia&gt; MyType(; a = 5, b = 4.5)
MyType(5, 4.5, &quot;hello&quot;)</code></pre><div class = "info-body">
<header class = "info-header">Function-like objects</header><p><p>Methods are associated with types; therefore, it is possible to make an arbitrary Julia object &quot;callable&quot; by adding methods to its type. Such &quot;callable&quot; objects are sometimes called functors. Using this technique to the <code>MyType</code> defined above, we can define a method that returns values of all its fields.</p><pre><code class="language-julia-repl">julia&gt; (m::MyType)() = (m.a, m.b, m.c)

julia&gt; m = MyType(; a = 5, b = 4.5)
MyType(5, 4.5, &quot;hello&quot;)

julia&gt; m()
(5, 4.5, &quot;hello&quot;)</code></pre><p>Moreover, we can use multiple-dispatch for functors. We show an example, where the functor has a different behaviour when it is called with a number and a string.</p><pre><code class="language-julia">(m::MyType)(x::Real) = m.a*x + m.b
(m::MyType)(x::String) = &quot;$(m.c), $(x)&quot;</code></pre><p>These two methods give different results.</p><pre><code class="language-julia-repl">julia&gt; m(1)
9.5

julia&gt; m(&quot;world&quot;)
&quot;hello, world&quot;</code></pre></p></div><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p><a href="https://en.wikipedia.org/wiki/Normal_distribution">Gaussian distribution</a> is uniquely represented by its mean <span>$\mu$</span> and variance <span>$\sigma^2&gt;0$</span>. Write a structure <code>Gauss</code> with the proper fields and an inner constructor that checks if the input parameters are correct. Initialization without arguments <code>Gauss()</code> should return the standardized normal distribution (<span>$\mu = 0$</span> and <span>$\sigma = 1$</span>).  Define a functor that computes the probability density function at a given point defined by</p><p class="math-container">\[f_{\mu, \sigma}(x) = \frac{1}{\sigma \sqrt{ 2\pi }} \exp\left\{ -\frac{1}{2} \left( \frac{x - \mu}{\sigma} \right) ^2 \right\},\]</p><p>Verify that the probability density function is defined correctly, i.e., its integral equals 1.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>One possible way to define this structure is the <code>@kwdef</code> macro, where we specify the default parameters. We also define an inner constructor that promotes the inputs to a same type, and checks if the variance is positive.</p><pre><code class="language-julia">Base.@kwdef struct Gauss{T&lt;:Real}
    μ::T = 0
    σ::T = 1

    function Gauss(μ::Real, σ::Real)
        σ^2 &gt; 0 || error(&quot;the variance `σ^2` must be positive&quot;)
        pars = promote(μ, σ)
        return new{eltype(pars)}(pars...)
    end
end</code></pre><p>We specified the parameter <code>T</code> by <code>eltype(pars)</code> in the call of the <code>new</code> function. The probability density function can be defined as a functor in the following way:</p><pre><code class="language-julia">(d::Gauss)(x::Real) = exp(-1/2 * ((x - d.μ)/d.σ)^2)/(d.σ * sqrt(2*π))</code></pre><p>We use type annotation to ensure that all input arguments are real numbers.</p><pre><code class="language-julia-repl">julia&gt; gauss = Gauss()
Gauss{Int64}(0, 1)

julia&gt; gauss(0)
0.3989422804014327</code></pre><p>The integral of the probability density function over the real line should equal one. We check it numerically by discretizing the integral into a finite sum.</p><pre><code class="language-julia-repl">julia&gt; step = 0.01
0.01

julia&gt; x = -100:step:100;

julia&gt; sum(Gauss(), x) * step
1.0000000000000002

julia&gt; sum(Gauss(0.1, 2.3), x) * step
1.0</code></pre><p>We use <code>sum</code> with a function as the first input argument and apply it to each value of the second argument. This is possible because we defined a functor for <code>Gauss</code>. The result is the same as <code>sum(Gauss().(x))</code>. The difference is that the former, similarly to generators, does not allocate an array.</p></p></details><div class = "info-body">
<header class = "info-header">Plot recipes</header><p><p>The previous exercise defined a new type representing the Gaussian distribution. We also defined a functor that computes the probability density function of this distribution. It makes sense to visualize the probability density function using the <a href="../../lecture_04/Plots/#Plots.jl">Plots</a> package. Unfortunately, it is not possible to use <a href="../../lecture_04/Plots/#Function-plotting">Function plotting</a>, i.e., the following will not work even though the <code>Gauss</code> type is callable.</p><pre><code class="language-julia">plot(x, Gauss())</code></pre><p>Using the system of Julia types, it is possible to obtain special behaviour for a certain type only by defining a new method for this type. For example, if we use the <code>plot</code> function, all input data and plot attributes are preprocessed to some standard format and then the final graph is created. Due to the Julia type system, we can easily change how this preprocessing happens and define special behaviour for custom types.</p><p>For plotting, this is done by the <code>@recipe</code> macro from the <a href="https://github.com/JuliaPlots/RecipesBase.jl">RecipesBase</a> package. The RecipesBase package provides the functionality related to creating custom plots and the Plots package uses this functionality. Moreover, since the RecipesBase package is much smaller, its first run is faster. The syntax is straightforward. In the function head, we define two inputs: our type and input <code>x</code>. In the function body, we define plot attributes in the same way as if we pass them into the <code>plot</code> function. Finally, we define the output of the function.</p><pre><code class="language-julia">using RecipesBase

@recipe function f(d::Gauss, x = (d.μ - 4d.σ):0.1:(d.μ + 4d.σ))
    seriestype  :=  :path
    label --&gt; &quot;Gauss(μ = $(d.μ), σ = $(d.σ))&quot;
    xguide --&gt; &quot;x&quot;
    yguide --&gt; &quot;f(x)&quot;
    linewidth --&gt; 2
    return x, d.(x)
end</code></pre><p>The operators <code>:=</code> and <code>--&gt;</code> are specific for this package. Both set default values for plotting attributes. The difference is that the default values can be changed for <code>--&gt;</code> but cannot be changed for <code>:=</code>.</p><p>The recipe above is equivalent to calling the <code>plot</code> function.</p><pre><code class="language-julia">d = Gauss()
plot(x, d.(x);
    seriestype := :path,
    label = &quot;Gauss(μ = $(d.μ), σ = $(d.σ))&quot;,
    xguide = &quot;x&quot;,
    yguide = &quot;f(x)&quot;,
    linewidth = 2
)</code></pre><p>With the new plot recipe, we can plot the probability density function of the Gaussian distribution with different parameters.</p><pre><code class="language-julia">using Plots

plot(Gauss())
plot!(Gauss(4, 2); linewidth = 4, color = :red)
plot!(Gauss(-3, 2); label = &quot;new label&quot;, linestyle = :dash)</code></pre><p><img src="../gauss.svg" alt/></p></p></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_04/interaction/">« Interaction with other languages</a><a class="docs-footer-nextpage" href="../currencies/">Generic programming »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 March 2021 10:24">Tuesday 23 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
