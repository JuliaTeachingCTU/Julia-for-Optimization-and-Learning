<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Abstract and composit types · Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Abstract and composit types</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Composite-types"><span>Composite types</span></a></li><li><a class="tocitem" href="#Parametric-types"><span>Parametric types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Default-field-values"><span>Default field values</span></a></li></ul></li><li><a class="tocitem" href="../currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_06/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_06/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Statistics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">5: Type system and generic programming</a></li><li class="is-active"><a href>Abstract and composit types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Abstract and composit types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_05/compositetypes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h1><p>In Julia, abstract types cannot be instantiated and are used to create a logical hierarchy of types. This can be seen in the hierarchy of numeric types introduced in the first lecture.</p><p><img src="../types.svg" alt/></p><p>All types depicted in blue are abstract types. Note that Julia provides a variety of concrete types of numeric values. Although they have different representation sizes, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code>, and <code>Int128</code> all have in common that they are signed integer types. Likewise, <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code>, and <code>UInt128</code> are all unsigned integer types, while <code>Float16</code>, <code>Float32</code>, and <code>Float64</code> are distinct in being floating-point types rather than integers. It is common for a piece of code to make sense, for example, only if its arguments are some integer, but not depend on what particular kind of integer. For example, the greatest common denominator algorithm works for all kinds of integers but will not work for floating-point numbers. Abstract types allow the construction of a hierarchy of types, providing a context into which concrete types can fit.</p><p>Abstract types can be defined using the <code>abstract type</code> keyword followed by the type&#39;s name. Optionally, it is possible to specify that the type is a subtype of another existing abstract type. For example, the hierarchy of numeric types presented above can be defined as follows.</p><pre><code class="language-julia">abstract type Number end
abstract type Real &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type AbstractIrrational &lt;: Real end
abstract type Integer &lt;: Real end
abstract type Signed &lt;: Integer end
abstract type Unsigned &lt;: Integer end</code></pre><p>When no supertype is given, the default supertype is <code>Any</code>, i.e., in our example, the <code>Number</code> type is a subtype of <code>Any</code>. The <code>Any</code> type is sometimes called the <em>top</em> type since all types are its subtypes. In Julia, there is also the <em>bottom</em> type <code>Union{}</code>.  It is the exact opposite of the <code>Any</code> type since no object is an instance of <code>Union{}</code> and all types are supertypes of <code>Union{}</code>.</p><p>The <code>&lt;:</code> operator can be used in expressions as a subtype operator that returns <code>true</code> when its left operand is a subtype of its right operand.</p><pre><code class="language-julia-repl">julia&gt; Signed &lt;: Integer
true

julia&gt; Signed &lt;: Number
true

julia&gt; Signed &lt;: AbstractFloat
false</code></pre><p>Julia also provides the <code>isa</code> function, which can be used to test if the given variable is an instance of some type or subtype of some abstract type.</p><pre><code class="language-julia-repl">julia&gt; isa(1, Int64) # equivalent to typeof(1) &lt;: Int64
true

julia&gt; isa(1, Integer) # equivalent to typeof(1) &lt;: Integer
true

julia&gt; isa(1, AbstractFloat) # equivalent to typeof(1) &lt;: AbstractFloat
false</code></pre><p>Another handy function is the <code>isabstracttype</code> function that checks whether the given type is abstract or not.</p><pre><code class="language-julia-repl">julia&gt; isabstracttype(Real)
true

julia&gt; isabstracttype(Float64)
false</code></pre><p>Similarly, the <code>isconcretetype</code> function checks whether the given type is concrete or not.</p><pre><code class="language-julia-repl">julia&gt; isconcretetype(Real)
false

julia&gt; isconcretetype(Float64)
true</code></pre><h1 id="Composite-types"><a class="docs-heading-anchor" href="#Composite-types">Composite types</a><a id="Composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-types" title="Permalink"></a></h1><p>A composite type is a collection of pairs of keys and values, and its instance of which can be treated as a single value. In many languages, composite types are the only kind of user-definable type. In Julia, it is possible to define also other types (primitive types, for example). However, composite types are by far the most used.</p><p>In object-oriented languages, such as Python or Java, composite types also have named functions associated with them, and the combination is called an <em>object</em>.  In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of function to use by multiple-dispatch. It means that the types of all of a function&#39;s arguments are considered when selecting a method, rather than just the first one. Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial language design aspect.</p><p>Composite types can be defined using the <code>struct</code> keyword followed by the type name and field names that can be optionally annotated with types.</p><pre><code class="language-julia">struct Foo
    a
    b::Int
end</code></pre><p>Note that if the type annotation of the field is omitted,  the <code>Any</code> type is used by default, i.e., such a field can contain any value. Also, note that there is a convention in Julia that the first letter of each word in custom type names is in uppercase. We can create a new instance of the above type by calling <code>Foo</code> as a function with input arguments representing fields of the <code>Foo</code> type.</p><pre><code class="language-julia-repl">julia&gt; foo = Foo([1,2,3], 4)
Foo([1, 2, 3], 4)

julia&gt; isa(foo, Foo)
true</code></pre><p>When a type is applied like a function, it is called a constructor. By default, two constructors are generated automatically. One accepts any arguments and calls convert to convert them to the fields&#39; types, and the other accepts arguments that match the field&#39;s types exactly. If all fields are of type <code>Any</code> (or we do not specify their types), the later constructor is not generated.  We can list all constructors using the <code>methods</code> function.</p><pre><code class="language-julia-repl">julia&gt; methods(Foo)
# 2 methods for type constructor:
[1] Foo(a, b::Int64) in Main at none:2
[2] Foo(a, b) in Main at none:2</code></pre><p>By default, Julia generates these two constructors because it makes it easier to add new definitions without inadvertently replacing a default constructor.</p><p>The fields of composite types can be accessed via dot notation similarly to named tuples.</p><pre><code class="language-julia-repl">julia&gt; foo.a
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; foo.b
4</code></pre><p>Internally <code>foo.a</code> is just a shortcut for the <code>getproperty(foo, :a)</code>.</p><pre><code class="language-julia-repl">julia&gt; getproperty(foo, :a)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; getproperty(foo, :b)
4</code></pre><p>There is also a convenient function, <code>fieldnames</code>, that returns a tuple with names of all fields of a given composite type. Note that all field names are represented as symbols.</p><pre><code class="language-julia-repl">julia&gt; fieldnames(Foo)
(:a, :b)</code></pre><p>Composite types declared with <code>struct</code> are immutable, i.e., they cannot be modified after construction.</p><pre><code class="language-julia-repl">julia&gt; foo.a = 1
ERROR: setfield! immutable struct of type Foo cannot be changed</code></pre><p>Composite types declared with <code>struct</code> are immutable, i.e., they cannot be modified after construction.</p><p>However, immutability is not recursive. It means that if an immutable object contains a mutable object (such as an array), we can modify elements of the mutable object. We can observe this behavior in the following example. The <code>Foo</code> type is defined as immutable, but we instantiate the <code>foo</code> object with a vector as a first argument. Since a vector is mutable, we can modify its elements.</p><pre><code class="language-julia-repl">julia&gt; foo.a[1] = 5
5

julia&gt; foo.a
3-element Array{Int64,1}:
 5
 2
 3</code></pre><p>Mutable composite types can be declared in a similar way as immutable ones. The only difference is that we have to add the <code>mutable</code> keyword before the <code>struct</code> keyword.</p><pre><code class="language-julia">mutable struct MutableFoo
    a
    b::Int
end</code></pre><p>Instances of mutable types are created in the same way as in the case of immutable ones.</p><pre><code class="language-julia-repl">julia&gt; mfoo = MutableFoo([1,2,3], 4)
MutableFoo([1, 2, 3], 4)

julia&gt; isa(mfoo, MutableFoo)
true</code></pre><p>There are two ways how to change fields of mutable types. The first one is to use the <code>setproperty!</code> function. The second one is to use the shorthand dot syntax to access the field and the <code>=</code> operator to assign a new value.</p><pre><code class="language-julia-repl">julia&gt; mfoo.a = 2.345
2.345

julia&gt; setproperty!(mfoo, :a, 2)
2

julia&gt; mfoo
MutableFoo(2, 4)</code></pre><p>Note that the syntax <code>mfoo.a = 2.345</code> is equivalent to <code>setproperty!(mfoo, :a, 2.345)</code>.</p><div class = "info-body">
<header class = "info-header">Type unions</header><p><p>A type union is a special abstract type that includes all instances of any of its argument types. Type unions can be constructed using the <code>Union</code> keyword.</p><pre><code class="language-julia-repl">julia&gt; AbstractFoo = Union{Foo, MutableFoo}
Union{Foo, MutableFoo}

julia&gt; Foo &lt;: AbstractFoo
true

julia&gt; MutableFoo &lt;: AbstractFoo
true</code></pre><p>The <code>Union</code> type can be very useful in many cases. For example, if there is no supertype for multiple types, but we want to write a specialized function that can be used for all of them. In such a case, we can use the type <code>Union</code> and write one function with type annotation to all of them at once.</p><pre><code class="language-julia-repl">julia&gt; geta(foo::AbstractFoo) = foo.a
geta (generic function with 1 method)

julia&gt; geta(foo) == foo.a
true

julia&gt; geta(mfoo) == mfoo.a
true</code></pre></p></div><h2 id="Parametric-types"><a class="docs-heading-anchor" href="#Parametric-types">Parametric types</a><a id="Parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-types" title="Permalink"></a></h2><p>An important and powerful feature of Julia&#39;s type system is that it is parametric: types can take parameters. It means that type declaration actually introduces a whole family of new types (one for each possible combination of parameter values). Parametric abstract and composite types can be defined as follows.</p><pre><code class="language-julia">abstract type AbstractPoint{T} end

struct Point{T &lt;: Real} &lt;: AbstractPoint{T}
    x::T
    y::T
end</code></pre><p>In the example above, we defined one parametric abstract type, <code>AbstractPoint</code>, and its parametric subtype <code>Point</code>. The declaration of the concrete type <code>Point{T &lt;: Real}</code> has two fields of type <code>T</code>, where <code>T</code> can be any subtype of <code>Real</code>. This definition ensures that both fields are always of the same type. Note that <code>Point{Float64}</code> is a concrete type equivalent to the type defined by replacing <code>T</code> in the definition of <code>Point</code> with <code>Float64</code>.</p><pre><code class="language-julia-repl">julia&gt; isconcretetype(Point{Float64})
true

julia&gt; isconcretetype(Point{Int64})
true</code></pre><p>Thus, this single declaration actually declares concrete type for each subtype <code>T</code> of <code>Real</code>.  The <code>Point</code> type itself is also a valid type object, containing all instances <code>Point{Float64}</code>, <code>Point{Int64}</code>, etc., as subtypes.</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point &lt;: AbstractPoint
true

julia&gt; Point{Int64} &lt;: Point &lt;: AbstractPoint
true</code></pre><p>However, concrete <code>Point{T}</code> types with different <code>T</code> values are never subtypes of each other. Even though <code>Float64</code> is a subtype of <code>Real</code>, the <code>Point{Float64}</code> is not a subtype of  <code>Point{Real}</code>.</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point{Real}
false

julia&gt; Point{Float64} &lt;: AbstractPoint{Float64}
true

julia&gt; Point{Float64} &lt;: AbstractPoint{Real}
false</code></pre><p>This behavior is for practical reasons: while any instance of <code>Point{Float64}</code> may conceptually be like an instance of <code>Point{Real}</code> as well, the two types have different representations in memory:</p><ul><li>An instance of <code>Point{Float64}</code> can be represented compactly and efficiently as an immediate pair of 64-bit values.</li><li>An instance of <code>Point{Real}</code> must be able to hold any pair of instances of <code>Real</code>. Since objects that are instances of <code>Real</code> can be of arbitrary size and structure, in practice, an instance of <code>Point{Real}</code> must be represented as a pair of pointers to individually allocated <code>Real</code> objects.</li></ul><p>The efficiency gained by being able to store <code>Point{Float64}</code> objects with immediate values is magnified enormously in the case of arrays: an <code>Array{Float64}</code> can be stored as a contiguous memory block of 64-bit floating-point values, whereas an <code>Array{Real}</code> must be an array of pointers to individually allocated <code>Real</code> objects - which may well be boxed 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the <code>Real</code> abstract type.</p><p>Since <code>Point{Float64}</code> is not a subtype of <code>Point{Real}</code>, the following method can&#39;t be applied to arguments of type <code>Point{Float64}</code>.</p><pre><code class="language-julia">julia&gt; coordinates(p::Point{Real}) = (p.x, p.y)

julia&gt; coordinates(Point(1,2))
ERROR: MethodError: no method matching coordinates(::Point{Int64})
[...]

julia&gt; coordinates(Point(1.0,2.0))
ERROR: MethodError: no method matching coordinates(::Point{Float64})
[...]</code></pre><p>A correct way to define a method that accepts all arguments of type <code>Point{T}</code> where <code>T</code> is a subtype of <code>Real</code> is as follows.</p><pre><code class="language-julia-repl">julia&gt; coordinates(p::Point{&lt;:Real}) = (p.x, p.y)
coordinates (generic function with 1 method)

julia&gt; coordinates(Point(1,2))
(1, 2)

julia&gt; coordinates(Point(1.0,2.0))
(1.0, 2.0)</code></pre><p>Or simply use the <code>Point</code> type without specified parameter. It is also possible to define a function for all subtypes of some abstract type.</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, p::AbstractPoint) = print(io, coordinates(p))

julia&gt; Point(4, 2)
(4, 2)

julia&gt; Point(0.2, 1.3)
(0.2, 1.3)</code></pre><p>There are two ways how to instantiate the <code>Point</code> type.  The first way is to create an instance of <code>Point{T}</code> without specifying the <code>T</code> parameter and letting Julia decide which type should be used.  The second way is to specify the <code>T</code> parameter manually.</p><pre><code class="language-julia-repl">julia&gt; Point(1, 2)
(1, 2)

julia&gt; Point{Float32}(1, 2)
(1.0f0, 2.0f0)</code></pre><p>Note that the default constructors work only if we use arguments with the same type or if we specify the <code>T</code> parameter manually. In all other cases, an error will occur.</p><pre><code class="language-julia-repl">julia&gt; Point(1, 2.0)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T&lt;:Real at none:3</code></pre><p>This situation can be handled by defining custom constructors, as discussed in the next section.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Define a structure that represents 3D-point. Do not forget to define it as a subtype of the AbstractPoint type. Also, add a new method to the <code>coordinates</code> function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Since we did not specify what the structure should look like, there are several possibilities for defining it. For example, we can define it as a structure with three fields as in the code below. Another option is to use, for example, a tuple to store the point coordinates.</p><pre><code class="language-julia">struct Point3D{T &lt;: Real} &lt;: AbstractPoint{T}
    x::T
    y::T
    z::T
end

coordinates(p::Point3D) = (p.x, p.y, p.z)</code></pre><p>Note that since the <code>show</code> function was defined for the abstract type <code>AbstractPoint</code> and uses the <code>coordinates</code> function, the custom print is immediately applied to the new type.</p><pre><code class="language-julia-repl">julia&gt; Point3D(1, 2, 3)
(1, 2, 3)

julia&gt; Point3D{Float32}(1, 2, 3)
(1.0f0, 2.0f0, 3.0f0)</code></pre></p></details><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>Constructors are functions that create new instances of composite types. When the user defines a new composite type,  Julia creates default constructors. However, sometimes it is very useful to add additional constructors. As an example, we can mention the case from the end of the previous section. In this case, it makes sense to have the ability to create an instance of the <code>Point</code> type from two numbers that can be of any subtypes of <code>Real</code>. This can be achieved by defining the following constructor.</p><pre><code class="language-julia">Point(x::Real, y::Real) = Point(promote(x, y)...)</code></pre><p>Note that we use the <code>promote</code> function. This function converts its arguments to the type that can safely represent their types. For example, if we call <code>promote(1, 2.3)</code> the result will be a tuple <code>(1.0, 2.3)</code> because it is possible to represent <code>Int64</code> using <code>Float64</code> (not precisely), but it is not possible to represent <code>Float64</code> using <code>Int64</code>. We can test the new constructor on the example from the end of the previous section.</p><pre><code class="language-julia-repl">julia&gt; Point(1, 2.0)
(1.0, 2.0)

julia&gt; typeof(Point(1, 2.0))
Point{Float64}</code></pre><p>As expected, the result is of type <code>Point{Float64}</code>. The constructor defined above is called an outer constructor because it is defined outside the type definition. A constructor is just like any other function in Julia, i.e., its methods&#39; combined behavior defines its overall behavior. Accordingly, you can add functionality to a constructor by defining new methods.</p><p>Outer constructors can be used to provide additional convenience methods for constructing objects. However, they can not be used to constructing self-referential objects or if we want to ensure that the resulting instance has some special properties. In such a case, we have to use inner constructors.  An inner constructor method is like an outer constructor method, except for two differences.</p><ol><li>It is declared inside the block of a type declaration rather than outside of it like normal methods.</li><li>It has access to a special locally existent function called <code>new</code> that creates objects of the block&#39;s type.</li></ol><p>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this.</p><pre><code class="language-julia">struct OrderedPair{T &lt;: Real}
    x::Real
    y::Real

    function OrderedPair(x::Real, y::Real)
        x &gt; y &amp;&amp; error(&quot;out of order&quot;)
        xp, yp = promote(x, y)
        return new{typeof(xp)}(xp, yp)
    end
end</code></pre><p>If the user defines any inner constructor method, <strong>no additional constructor method is defined by default</strong>.  The example above means that any instance of the <code>OrderedPair</code> has to meet the assumption that <code>x &lt;= y</code>.</p><pre><code class="language-julia-repl">julia&gt; OrderedPair(1,2)
OrderedPair{Int64}(1, 2)

julia&gt; OrderedPair(2,1)
ERROR: out of order
[...]</code></pre><p>Moreover, outer constructor methods can only create objects by calling other constructor methods, i.e., some inner constructor must be called to create an object. It means that even if we add any number of outer constructors, the resulting object is created by the inner constructor and therefore has to meet its assumptions.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Define a structure that represents ND-point and stores coordinates as <code>NTuple</code> type. Do not forget to define it as a subtype of the <code>AbstractPoint</code> type. Also, add a new method to the <code>coordinates</code> function. Redefine the default inner constructor to create an instance of the <code>PointND</code> directly from different types&#39; values.</p><p><strong>Hint:</strong> use the <code>new</code> function in the definition of the new inner constructor.</p><p><strong>Hint:</strong> in the <code>NTuple{N, T}</code> type, <code>N</code> represents a number of elements and <code>T</code> their type. Use similar notation in the definition of the <code>PointND</code> to specify a dimension.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>In this case, we can use an inner constructor with the optional number of input arguments. In the definition below, we use type annotation to set these arguments to be real numbers. Since we use the <code>new</code> function and our type is parametric, we have to specify <code>N</code> and type <code>T</code>.</p><pre><code class="language-julia">struct PointND{N, T &lt;: Real} &lt;: AbstractPoint{T}
    x::NTuple{N, T}

    function PointND(args::Real...)
        vals = promote(args...)
        return new{length(args), eltype(vals)}(vals)
    end
end

coordinates(p::PointND) = p.x</code></pre><p>Note that since the <code>show</code> function was defined for the abstract type <code>AbstractPoint</code> and uses the <code>coordinates</code> function, the custom print is immediately applied to the new type. Also note, that since we redefined the default constructors, we can create an instance of the <code>PointND</code> type from inputs of mixed types.</p><pre><code class="language-julia-repl">julia&gt; PointND(1, 2)
(1, 2)

julia&gt; PointND(1, 2.2, 3, 4.5)
(1.0, 2.2, 3.0, 4.5)</code></pre></p></details><h2 id="Default-field-values"><a class="docs-heading-anchor" href="#Default-field-values">Default field values</a><a id="Default-field-values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-field-values" title="Permalink"></a></h2><p>In many cases, it is beneficial to define custom types with default field values. This can be achieved by defining a constructor that uses optional or keyword arguments. Another option is to use the <code>@kwdef</code> macro from the <code>Base</code>. This macro automatically defines a keyword-based constructor.</p><pre><code class="language-julia">Base.@kwdef struct MyType
    a::Int # required keyword
    b::Float64 = 2.3
    c::String = &quot;hello&quot;
end</code></pre><p>We can use the <code>methods</code> function to check which constructors have been created. As can be seen, there are three constructors.  The first constructor is the one created by the <code>@kwdef</code> macro. The latter two are the default constructors created since we did not provide any inner constructor.</p><pre><code class="language-julia-repl">julia&gt; methods(MyType)
# 3 methods for type constructor:
[1] MyType(; a, b, c) in Main at util.jl:438
[2] MyType(a::Int64, b::Float64, c::String) in Main at none:2
[3] MyType(a, b, c) in Main at none:2</code></pre><p>The instance of the <code>MyType</code> type can be created using the default constructors as follows.</p><pre><code class="language-julia-repl">julia&gt; MyType(1, 2.3, &quot;aaa&quot;)
MyType(1, 2.3, &quot;aaa&quot;)</code></pre><p>The other way is to use the constructor with predefined field values. In such a case, all values have to be passed as keyword arguments. The fields without default values are mandatory keyword arguments, i.e., we have to specify them.</p><pre><code class="language-julia-repl">julia&gt; MyType(; a = 3)
MyType(3, 2.3, &quot;hello&quot;)

julia&gt; MyType(; a = 5, b = 4.5)
MyType(5, 4.5, &quot;hello&quot;)</code></pre><div class = "info-body">
<header class = "info-header">Function-like objects</header><p><p>Methods are associated with types, so it is possible to make any arbitrary Julia object &quot;callable&quot; by adding methods to its type. Such &quot;callable&quot; objects are sometimes called &quot;functors.&quot; Using this technique to the <code>MyType</code> defined above, we can define a method that returns all field&#39;s values as a tuple.</p><pre><code class="language-julia-repl">julia&gt; (m::MyType)() = (m.a, m.b, m.c)

julia&gt; m = MyType(; a = 5, b = 4.5)
MyType(5, 4.5, &quot;hello&quot;)

julia&gt; m()
(5, 4.5, &quot;hello&quot;)</code></pre><p>Moreover, we can use multiple-dispatch to define other methods. The first method for a given real number computes a simple linear and uses fields <code>a</code>, <code>b</code> of the <code>MyType</code> as slope and intercept. The second method creates a string from the given string and a field <code>c</code> of the <code>MyType</code>.</p><pre><code class="language-julia">(m::MyType)(x::Real) = m.a*x + m.b
(m::MyType)(x::String) = &quot;$(m.c), $(x)&quot;</code></pre><p>If we use these two methods and the instance of the <code>MyType</code> defined in the example above,  we get the following results.</p><pre><code class="language-julia-repl">julia&gt; m(1)
9.5

julia&gt; m(&quot;world&quot;)
&quot;hello, world&quot;</code></pre></p></div><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a structure <code>Gauss</code> that will represent a <a href="https://en.wikipedia.org/wiki/Normal_distribution">Gaussian distribution</a>. Write an inner constructor that checks if the given parameters are correct. Initialization without arguments <code>Gauss()</code> should return the standardized normal distribution (<span>$\mu = 0$</span> and <span>$\sigma = 1$</span>).  Define a functor that computes the probability density function in the given point. Recall that the probability density function for the Gaussian distribution is defined as follows.</p><p class="math-container">\[f_{\mu, \sigma}(x) = \frac{1}{\sigma \sqrt{ 2\pi }} \exp\left\{ -\frac{1}{2} \left( \frac{x - \mu}{\sigma} \right) ^2 \right\},\]</p><p>where <span>$\mu \in \mathbb{R}$</span> and <span>$\sigma^2 &gt; 0$</span>. Verify that the probability density function is defined correctly, i.e., its integral equals 1. Create a plot of the probability density function.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>One of the possible ways how to define structure from the description of the exercise is the following. We use the <code>@kwdef</code> macro to define the default values of the parameters. We also defined an inner constructor that checks if the variance is positive.</p><pre><code class="language-julia">Base.@kwdef struct Gauss{T&lt;:Real}
    μ::T = 0
    σ::T = 1

    function Gauss(μ::Real, σ::Real)
        σ &gt; 0 || error(&quot;the variance `σ^2` must be positive&quot;)
        pars = promote(μ, σ)
        return new{eltype(pars)}(pars...)
    end
end</code></pre><p>Note that in the inner constructor, we use the <code>promote</code> function and that we specify the parameter <code>T</code> in the call of the <code>new</code> function. The probability density function can be defined as a functor in the following way.</p><pre><code class="language-julia">(d::Gauss)(x::Real) = exp(-1/2 * ((x - d.μ)/d.σ)^2)/(d.σ * sqrt(2*π))</code></pre><p>We used type annotation to ensure that all input arguments are real numbers.</p><pre><code class="language-julia-repl">julia&gt; gauss = Gauss()
Gauss{Int64}(0, 1)

julia&gt; gauss(0)
0.3989422804014327</code></pre><p>The integral of the probability density function over all real numbers should equal one. We can check it numerically by discretizing the integral into a finite sum.</p><pre><code class="language-julia-repl">julia&gt; step = 0.01
0.01

julia&gt; x = -100:step:100;

julia&gt; sum(Gauss(), x) * step
1.0000000000000002

julia&gt; sum(Gauss(0.1, 2.3), x) * step
1.0</code></pre><p>We use the <code>sum</code> function, which can accept a function as the first argument and apply it to each value before summation. Since we defined a functor for the <code>Gauss</code> type, we can pass its instance as the fits argument, and the result will be the same as if we use <code>sum(Gauss().(x))</code>. The difference is that the former, similarly to generators, does not allocate an array.</p><p>We can also visualize the probability density functions with the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> package. Unfortunately, we cannot use the syntax for the plotting function described in the <a href="../../lecture_04/Plots/#Function-plotting">Function plotting</a> section, i.e., the following will not work even though the <code>Gauss</code> type is callable.</p><pre><code class="language-julia">plot(x, Gauss())</code></pre><p>However, we can define a custom plot for our type using the <code>@recipe</code> macro. The syntax is straightforward. In the function head, we define two inputs: our type and some input <code>x</code>. Then in the function body, we define plot attributes in the same way as if we pass them in the <code>plot</code> function. Finally, we define the output of the function. Note that we use two different syntaxes for defining plot attributes. If we use <code>:=</code> operator, the attribute will be set to the provided value and can not be changed by the user. On the other hand, if we use <code>--&gt;</code> operator, the provided value is used as default and can be changed by the user.</p><pre><code class="language-julia">using Plots

@recipe function f(d::Gauss, x)
    seriestype := :path
    label --&gt; &quot;Gauss(μ = $(d.μ), σ = $(d.σ))&quot;
    xguide --&gt; &quot;x&quot;
    yguide --&gt; &quot;f(x)&quot;
    linewidth --&gt; 2
    return x, d.(x)
end</code></pre><p>The recipe above is equivalent to calling the <code>plot</code> function as follows.</p><pre><code class="language-julia">d = Gauss()
plot(x, d.(x);
    seriestype := :path,
    label = &quot;Gauss(μ = $(d.μ), σ = $(d.σ))&quot;,
    xguide = &quot;x&quot;,
    yguide --&gt; &quot;f(x)&quot;,
    linewidth --&gt; 2
)</code></pre><p>With the new plot recipe, we can plot the probability density function of Gaussian distribution with different parameters in a simple way.</p><pre><code class="language-julia">using Plots
x = -15:0.1:15

plot(Gauss(), x)
plot!(Gauss(4, 2), x)
plot!(Gauss(-3, 2), x)</code></pre><p><img src="../gauss.svg" alt/></p></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_04/interaction/">« Interaction with other languages</a><a class="docs-footer-nextpage" href="../currencies/">Generic programming »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 14 March 2021 21:08">Sunday 14 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
