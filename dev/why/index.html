<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Why Julia? · Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/julia/">Julia</a></li><li><a class="tocitem" href="../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../installation/git/">Git</a></li><li><a class="tocitem" href="../installation/tutorial/">Quick Start Guide</a></li></ul></li><li class="is-active"><a class="tocitem" href>Why Julia?</a><ul class="internal"><li><a class="tocitem" href="#Intuitive-and-flexible-syntax"><span>Intuitive and flexible syntax</span></a></li><li><a class="tocitem" href="#Type-system-and-Multiple-Dispatch"><span>Type system and Multiple-Dispatch</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Disadvantages"><span>Disadvantages</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../lecture_01/operators/">Elementary Functions</a></li><li><a class="tocitem" href="../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../lecture_01/data_structures/">Data Structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_02/conditions/">Conditional Evaluation</a></li><li><a class="tocitem" href="../lecture_02/loops/">Loops and Iterators</a></li><li><a class="tocitem" href="../lecture_02/scope/">Soft Local Scope</a></li><li><a class="tocitem" href="../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_04/basics/">Package Management</a></li><li><a class="tocitem" href="../lecture_04/standardlibrary/">Standard Library</a></li><li><a class="tocitem" href="../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../lecture_04/otherpackages/">Other Useful Packages</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><span class="tocitem">Final Project</span></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Statistics</span></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Why Julia?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Why Julia?</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/why.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Why-julia?"><a class="docs-heading-anchor" href="#Why-julia?">Why julia?</a><a id="Why-julia?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-julia?" title="Permalink"></a></h1><p>There are a lot of established programming languages like Python, Matlab, R, or C. So when a new language is introduced, it is natural to ask, why should I learn this new language? What are the advantages and disadvantages of this language? In this section, we will try to introduce the major advantages and disadvantages of Julia and compare Julia to Python, Matlab, R, or C.</p><h2 id="Intuitive-and-flexible-syntax"><a class="docs-heading-anchor" href="#Intuitive-and-flexible-syntax">Intuitive and flexible syntax</a><a id="Intuitive-and-flexible-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Intuitive-and-flexible-syntax" title="Permalink"></a></h2><p>Julia provides very intuitive and yet flexible syntax, that allows users to write relatively complicated functions in a simple and readable way. As an example, we can compare the definition of the function that computes the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a> in different languages. In Matlab, the naive implementation of such function is as follows</p><pre><code class="language-matlab">function f = fib(n)
    if n &lt; 2
        f = n;
    else
        f = fib(n-1) + fib(n-2);
    end
end</code></pre><p>Note that we do not check if the input argument is a non-negative integer. Using the Python, we get the following implementation</p><pre><code class="language-python">def fib(n):
    if n&lt;2:
        return n
    return fib(n-1) + fib(n-2)</code></pre><p>and if we use the C language the function definition is following</p><pre><code class="language-c">int fib(int n) {
    return n &lt; 2 ? n : fib(n-1) + fib(n-2);
}</code></pre><p>We see that all three implementations are very different. Surprisingly, the implementation in C is the shortest one. The reason is, that in C it is possible to use the <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a>. In Matlab, it is possible to write the <code>if-else</code> statement on one line, however, it will decrease the code readability. Implementation of the Fibonacci function in Julia is the following</p><pre><code class="language-julia">fib(n::Int) = n &lt; 2 ? n : fib(n-1) + fib(n-2)</code></pre><p>But it is also possible to use traditional multiline function declaration syntax</p><pre><code class="language-julia">function fib(n::Int)
    if n &lt; 2
        return n
    else
        return fib(n-1) + fib(n-2)
    end
end</code></pre><p>Note that annotation of the input argument type and use of the <code>return</code> keyword is optional and can be omitted. What we can see it, that Julia supports different syntax for defining functions. It is very useful because it is possible to write simple functions on one line and use a multiline syntax for more complicated functions. Additionally, the authors of Julia took inspiration from other languages and the result is, that Julia provides many handy features known from other languages. For example:</p><ul><li>The syntax of matrix operations are inspired by the one in Matlab.</li><li>Statistical packages use similar syntax to the packages in R.</li><li>It is possible to use list comprehensions and generators like in Python.</li></ul><h2 id="Type-system-and-Multiple-Dispatch"><a class="docs-heading-anchor" href="#Type-system-and-Multiple-Dispatch">Type system and Multiple-Dispatch</a><a id="Type-system-and-Multiple-Dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Type-system-and-Multiple-Dispatch" title="Permalink"></a></h2><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p>One of the most obvious advantages of Julia is its speed. Since Julia uses just-in-time compilation it is possible to achieve the performance of C without using any special tricks or packages. It can be seen in the following figure which shows speed comparison of various languages in multiple micro-benchmarks. The full description of these micro-benchmarks can be found on the official <a href="https://julialang.org/benchmarks/">Julia Micro-Benchmarks</a> webpage.</p><p>These micro-benchmarks test performance on a range of common code patterns, such as function calls, string parsing, sorting, numerical loops, random number generation, recursion, and array operations. It is important to say that the used benchmark codes are not optimized for maximal performance. Instead, the benchmarks are written to test the performance of identical algorithms and code patterns implemented in each language. In the following figure, we can see the computational time increase against the C language for several benchmark functions.</p><p><img src="../benchmarks.svg" alt/></p><p>It is fair to say, that in many cases it is possible to improve the performance of other languages using simple tricks. For example, the performance of Python can be improved using Numba, an open-source JIT compiler that translates a subset of Python and NumPy into fast machine code using <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> compiler. Since both Numba and Julia use the same compiler, it is interesting to compare the performance of Julia and Python+Numba.</p><p>For the comparison consider the following example of estimating <span>$\pi$</span> using Monte Carlo sampling originally posted <a href="https://blakeaw.github.io/2019-09-20-numba-vs-julia/">here</a>. A naive implementation of such estimation in pure Python 3.8.5 (using NumPy for the random number generator) is as follows</p><pre><code class="language-python">import numpy as np

def estimate_pi(n):
    n_circle = 0
    for i in range(n):
        x = 2*np.random.random() - 1
        y = 2*np.random.random() - 1
        if np.sqrt(x**2 + y**2) &lt;= 1:
           n_circle += 1
    return 4*n_circle/n</code></pre><p>In order to track the computational time, we use the <a href="https://ipython.org/">IPython 7.13.0</a> command shell in combination with the <code>timeit</code> package as follows</p><pre><code class="language-python">In [2]: import timeit
   ...: n = 10000000

In [3]: %timeit estimate_pi(n)
18.3 s ± 990 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><p>We see that the average computation time is <strong>19.3</strong> seconds, which is a lot. The reason is, that <code>for</code> loops in Python are slow. One way how to improve the performance is to use NumPy vectorized operations (it is a similar approach used often in Matlab to improve performance). The vectorized version of the function above can be written as follows</p><pre><code class="language-python">def estimate_pi_vec(n):
    xy = 2*np.random.random((n, 2)) - 1
    n_circle = (np.sqrt((xy**2).sum(axis = 1)) &lt;= 1).sum()
    return 4*n_circle/n</code></pre><p>Using the same function to track the computational time, we get <strong>354</strong> milliseconds as can be seen below</p><pre><code class="language-python">In [5]: %timeit estimate_pi_vec(n)
354 ms ± 21.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><p>The vectorized version is 50 times faster than the pure Python implementation using the <code>for</code> loop. However, it requires rewriting the code and in many cases, it can be very difficult or even impossible to vectorize the code. Another approach is to use the Numba package mentioned above. The Numba package is very easy to use. In our case, we only need to add one line of code before the function definition</p><pre><code class="language-python">import numba

@numba.jit()
def estimate_pi_numba(n):
    n_circle = 0
    for i in range(n):
        x = 2*np.random.random() - 1
        y = 2*np.random.random() - 1
        if np.sqrt(x**2 + y**2) &lt;= 1:
           n_circle += 1
    return 4*n_circle/n</code></pre><p>The result, in this case, is quite impressive and the average computational time is only <strong>109</strong> milliseconds as can be seen below</p><pre><code class="language-python">In [7]: %timeit estimate_pi_numba(n)
109 ms ± 2.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><p>The resulting code is more than 150 times faster than the pure Python implementation. The question is, how fast is Julia? To answer this question, we use the exact same function definition as in the case of the pure Python implementation.</p><pre><code class="language-julia">function estimate_pi(n)
    n_circle = 0
    for i in 1:n
        x = 2*rand() - 1
        y = 2*rand() - 1
        if sqrt(x^2 + y^2) &lt;= 1
           n_circle += 1
        end
    end
    return 4*n_circle/n
end</code></pre><p>In Julia, we can use the <code>BenchmarkTools</code> package that allows simple benchmarking of the code. To track the computational time we use <code>@benchmark</code> macro as follows</p><pre><code class="language-julia">julia&gt; using BenchmarkTools

julia&gt; n = 10000000
10000000

julia&gt; @benchmark estimate_pi(n)
BenchmarkTools.Trial:
  memory estimate:  16 bytes
  allocs estimate:  1
  --------------
  minimum time:     86.532 ms (0.00% GC)
  median time:      93.298 ms (0.00% GC)
  mean time:        95.266 ms (0.00% GC)
  maximum time:     112.988 ms (0.00% GC)
  --------------
  samples:          53
  evals/sample:     1</code></pre><p>We see that the average computation time is <strong>95.266</strong> seconds. Without any modifications, Julia&#39;s code is faster than the Python implementation that uses Numba. The performance gap is not large. However, the Numba package will work only on a small subset of Python and NumPy functionalities. Of course, there are other packages that can be used to increase performance such as Cython. But all these packages have the same problem as Numba and will not support all Python functionalities. The reason is, that Python was not designed to be compiled and thus there are many limitations that can not be solved. On the other hand, Julia was designed to be fast and provides high-performance out of the box without the necessity to do any additional steps. Moreover, the performance in Julia is not restricted only to the subset of the Language as in the case of Numba and other similar packages.</p><h2 id="Disadvantages"><a class="docs-heading-anchor" href="#Disadvantages">Disadvantages</a><a id="Disadvantages-1"></a><a class="docs-heading-anchor-permalink" href="#Disadvantages" title="Permalink"></a></h2><p>There is no language that is perfect for all tasks. In most cases, the choice of the language is a matter of subjective preferences. To be as objective as possible we provide a list of disadvantages of Julia</p><ul><li><p><strong>A limited number of packages:</strong> Even though Julia grows rapidly and there are a large number of packages, it can not be compared to the number of available packages in Python or R. However, Julia provides a simple way how to interact with other languages. So if there is no adequate package in Julia, it is possible to use packages from other languages.</p></li><li><p><strong>Slow first run:</strong> Since Julia uses just-in-time compilation, the first call of every function is slower due to compilation. This slowdown can be significant if multiple functions are called for the first time at once. Such a case is creating a plot in a fresh Julia session because packages for plotting are large and use a lot of functions.  It results in a long time to the first plot (~20 s with <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>).</p></li><li><p><strong>Limited number of job opportunities:</strong> Because Julia is a relatively new language, there is a limited number of job opportunities, especially compared to Python. On the other hand, there is a list of Julia users and Julia Computing customers on the official webpage of <a href="https://juliacomputing.com/">Julia Computing</a> containing for example Amazon, Google, IBM, Intel and many others.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/tutorial/">« Quick Start Guide</a><a class="docs-footer-nextpage" href="../lecture_01/variables/">Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 February 2021 18:45">Monday 8 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
