<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Why Julia? · Julia for Optimization and Learning</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/ctustyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Julia for Optimization and Learning logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Julia for Optimization and Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia for Optimization and Learning</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Why Julia?</a><ul class="internal"><li><a class="tocitem" href="#Intuitive-and-flexible-syntax"><span>Intuitive and flexible syntax</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/vscode/">Julia + Visual Studio Code</a></li><li><a class="tocitem" href="../installation/git/">Git</a></li><li><a class="tocitem" href="../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../lecture_01/strings/">Strings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Data structures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_02/arrays/">Arrays</a></li><li><a class="tocitem" href="../lecture_02/tuples/">Tuples and named tuples</a></li><li><a class="tocitem" href="../lecture_02/dictionaries/">Dictionaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_03/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../lecture_03/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../lecture_03/scope/">Soft local scope</a></li><li><a class="tocitem" href="../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_04/functions/">Functions</a></li><li><a class="tocitem" href="../lecture_04/methods/">Methods</a></li><li><a class="tocitem" href="../lecture_04/scope/">Scope of variables</a></li><li><a class="tocitem" href="../lecture_04/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../lecture_04/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_05/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../lecture_05/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../lecture_05/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../lecture_05/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../lecture_05/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_06/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../lecture_06/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_07/modules/">Files and modules</a></li><li><a class="tocitem" href="../lecture_07/pkg/">Package manager</a></li><li><a class="tocitem" href="../lecture_07/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_08/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../lecture_08/gradients/">Gradients</a></li><li><a class="tocitem" href="../lecture_08/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../lecture_08/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_09/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../lecture_09/linear/">Linear regression</a></li><li><a class="tocitem" href="../lecture_09/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../lecture_10/nn/">Neural networks</a></li><li><a class="tocitem" href="../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">11: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_11/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../lecture_11/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../lecture_11/nn/">More complex networks</a></li><li><a class="tocitem" href="../lecture_11/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">12: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_12/sparse/">Linear regression with sparse constraints</a></li><li><a class="tocitem" href="../lecture_12/monte/">Monte Carlo sampling</a></li><li><a class="tocitem" href="../lecture_12/glm/">Linear regression revisited</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">13: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture_13/theory/">Differential equations</a></li><li><a class="tocitem" href="../lecture_13/ode/">Wave equation</a></li><li><a class="tocitem" href="../lecture_13/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../lecture_13/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Why Julia?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Why Julia?</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Julia-for-Optimization-and-Learning/blob/master/docs/src/why.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Why-julia?"><a class="docs-heading-anchor" href="#Why-julia?">Why julia?</a><a id="Why-julia?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-julia?" title="Permalink"></a></h1><p>There are many established programming languages like Python, Matlab, R, or C. When a new language is introduced, the natural question is why I should learn this new language. What are the advantages and disadvantages of this language? This section introduces significant advantages and disadvantages of Julia and compares it to Python, Matlab, R, and C.</p><div class="admonition is-success"><header class="admonition-header">Advantages:</header><div class="admonition-body"><ul><li><strong>Intuitive and flexible syntax:</strong> Julia was designed to be easy to use and powerful at the same time. Julia provides a very intuitive syntax and supports many useful concepts from other languages such as generators from Python. More details and examples are provided in the separate section below.</li><li><strong>Performance:</strong> Since Julia is a compiled language, code in Julia is generally faster than code written in pure Python or Matlab. More details and examples are provided in the separate section below.</li><li><strong>Type system:</strong> Like Matlab or Python, it is not necessary to use type annotations for variable or function input arguments. However, since everything in Julia has its own type, it is possible to use type annotation. This allows the compiler to optimize the code, and it can also prevent mistakes.</li><li><strong>Multiple dispatch:</strong> Julia multiple dispatch means that one functions consist of multiple methods which may differ in the number of input arguments or their type. When a function is called, the most specific method definition matching the number and argument types is executed. This allows defining general functions such as <code>convert</code> for all conversion operations, instead of using specific function names like <code>str2double</code> typically used in Matlab.</li></ul></div></div><p>To be as objective as possible, we provide a list of Julia disadvantages.</p><div class="admonition is-category-theorem"><header class="admonition-header">Disadvantages:</header><div class="admonition-body"><ul><li><strong>A limited number of packages:</strong> Even though Julia grows rapidly and there are many packages, it can not compete with the number of available packages in Python or R. However, Julia provides a simple way of interacting with other languages. If there is no adequate package in Julia, it is possible to use packages from other languages.</li><li><strong>Slow first run:</strong> Since Julia uses just-in-time compilation, the first call of every function is slower due to compilation. This slowdown can be significant if multiple functions are called for the first time. This includes creating a plot in a new Julia session because packages for plotting are large and use many functions. It results in a long time to the first plot (~20 s with <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>).</li><li><strong>Limited number of job opportunities:</strong> Because Julia is a relatively new language, there is a limited number of job opportunities, especially compared to Python. On the other hand, there is a list of Julia users and Julia Computing customers on the official webpage of <a href="https://juliacomputing.com/">Julia Computing</a> including Amazon, Google, IBM, Intel and many others.</li></ul></div></div><h2 id="Intuitive-and-flexible-syntax"><a class="docs-heading-anchor" href="#Intuitive-and-flexible-syntax">Intuitive and flexible syntax</a><a id="Intuitive-and-flexible-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Intuitive-and-flexible-syntax" title="Permalink"></a></h2><p>Julia provides very intuitive and yet flexible syntax, which allows users to write relatively complicated functions in a simple and readable way. As an example, we can compare the definition of the function that computes the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a>. A naive Matlab implementation of this function would be:</p><pre><code class="language-matlab hljs">function f = fib(n)
    if n &lt; 2
        f = n;
    else
        f = fib(n-1) + fib(n-2);
    end
end</code></pre><p>We do not check whether the input argument is a non-negative integer for simplicity. Python would result in the following implementation:</p><pre><code class="language-python hljs">def fib(n):
    return n if n&lt;2 else fib(n-1) + fib(n-2)</code></pre><p>Finally, an implementation in C would be close to:</p><pre><code class="language-c hljs">int fib(int n) {
    return n &lt; 2 ? n : fib(n-1) + fib(n-2);
}</code></pre><p>We see that these three implementations are very different. Surprisingly, the implementation in C is the shortest one on par with python. The reason is that C allows using the <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a>. Even though Matlab allows to write the <code>if-else</code> statement on one line, this would decrease the code readability. Julia can implement this function in a simple way.</p><pre><code class="language-julia hljs">fib(n::Int) = n &lt; 2 ? n : fib(n-1) + fib(n-2)</code></pre><p>At the same time, it is possible to use traditional multiline function declaration syntax.</p><pre><code class="language-julia hljs">function fib(n::Int)
    if n &lt; 2
        return n
    else
        return fib(n-1) + fib(n-2)
    end
end</code></pre><p>The annotation of the input argument type and the <code>return</code> keyword are optional and can be both omitted. Julia, therefore, supports different syntax for defining functions. This is very useful because it is possible to write simple functions on one line or use a multiline syntax for more complicated functions. Additionally, Julia authors took inspiration from other languages, and Julia provides many handy features known from other languages:</p><ul><li>The syntax of matrix operations is inspired by Matlab.</li><li>Statistical packages use similar syntax to R packages.</li><li>It is possible to use list comprehensions and generators like in Python.</li></ul><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p>One of the most obvious advantages of Julia is its speed. Since Julia uses just-in-time compilation, it is possible to achieve the performance of C without using any special tricks or packages. It can be seen in the following figure, which shows a speed comparison of various languages for multiple micro-benchmarks. A full description of these micro-benchmarks can be found on the official <a href="https://julialang.org/benchmarks/">Julia Micro-Benchmarks</a> webpage.</p><p>These micro-benchmarks test performance on a range of common code patterns, such as function calls, string parsing, sorting, numerical loops, random number generation, recursion, or array operations. It is important to say that the used benchmark codes are not optimized for maximal performance. Instead, the benchmarks are written to test the performance of identical algorithms and code patterns implemented in each language. The following figure shows a computational time increase against the C language for several benchmark functions. The time on the <span>$y$</span> axis is logarithmic.</p><p><img src="../benchmarks.svg" alt/></p><p>It is fair to say that sometimes other languages can use simple tricks to improve their performance. For example, the performance of Python can be enhanced by Numba: an open-source JIT compiler that translates a subset of Python and NumPy into fast machine code using the <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> compiler. Since both Numba and Julia use the same compiler, it is interesting to compare the performance of Julia and Python+Numba.</p><p>For the comparison consider the following example of estimating <span>$\pi$</span> using the Monte Carlo sampling originally posted <a href="https://blakeaw.github.io/2019-09-20-numba-vs-julia/">here</a>. A naive implementation of such estimation in pure Python 3.8.5 (using NumPy for the random number generator) is as follows:</p><pre><code class="language-python hljs">import numpy as np

def estimate_pi(n):
    n_circle = 0
    for i in range(n):
        x = 2*np.random.random() - 1
        y = 2*np.random.random() - 1
        if np.sqrt(x**2 + y**2) &lt;= 1:
           n_circle += 1
    return 4*n_circle/n</code></pre><p>To track the computational time, we use the <a href="https://ipython.org/">IPython 7.13.0</a> command shell in combination with the <code>timeit</code> package.</p><pre><code class="language-python hljs">In [2]: import timeit
   ...: n = 10000000

In [3]: %timeit estimate_pi(n)
18.3 s ± 990 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><p>The average computation time is <strong>18.3</strong> seconds, which is a lot. The reason is that <code>for</code> loops in Python (and Matlab) are slow. One way to improve the performance is to use NumPy vectorized operations (it is a similar approach used often in Matlab to improve performance).</p><pre><code class="language-python hljs">def estimate_pi_vec(n):
    xy = 2*np.random.random((n, 2)) - 1
    n_circle = (np.sqrt((xy**2).sum(axis = 1)) &lt;= 1).sum()
    return 4*n_circle/n</code></pre><pre><code class="language-python hljs">In [5]: %timeit estimate_pi_vec(n)
354 ms ± 21.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><p>We use the same function to track the computational time, which amounts to <strong>354</strong> milliseconds. The vectorized version is 50 times faster than the pure Python implementation using the <code>for</code> loop. However, it requires rewriting the code and in many cases, which can often be very difficult or even impossible. Another approach is to use the Numba package mentioned above. The Numba package is straightforward to use by including one additional line of code before the function definition.</p><pre><code class="language-python hljs">import numba

@numba.jit()
def estimate_pi_numba(n):
    n_circle = 0
    for i in range(n):
        x = 2*np.random.random() - 1
        y = 2*np.random.random() - 1
        if np.sqrt(x**2 + y**2) &lt;= 1:
           n_circle += 1
    return 4*n_circle/n</code></pre><pre><code class="language-python hljs">In [7]: %timeit estimate_pi_numba(n)
109 ms ± 2.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><p>The result is quite impressive and the average computational time is only <strong>109</strong> milliseconds, which is more than 150 times faster than the pure Python implementation. However, Numba is not guaranteed to speed all computations.</p><p>How fast is Julia? To answer this question, we use the same function definition as in the pure Python implementation.</p><pre><code class="language-julia hljs">function estimate_pi(n)
    n_circle = 0
    for i in 1:n
        x = 2*rand() - 1
        y = 2*rand() - 1
        if sqrt(x^2 + y^2) &lt;= 1
           n_circle += 1
        end
    end
    return 4*n_circle/n
end</code></pre><p>In Julia, we can use the <code>BenchmarkTools</code> package that allows simple benchmarking of the code. To track the computational time we use <code>@benchmark</code> macro.</p><pre><code class="language-julia hljs">julia&gt; using BenchmarkTools

julia&gt; n = 10000000
10000000

julia&gt; @benchmark estimate_pi(n)
BenchmarkTools.Trial: 56 samples with 1 evaluation.
 Range (min … max):  86.735 ms … 94.346 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     89.119 ms              ┊ GC (median):    0.00%
 Time  (mean ± σ):   89.358 ms ±  1.659 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

                 ▁   ▃   █                                     
  ▄▁▄▇▁▇▇▁▁▄▄▄▄▄▄█▄▄▁█▄▄▁█▇▇▄▁▁▁▄▄▁▁▇▇▁▇▁▇▄▁▄▁▁▁▁▄▄▁▇▁▁▁▁▄▄▁▄ ▁
  86.7 ms         Histogram: frequency by time        92.7 ms &lt;

 Memory estimate: 16 bytes, allocs estimate: 1.</code></pre><p>We see that the average computation time is <strong>89</strong> milliseconds. Without any modifications, the Julia code is slightly faster than the Python implementation with Numba. Even though the performance gap is not large, the Numba package will only work on a small Python and NumPy functionalities subset. Of course, other packages such as Cython can be used to increase performance. But all these packages have the same problem as Numba and will not support all Python functionalities. Python was not designed to be compiled, which results in many limitations that can not be easily solved. On the other hand, Julia was designed to be fast and provide high-performance without taking any additional steps. Moreover, Julia performance is not restricted to a subset of the language as in the case of Numba and other similar packages.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../installation/vscode/">Julia + Visual Studio Code »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 15 February 2023 09:03">Wednesday 15 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
