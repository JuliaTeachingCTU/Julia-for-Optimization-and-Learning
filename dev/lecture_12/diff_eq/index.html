<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia package · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quick Start Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary Functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data Structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional Evaluation</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and Iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft Local Scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/basics/">Package Management</a></li><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard Library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other Useful Packages</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Statistics</span></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox" checked/><label class="tocitem" for="menuitem-14"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../theory/">Differential equations</a></li><li><a class="tocitem" href="../ode/">Wave equation</a></li><li class="is-active"><a class="tocitem" href>Julia package</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Lorenz-system"><span>Lorenz system</span></a></li></ul></li><li><a class="tocitem" href="../optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">12: Ordinary differential equations</a></li><li class="is-active"><a href>Julia package</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia package</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_12/diff_eq.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-package"><a class="docs-heading-anchor" href="#Julia-package">Julia package</a><a id="Julia-package-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-package" title="Permalink"></a></h1><p>To solve differential equations, we will use package <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations</a>.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>DifferentialEquations consider ODEs in the form</p><p class="math-container">\[\dot u(t) = f(t, u(t), p(t))\]</p><p>with the initial condition <span>$u(t_0)= u_0$</span>. While <span>$u$</span> is the solution, <span>$p$</span> described external parameters.</p><p>We will start with a simple problem</p><p class="math-container">\[\dot u(t) = 0.98u\]</p><p>with initial condition <span>$u(0) = 1$</span>. This has closed-form solution <span>$u(t) = e^{0.98t}$</span>. To solve this ODE by <code>DifferentialEquations</code>, we first need to create the problem <code>prob</code> by supplying function <span>$f$</span>, the initial point <span>$u_0$</span> and the time interval <span>$[t_0,t_1]$</span> to the constructor <code>ODEProblem</code></p><pre><code class="language-julia">using DifferentialEquations

f(u,p,t) = 0.98*u

u0 = 1.0
tspan = (0.0, 1.0)

prob = ODEProblem(f, u0, tspan)</code></pre><p>We can solve the ODE by</p><pre><code class="language-julia">sol = solve(prob)</code></pre><pre class="documenter-example-output">retcode: Success
Interpolation: automatic order switching interpolation
t: 5-element Array{Float64,1}:
 0.0
 0.10042494449239292
 0.35218603951893646
 0.6934436028208104
 1.0
u: 5-element Array{Float64,1}:
 1.0
 1.1034222047865465
 1.4121908848175448
 1.9730384275622996
 2.664456142481451</pre><p>The first line specifies that the solution was successful. We can automatically check whether the solution was successful by <code>sol.retcode == :Success</code>. The second line specifies the interpolation method. Even though the solution was evaluated at only 5 points <code>sol.t</code> with values <code>sol.u</code>, the interpolation </p><pre><code class="language-julia">using Plots

plot(sol)</code></pre><p><img src="../intro.svg" alt/></p><p>The <code>sol</code> structure is heavily overloaded. It can be used to evaluate the solution <span>$u$</span> at any time</p><pre><code class="language-julia">sol(0.8)</code></pre><pre class="documenter-example-output">2.1902158127997695</pre><p>The next exercise shows how to specify the interpolation technique and compares the resutlts.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>When calling the <code>solve</code> function, we can specify the interpolation way. Solve the ODE with linear interpolation (<code>dense=false</code>) and the Runge-Kutta method of fourth order (<code>RK4()</code>). Plot the results and compare them with the default and original solutions.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>To compues the additional solutions, we add the arguments as specified above</p><pre><code class="language-julia">sol2 = solve(prob, dense=false)
sol3 = solve(prob, RK4())</code></pre><p>For plotting, we create a discretization <code>ts</code> of the time interval and then plot the four functions</p><pre><code class="language-julia">ts = collect(range(tspan[1], tspan[2], length=100))

plot(ts, t-&gt;exp(0.98*t), label=&quot;True solution&quot;, legend=:topleft)
plot!(ts, t-&gt;sol(t), label=&quot;Default&quot;)
plot!(ts, t-&gt;sol2(t), label=&quot;Linear&quot;)
plot!(ts, t-&gt;sol3(t), label=&quot;Runge-Kutta&quot;)</code></pre></p></details><p><img src="../Comparison.svg" alt/></p><p>We see that all solutions are the same with the exception of the linear approximation.</p><h2 id="Lorenz-system"><a class="docs-heading-anchor" href="#Lorenz-system">Lorenz system</a><a id="Lorenz-system-1"></a><a class="docs-heading-anchor-permalink" href="#Lorenz-system" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Lorenz_system">Lorenz system</a> is a prime example of the <a href="https://en.wikipedia.org/wiki/Butterfly_effect">butterfly effect</a> in the chaos theory. There, a small changes in the initial conditions results in large changes after a long time. This effect was first described in 1961 during work on weather modelling.</p><p>The three-dimensional Lorenz system is described by the set of equations </p><p class="math-container">\[\begin{aligned}
\frac{\partial x}{\partial t} &amp;= \sigma (y - x), \\
\frac{\partial y}{\partial t} &amp;= x (\rho - z) - y, \\
\frac{\partial z}{\partial t} &amp;= x y - \beta z.
\end{aligned}\]</p><p>We define the right-hand side</p><pre><code class="language-julia">function lorenz(u, p, t)
    σ, ρ, β = p
    x_t = σ*(u[2]-u[1])
    y_t = u[1]*(ρ-u[3]) - u[2]
    z_t = u[1]*u[2] - β*u[3]
    return [x_t; y_t; z_t]
end</code></pre><p>The parameters are saved in a tuple or array <code>p</code>. Since the right-hand side of the Lorenz system is a vector, we need to return a vector as well. Now, we compute the solution in the same way as before.</p><pre><code class="language-julia">u0 = [1.0; 0.0; 0.0]
p = [10; 28; 8/3]

tspan = (0.0, 100.0)
prob = ODEProblem(lorenz, u0, tspan, p)

sol = solve(prob)</code></pre><p>Using the same function to plot</p><pre><code class="language-julia">plot(sol)</code></pre><p><img src="../lorenz0.svg" alt/></p><p>results in two-dimensional graph of all coorinates. To plot 3D, we need to specify it</p><pre><code class="language-julia">plt1 = plot(sol, vars=(1,2,3), label=&quot;&quot;)</code></pre><p><img src="../lorenz1.svg" alt/></p><p>We see again the power of interpolation. If we used linear interpolation (connected the points)</p><pre><code class="language-julia">plot(sol, vars=(1,2,3), denseplot=false; label=&quot;&quot;)</code></pre><p><img src="../lorenz2.svg" alt/></p><p>we would obtain a much coarse graph. This shows the strength of the <code>DifferentialEquations</code> package. With a small computational effort, it is able to compute a good solution. Note that the last plotting call is equivalent to</p><pre><code class="language-julia">traj = hcat(sol.u...)
plot(traj[1,:], traj[2,:], traj[3,:]; label=&quot;&quot;)</code></pre><p>In the introduction to this part, we mentioned the chaos theory. We will elaborate on this in the next exercise.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Consider the same setting as above but perturb the first parameter of <code>p</code> by the smallest possible value (with respect to the machine precision). Then solve the Lorenz system again and compare results by plotting the two trajectories next to each other.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The machine precision can be obtained by <code>eps(T)</code>, where <code>T</code> is the desired type. However, when we add this to <code>p[1]</code>, we obtain the same number</p><pre><code class="language-julia">p[1] + eps(eltype(p)) == p[1]</code></pre><pre class="documenter-example-output">true</pre><p>The reason is that <code>p[1]</code> has value 10 and the sum exceeds the allowed number of valid digits and it is truncated back to 10. We therefore cheat a bit and manually modify the number</p><pre><code class="language-julia">p0 = (10.000000000000001,28,8/3)</code></pre><p>Then we plot the graphs as before</p><pre><code class="language-julia">prob0 = ODEProblem(lorenz, u0, tspan, p0)
sol0 = solve(prob0)

plt0 = plot(sol0, vars=(1,2,3), label=&quot;&quot;)

plot(plt1, plt0; layout=(1,2))</code></pre></p></details><p><img src="../lorenz4.svg" alt/></p><p>The solutions look obviously different. Comparing the terminal states of both solutions</p><pre><code class="language-julia">hcat(sol(tspan[2]), sol0(tspan[2]))</code></pre><pre class="documenter-example-output">3×2 Array{Float64,2}:
 -2.94542  -0.628467
 -1.84189  -3.10333
 22.7963   23.3035</pre><p>shows that they are different by a large margin. This raises a natural question.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Can we trust the solutions? Why?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Unfortunately, we cannot. Numerical methods always introduce some errors by</p><ul><li><em>Rounding errors</em> due to representing real numbers in machine precision.</li><li><em>Discretization errors</em> for continuous systems when the derivative is approximated by some kind of finite difference.</li></ul><p>However, if the system itself is unstable in the way that an extremely small perturbation results in big differences in solutions, the numerical method even enhances these errors. The solution could be trusted on some small interval but not after it.</p></p></details><p>The next section will show a situation where we try to mitigate this possible effect by using mathematical formulas to compute the exact solution as long as possible. This delays the necessary discretization and may bring a better stability.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ode/">« Wave equation</a><a class="docs-footer-nextpage" href="../optimal_control/">Optimal control »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 29 January 2021 20:51">Friday 29 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
