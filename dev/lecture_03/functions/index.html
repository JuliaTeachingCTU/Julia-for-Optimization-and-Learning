<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why_julia/">Why Julia?</a></li><li><a class="tocitem" href="../../howto/">How to...</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Mathematical operations and Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluation</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#One-line-functions"><span>One-line functions</span></a></li><li><a class="tocitem" href="#Optional-arguments"><span>Optional arguments</span></a></li><li><a class="tocitem" href="#Keyword-arguments"><span>Keyword arguments</span></a></li><li><a class="tocitem" href="#Variable-number-of-arguments"><span>Variable number of arguments</span></a></li><li><a class="tocitem" href="#Anonymous-functions"><span>Anonymous functions</span></a></li><li><a class="tocitem" href="#Dot-Syntax-for-Vectorizing-Functions"><span>Dot Syntax for Vectorizing Functions</span></a></li><li><a class="tocitem" href="#Function-composition-and-piping"><span>Function composition and piping</span></a></li></ul></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../scope/">Scope of Variables</a></li><li><a class="tocitem" href="../exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Useful packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/packages/">Packages</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Theory of optimization</a></li><li><a class="tocitem" href="../../lecture_07/gradients/">Visualization of gradients</a></li><li><a class="tocitem" href="../../lecture_07/numerical_methods/">Numerical methods</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">10: Neural networks II.</span></li><li><span class="tocitem">11: Ordinary differential equations</span></li><li><span class="tocitem">12: Statistics I.</span></li><li><span class="tocitem">13: Statistics II.</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Functions and methods</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_03/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><p>In Julia, a function is an object that maps a tuple of argument values to a return value. There are multiple ways how to create a function and each of them is useful in different situations. The first way is to use <code>function ... end</code> syntax</p><pre><code class="language-julia">function plus(x,y)
    x + y
end</code></pre><p>In the previous example, we created a function <code>plus</code> that accepts two arguments <code>x</code>, <code>y</code> and returns their sum.</p><pre><code class="language-julia-repl">julia&gt; plus(2, 3)
5

julia&gt; plus(2, -3)
-1</code></pre><p>By default, the function in Julia returns the last evaluated expression, which in our example is <code>x + y</code>. However, in many situations, it is useful to return something other than the last expression. For such a case there is an <code>return</code> keyword. The previous example can be equivalently rewritten as follows</p><pre><code class="language-julia">function plus(x,y)
    return x + y
end</code></pre><p>Even though both function definitions do exactly the same, it is a good practice to always use <code>return</code> keyword. Using the <code>return</code> keyword usually improves the readability of the code and can prevent potential confusion.</p><pre><code class="language-julia">function plus(x, y)
    return x + y
    println(&quot;I am a useless line of code!!&quot;)
end</code></pre><p>We can see, that there is println function used on the last line in the previous example. However, if the function is called, nothing is printed into the REPL</p><pre><code class="language-julia-repl">julia&gt; plus(4, 5)
9

julia&gt; plus(3, -5)
-2</code></pre><p>The reason is, that the expressions after the <code>return</code> keyword are never evaluated</p><p>It is also possible to return multiple values at once. This can be done by simply writing multiple comma-separated values after the <code>return</code> keyword (or on the last line when <code>return</code> is not used)</p><pre><code class="language-julia">function powers(x)
    return x, x^2, x^3, x^4
end</code></pre><p>In fact, this syntax creates a tuple of values and then this tuple is returned as a function output. It can be seen, if we call the <code>powers</code> function that returns the first four powers of the given <code>x</code></p><pre><code class="language-julia-repl">julia&gt; ps = powers(2)
(2, 4, 8, 16)

julia&gt; typeof(ps)
NTuple{4,Int64}</code></pre><p>Since the function returns a tuple, returned values can be directly unpacked into multiple variables. It can be done in the same way as unpacking <a href="../../lecture_01/data_structures/#Tuples">tuples</a></p><pre><code class="language-julia-repl">julia&gt; x1, x2, x3, x4 = powers(2)
(2, 4, 8, 16)

julia&gt; x3
8</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a function that for a given real number <span>$x$</span> and integer <span>$p$</span> computes <span>$x^p$</span> without using the <code>^</code> operator. You can use only basic arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>if</code> condition.</p><p><strong>Hint:</strong> use recursion.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>To use recursion, we have to split the computation into three parts:</p><ul><li><span>$p = 0$</span>: the function should return <code>1</code>.</li><li><span>$p &gt; 0$</span>: the function should be called recursively with arguments <span>$x$</span>, <span>$p - 1$</span> and the result should be multiplied by <span>$x$</span>.</li><li><span>$p &lt; 0$</span>: then it is equivalent to call the power function with arguments <span>$1/x$</span>, <span>$- p$</span>.</li></ul><p>These three cases can be defined simply using one <code>if</code> condition as follows</p><pre><code class="language-julia">function power(x::Real, p::Integer)
    if p == 0
        return 1
    elseif p &gt; 0
        return x * power(x, p - 1)
    else
        return power(1/x, - p)
    end
end</code></pre><p>Note, that we use type annotation for function arguments. In this case, it will assure, that the first argument is always a real number and the second argument is always an integer.</p><pre><code class="language-julia-repl">julia&gt; power(2, 5)
32

julia&gt; power(2, -2)
0.25

julia&gt; power(2, 5) == 2^5
true

julia&gt; power(5, -3) == 5^(-3)
true</code></pre><p>If we call the function with arguments of inappropriate types, an error will occur</p><pre><code class="language-julia-repl">julia&gt; power(2, 2.5)
ERROR: MethodError: no method matching power(::Int64, ::Float64)
Closest candidates are:
  power(::Real, !Matched::Integer) at none:1</code></pre><p>We will discuss the type annotation later in the section about <a href="../methods/#Methods">multiple-dispatch</a>.</p></p></details><h2 id="One-line-functions"><a class="docs-heading-anchor" href="#One-line-functions">One-line functions</a><a id="One-line-functions-1"></a><a class="docs-heading-anchor-permalink" href="#One-line-functions" title="Permalink"></a></h2><p>Besides the traditional function declaration syntax above, it is possible to define a function in a compact one-line form</p><pre><code class="language-julia">plus(x, y) = x + y</code></pre><p>that is equivalent to the previous definition of <code>plus</code> function</p><pre><code class="language-julia-repl">julia&gt; plus(4, 5)
9

julia&gt; plus(3, -5)
-2</code></pre><p>This syntax is very similar to the mathematical notation especially in combination with the greek alphabet. For example the following function</p><p class="math-container">\[f(\varphi) = - 4 \cdot \sin\left(\varphi - \frac{\pi}{12}\right)\]</p><p>can be in Julia defined in almost identical form</p><pre><code class="language-julia">f(φ) = -4sin(φ - π/12)</code></pre><p>Even with one-line syntax, it is possible to create more complex functions with some intermediate calculations. It can be done, using brackets and semicolons to separate expressions. The last expression in brackets is then returned  as a function output</p><pre><code class="language-julia">g(x) = (x -= 1; x *= 2; x)</code></pre><p>In this example, the <code>g</code> function subtracts <code>1</code> from the given <code>x</code> and then multiply the result by <code>2</code></p><pre><code class="language-julia-repl">julia&gt; g(3)
4</code></pre><p>However, for better code readability, the traditional multiline syntax should be used for more complex functions.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a one-line function, that returns true if the input argument is an odd number and false otherwise</p><p><strong>Hint:</strong> use modulo function and <a href="../../lecture_02/conditions/#Ternary-operator">ternary operator</a> <code>?</code> (for more info, use help for symbol <code>?</code>).</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>In help, we can find the syntax for the ternary operator</p><pre><code class="language-julia">a ? b : c</code></pre><p>This expression can be read as follows: <em>if <code>a</code> is true, evaluate <code>b</code> otherwise evaluate <code>c</code></em>. We also know that even numbers are divisible by 2 and we can check it using the modulo, i.e. the given integer <code>x</code> is even if <code>mod(x, 2) == 0</code>.  Altogether, we get the following function definition</p><pre><code class="language-julia">even(x::Integer) = mod(x, 2) == 0 ? true : false</code></pre><p>Note, that we use type annotation to assure, that the argument is always an integer.</p><pre><code class="language-julia-repl">julia&gt; even(11)
false

julia&gt; even(14)
true</code></pre></p></details><h2 id="Optional-arguments"><a class="docs-heading-anchor" href="#Optional-arguments">Optional arguments</a><a id="Optional-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-arguments" title="Permalink"></a></h2><p>Another very useful thing is optional arguments. Similarly to python, optional arguments can be created by assigning a default value to the normal argument. The following function has only one argument, which is optional with a default value <code>world</code></p><pre><code class="language-julia">hello(x = &quot;world&quot;) = println(&quot;Hello $(x).&quot;)</code></pre><p>Since the only argument is optional, we can call the function without any argument. In such a case, the function prints <code>&quot;Hello $(x).&quot;</code>, where <code>x</code> is replaced by the default value</p><pre><code class="language-julia-repl">julia&gt; hello()
Hello world.</code></pre><p>If we call the function with the argument, it will change the printed sentence</p><pre><code class="language-julia-repl">julia&gt; hello(&quot;people&quot;)
Hello people.</code></pre><p>In the same way, it is possible to define multiple optional arguments. It is even possible to define optional arguments, that depend on other arguments</p><pre><code class="language-julia">powers(x, y = x*x, z = y*x, v = z*x) = x, y, z, v</code></pre><p>This function has one mandatory argument and three optional ones. If only the first argument <code>s</code> is provided, then the function returns the first four powers of the given <code>x</code></p><pre><code class="language-julia-repl">julia&gt; powers(2)
(2, 4, 8, 16)</code></pre><p>Otherwise, the function output depends on the given input arguments. For example, if two arguments <code>x</code> and <code>y</code> are provided, the function returns these two arguments unchanged, their product <code>x*y</code> and also <code>x^2*y</code></p><pre><code class="language-julia-repl">julia&gt; powers(2, 3)
(2, 3, 6, 12)</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a function, that computes the value of the following quadratic form</p><p class="math-container">\[q_{a,b,c}(x) = ax^2 + bxy + cy^2\]</p><p>where <span>$a, b, c, x \in \mathbb{R}$</span>. Use optional arguments to set default values for parameters</p><p class="math-container">\[a = 1 \quad b = 2a \quad c = 3(a + b).\]</p><p>What is the function value at point <span>$(4, 2)$</span> for default parameters? What is the function value at the same point, if we use <span>$c = 3$</span>?</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The quadratic form can be implemented as follows</p><pre><code class="language-julia">q(x, y, a = 1, b = 2*a, c = 3*(a + b)) = a*x^2 + b*x*y + c*y^2</code></pre><p>Since we want to evaluate the function <code>q</code> at point <code>(4, 2)</code> with default parameters, we can simply use only first two arguments</p><pre><code class="language-julia-repl">julia&gt; q(4, 2)
68</code></pre><p>However, it is not possible to set only the last optional argument. We have to also set all previous optional arguments too. For the first two optional arguments, we use the default values, i.e. <code>a = 1</code> and <code>b = 2*a = 2</code>.</p><pre><code class="language-julia-repl">julia&gt; q(4, 2, 1, 2, 3)
44</code></pre></p></details><h2 id="Keyword-arguments"><a class="docs-heading-anchor" href="#Keyword-arguments">Keyword arguments</a><a id="Keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-arguments" title="Permalink"></a></h2><p>The exercise from the previous section shows the biggest disadvantage of using optional arguments, i.e. it is not possible to change only one optional argument unless it is the first one. Luckily there are also keyword arguments, that can be used instead of optional arguments. The syntax is exactly the same as for optional arguments with one exception: we have to use a semicolon before the first keyword argument</p><pre><code class="language-julia">linear(x; a = 1, b = 0) = a*x + b</code></pre><p>This function is a simple linear function, where <code>a</code> parameter is called slope and <code>b</code> parameter is called intercept. As with functions with optional arguments, we can call the function only with the mandatory arguments</p><pre><code class="language-julia-repl">julia&gt; linear(2)
2</code></pre><p>or we can change the value of any keyword argument by assigning a new value to its name</p><pre><code class="language-julia-repl">julia&gt; linear(2; a = 2)
4

julia&gt; linear(2; b = 4)
6

julia&gt; linear(2; a = 2, b = 4)
8</code></pre><p>Note that the semicolon, in this case, is not mandatory and can be omitted. Also, the order of keyword arguments can be arbitrary as can be seen i the following example</p><pre><code class="language-julia-repl">julia&gt; linear(2, b = 4, a = 2)
8</code></pre><p>It is even possible to mix keyword arguments with positional arguments</p><pre><code class="language-julia-repl">julia&gt; linear(a = 2, 2, b = 4)
8</code></pre><p>However, it&#39;s a good practice to always separate keyword arguments from optional arguments with a semicolon.</p><p>Julia also provides one very nice feature, that can be used to pass keyword arguments. Imagine, that we have two variable <code>a</code>, <code>b</code>, that represents the keyword arguments of the <code>linear</code> function. The standard way how to pass these arguments to the function is the following</p><pre><code class="language-julia-repl">julia&gt; a, b = 2, 4
(2, 4)

julia&gt; linear(2; a = a, b = b)
8</code></pre><p>However, in Julia, we can use the shorter version, that can be used if the variable name is the same as the name of the keyword argument we want to set</p><pre><code class="language-julia-repl">julia&gt; linear(2; a, b)
8</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a probability density function for the Gaussian distribution, that is given by the following formula</p><p class="math-container">\[f_{\mu, \sigma}(x) = \frac{1}{\sigma \sqrt{ 2\pi }} \exp\left\{ -\frac{1}{2} \left( \frac{x - \mu}{\sigma} \right) ^2 \right\},\]</p><p>where <span>$\mu \in \mathbb{R}$</span> and <span>$\sigma^2 &gt; 0$</span>. Use keyword arguments to set the default values <span>$\mu = 0$</span> and <span>$\sigma = 1$</span>.</p><p><strong>Bonus:</strong> check that this function is really a probability density function</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The probability density function for the <a href="https://en.wikipedia.org/wiki/Normal_distribution#General_normal_distribution">Gaussian distribution</a> can be simply written as follows</p><pre><code class="language-julia">function f(x::Real; μ::Real = 0, σ::Real = 1)
    σ^2 == 0 &amp;&amp; error(&quot;the variance `σ^2` must be nonzero&quot;)
    return exp(-1/2 * ((x - μ)/σ)^2)/(σ * sqrt(2*π))
end</code></pre><p>Note, that we use type annotation to  assure, that all input arguments will be real numbers and we also check whether the given arguments do not lead to a zero variance (the first line in the function body).</p><pre><code class="language-julia-repl">julia&gt; f(0)
0.3989422804014327

julia&gt; f(0.1; μ = 1, σ = 1)
0.2660852498987548</code></pre><p>We know, that the integral over all real numbers from the probability density function should be equal to one. We can check it numerically as follows</p><pre><code class="language-julia-repl">julia&gt; x = -100:0.1:100;

julia&gt; sum(f, x) * 0.1
1.0

julia&gt; g(x) = f(x; μ = -1, σ = 1.4)
g (generic function with 1 method)

julia&gt; sum(g, x) * 0.1
1.0000000000000002</code></pre><p>We use the sum function, which can accept a function as a first argument a then this function is applied to each value before summation. The result is always multiplied by <code>0.1</code>. It is because we use a range with stepsize <code>0.1</code>  to approximate continuous interval <code>[-100, 100]</code>.</p><p>Finally, we can use the following code to visualize the probability density functions</p><pre><code class="language-julia">using Plots

x = -15:0.1:15

plot(x, f.(x); label = &quot;μ = 0, σ = 1&quot;, linewidth = 2, xlabel = &quot;x&quot;, ylabel = &quot;f(x)&quot;);
plot!(x, f.(x; μ = 4, σ = 2); label = &quot;μ = 4, σ = 2&quot;, linewidth = 2);
plot!(x, f.(x; μ = -3, σ = 2); label = &quot;μ = -3, σ = 2&quot;, linewidth = 2);</code></pre><pre class="documenter-example-output">/home/runner/.julia/packages/GR/RlE5Y/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</pre><p>We use a lot of things that will be discussed later in the course. So for now, just enjoy a nice picture of the Gaussian probability density functions</p><p><img src="../gauss.svg" alt/></p></p></details><h2 id="Variable-number-of-arguments"><a class="docs-heading-anchor" href="#Variable-number-of-arguments">Variable number of arguments</a><a id="Variable-number-of-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-number-of-arguments" title="Permalink"></a></h2><p>Sometimes, it is very convenient to be able to define a function, that can accept any number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. In Julia, varargs functions can be defined using triple-dot syntax after the last positional argument as follows</p><pre><code class="language-julia">foo(x...) = x</code></pre><p>The <code>foo</code> function defined above, accepts any number of input arguments, wraps them in a tuple a returns them</p><pre><code class="language-julia-repl">julia&gt; foo()
()

julia&gt; foo(1, 2, &quot;a&quot;, :b, [1,2,3])
(1, 2, &quot;a&quot;, :b, [1, 2, 3])</code></pre><p>The following example is more useful. In that example, we define <code>basicinfo</code> function, that accepts any number of input arguments and then prints basic information like the number of given arguments, their sum, mean and standard deviation.</p><pre><code class="language-julia">using Statistics

function basicinfo(x...)
    println(&quot;&quot;&quot;
      - number of arguments: $(length(x))
      - sum: $(round(sum(x); digits = 2))
      - mean: $(round(mean(x); digits = 2))
      - std: $(round(std(x); digits = 2))
    &quot;&quot;&quot;)
    return
end</code></pre><p>Note, that we have to use package <code>Statistics</code>, since functions <code>mean</code> and <code>std</code> are not part of standard packages, that are loaded in every Julia session.</p><pre><code class="language-julia-repl">julia&gt; basicinfo(0.158, 1.889, 1.246, 4.569)
  - number of arguments: 4
  - sum: 7.86
  - mean: 1.97
  - std: 1.88


julia&gt; basicinfo(0.158, 1.889, 1.246, 4.569, 5.189, -4.123)
  - number of arguments: 6
  - sum: 8.93
  - mean: 1.49
  - std: 3.37</code></pre><p>A similar syntax for a variable number of positional arguments can be used for keyword arguments as well. Functions that accept any number of keyword arguments can be very useful. Such functions can be used for example</p><pre><code class="language-julia">shiftedsum(x; a = 1, kwargs...) = sum(x .- a; kwargs...)</code></pre><p>Here we define a function, that subtracts <code>a</code> from each element of the given input array <code>x</code> and then sums this array. This function also pass all given keyword arguments to the <code>sum</code> function.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; shiftedsum(A)
15

julia&gt; shiftedsum(A; dims = 1)
1×3 Array{Int64,2}:
 3  5  7</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a function <code>wrapper</code>, that accepts a number and applies the <code>round</code>, <code>ceil</code> or <code>floor</code> function based on the keyword argument <code>type</code>. Make sure that all optional and keyword arguments can be passed to these three functions.</p><p>Use the function to solve the following tasks</p><ul><li>Round <code>1252.1518</code> to the nearest larger integer and convert the resulting value to <code>Int64</code>.</li><li>Round <code>1252.1518</code> to the nearest smaller integer and convert the resulting value to <code>Int16</code>.</li><li>Round <code>1252.1518</code> to <code>2</code> digits after the decimal point.</li><li>Round <code>1252.1518</code> to <code>3</code> significant digits.</li></ul></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The one way how to define such a function is to use <code>if</code> conditions as follows</p><pre><code class="language-julia">function wrapper(x...; type = :round, kwargs...)
    if type == :ceil
        return ceil(x...; kwargs...)
    elseif type == :floor
        return floor(x...; kwargs...)
    else
        return round(x...; kwargs...)
    end
end</code></pre><p>In this case, the <code>type</code> keyword argument is used to determine which function should be used. Note, that we use an optional number of arguments as well as an optional number of keyword arguments. The reason is, that we want to pass all given arguments to the appropriate function and this is the easiest way how to do it.</p><pre><code class="language-julia-repl">julia&gt; x = 1252.1518
1252.1518

julia&gt; wrapper(Int64, x; type = :ceil)
1253

julia&gt; wrapper(Int16, x; type = :floor)
1252

julia&gt; wrapper(x; digits = 2)
1252.15

julia&gt; wrapper(x; sigdigits = 3)
1250.0</code></pre><p>The second way how to solve this exercise is to use the fact, that it is possible to pass functions as arguments. Using this fact, we can omit the if condition, and we can pass the appropriate function directly</p><pre><code class="language-julia">wrapper_new(x...; type = round, kwargs...) = type(x...; kwargs...)</code></pre><p>Note, that in the function definition, we use the <code>type</code> keyword argument as a function. It can be done since we assume that a function is assigned to the keyword argument type</p><pre><code class="language-julia-repl">julia&gt; wrapper_new(1.123; type = ceil)
2.0</code></pre><p>If we use for example <code>Symbol</code> instead of a function, the error will occur</p><pre><code class="language-julia-repl">julia&gt; wrapper_new(1.123; type = :ceil)
ERROR: MethodError: objects of type Symbol are not callable</code></pre><p>Finally, we can test <code>wrapper_new</code> function on the same arguments as we tested <code>wrapper</code> function</p><pre><code class="language-julia-repl">julia&gt; x = 1252.1518
1252.1518

julia&gt; wrapper_new(Int64, x; type = ceil)
1253

julia&gt; wrapper_new(Int16, x; type = floor)
1252

julia&gt; wrapper_new(x; digits = 2)
1252.15

julia&gt; wrapper_new(x; sigdigits = 3)
1250.0</code></pre></p></details><h2 id="Anonymous-functions"><a class="docs-heading-anchor" href="#Anonymous-functions">Anonymous functions</a><a id="Anonymous-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Anonymous-functions" title="Permalink"></a></h2><p>It is also common to use anonymous functions, i.e. functions without specified name. Such a function can be defined in almost the same way as a normal function:</p><pre><code class="language-julia">h1 = function (x)
    x^2 + 2x - 1
end
h2 = x -&gt;  x^2 + 2x - 1</code></pre><p>Those two function declarations create functions with automatically generated names. Then variables <code>h1</code> and <code>h2</code> only refers to these functions. The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is <code>map</code> function, which applies a function to each value of an array and returns a new array containing the resulting values:</p><pre><code class="language-julia-repl">julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</code></pre><p>Julia also provides a reserved word do, that allows creating more complicated functions easily. In the following example, we apply <code>map</code> function to two arrays.  Using do block, we create an anonymous function, that prints the given values a return their sum</p><pre><code class="language-julia-repl">julia&gt; map([1,3,-1], [2,4,-2]) do x, y
           println(&quot;x = $(x), y = $(y)&quot;)
           return x + y
       end
x = 1, y = 2
x = 3, y = 4
x = -1, y = -2
3-element Array{Int64,1}:
  3
  7
 -3</code></pre><p>Note, that the body of such a function is written in the same way as in the case of a normal function definition. The arguments of such function are defined after the <code>do</code> keyword. Usually, it is better to create an actual function and then use it in <code>map</code> function. The previous example can be rewritten as</p><pre><code class="language-julia">function f(x, y)
    println(&quot;x = $(x), y = $(y)&quot;)
    return x + y
end</code></pre><pre><code class="language-julia-repl">julia&gt; map(f, [1,3,-1], [2,4,-2])
x = 1, y = 2
x = 3, y = 4
x = -1, y = -2
3-element Array{Int64,1}:
  3
  7
 -3</code></pre><p>There are many possible uses quite different from map, such as managing system state. For example, there is a version of open that runs code ensuring that the opened file is eventually closed</p><pre><code class="language-julia">open(&quot;outfile&quot;, &quot;w&quot;) do io
    write(io, data)
end</code></pre><h2 id="Dot-Syntax-for-Vectorizing-Functions"><a class="docs-heading-anchor" href="#Dot-Syntax-for-Vectorizing-Functions">Dot Syntax for Vectorizing Functions</a><a id="Dot-Syntax-for-Vectorizing-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Dot-Syntax-for-Vectorizing-Functions" title="Permalink"></a></h2><p>In technical-computing languages, it is common to have <em>vectorized</em> versions of functions. Imagine, that we have a function <code>f(x)</code>, then its vectorized version is a function, that applies function <code>f</code> to each element of an array <code>A</code> and returns a new array <code>f(A)</code>. Such functions are especially useful in languages, where loops are slow and vectorized versions of functions are written in a low-level language (C, Fortran,...) and are much faster. As an example, we can mention Matlab.</p><p>In Julia, vectorized functions are not required for performance, and indeed it is often beneficial to write your own loops, but they can still be convenient. As an example, consider the sine function and imagine, that we want to compute its value for all following values <code>[0, π/2, 3π/4]</code>. Using the loops we can do it as follows</p><pre><code class="language-julia-repl">julia&gt; x = [0, π/2, 3π/4];

julia&gt; A = zeros(length(x));

julia&gt; for (i, xi) in enumerate(x)
           A[i] = sin(xi)
       end

julia&gt; A
3-element Array{Float64,1}:
 0.0
 1.0
 0.7071067811865476</code></pre><p>or using list compherension</p><pre><code class="language-julia-repl">julia&gt; A = [sin(xi) for xi in x]
3-element Array{Float64,1}:
 0.0
 1.0
 0.7071067811865476</code></pre><p>However, in this case, the most onvenient way is to use dot syntax for vectorizing functions as follows</p><pre><code class="language-julia-repl">julia&gt; A = sin.(x)
3-element Array{Float64,1}:
 0.0
 1.0
 0.7071067811865476</code></pre><p>In Julia, it is possible to use this syntax for any function to apply it to each element of the given array. It is extremely useful since it allows us to write simple functions that accept for example only numbers as arguments and then we can easily apply them to whole arrays</p><pre><code class="language-julia">plus(x::Real, y::Real) = x + y</code></pre><p>Here, we define a function, that accepts two real numbers and returns their sum. This function will work perfectly for two numbers</p><pre><code class="language-julia-repl">julia&gt; plus(1,3)
4

julia&gt; plus(1.4,2.7)
4.1</code></pre><p>But, if we try to apply this function to arrays, an error will occur</p><pre><code class="language-julia-repl">julia&gt; x = [1,2,3,4]; # column vector

julia&gt; plus(x, x)
ERROR: MethodError: no method matching plus(::Array{Int64,1}, ::Array{Int64,1})</code></pre><p>However, we can use dot syntax for vectorizing functions, to any function in Julia. Then the plus function will be applied to arrays <code>x</code> and <code>y</code> element-wise</p><pre><code class="language-julia-repl">julia&gt; plus.(x, x)
4-element Array{Int64,1}:
 2
 4
 6
 8</code></pre><p>More generally, if we have a function <code>f</code> and we use dot syntax <code>f.(args...)</code>, then it is equivalent to calling the <code>broadcast</code> function  in the following way <code>broadcast(f, args...)</code></p><pre><code class="language-julia-repl">julia&gt; broadcast(plus, x, x)
4-element Array{Int64,1}:
 2
 4
 6
 8</code></pre><p>This allows us to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars. For more information see the section about <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting</a> in the official documentation. In the following example, the <code>plus</code> function adds one to each element of the <code>x</code> array</p><pre><code class="language-julia-repl">julia&gt; plus.(x, 1)
4-element Array{Int64,1}:
 2
 3
 4
 5</code></pre><p>Or we can apply the <code>plus</code> function to the column vector <code>x</code> and the row vector <code>y</code>. The result will be a matrix</p><pre><code class="language-julia-repl">julia&gt; y = [1 2 3 4]; # row vector

julia&gt; plus.(x, y)
4×4 Array{Int64,2}:
 2  3  4  5
 3  4  5  6
 4  5  6  7
 5  6  7  8</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Some text that describes the exercise</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Solution</p></p></details><h2 id="Function-composition-and-piping"><a class="docs-heading-anchor" href="#Function-composition-and-piping">Function composition and piping</a><a id="Function-composition-and-piping-1"></a><a class="docs-heading-anchor-permalink" href="#Function-composition-and-piping" title="Permalink"></a></h2><p>As in mathematics, functions in Julia can be composed. If we have two functions <span>$f: \mathcal{X}  \rightarrow \mathcal{Y}$</span> and <span>$g: \mathcal{Y}  \rightarrow \mathcal{Z}$</span>, then their <a href="https://en.wikipedia.org/wiki/Function_composition">composition</a> can be mathematically written as</p><p class="math-container">\[(g \circ f)(x) = g(f(x)), \quad \forall x \in \mathcal{X}.\]</p><p>In Julia, we can compose functions in a similar way using the function composition operator <code>∘</code> (can be typed as <code>\circ&lt;tab&gt;</code>)</p><pre><code class="language-julia-repl">julia&gt; (sqrt ∘ +)(3, 6) # equivalent to sqrt(3 + 6)
3.0</code></pre><p>It is even possible to compose multiple functions at once</p><pre><code class="language-julia-repl">julia&gt; (sqrt ∘ abs ∘ sum)([-3, -6, -7])  # equivalent to sqrt(abs(sum([-3, -6, -7])))
4.0</code></pre><p>There is also another concept, that allows to chain functions, which is sometimes called <em>piping</em> or <em>using a pipe</em> to send data to a subsequent function. This concept can be used to simply pass the output of one function as an input to another one. In Julia, it can be one by pipe operator <code>|&gt;</code></p><pre><code class="language-julia-repl">julia&gt; [-3, -6, -7] |&gt; sum |&gt; abs |&gt; sqrt
4.0</code></pre><p>The pipe operator can be combined with broadcasting. In the following example, firstly we apply the <code>abs</code> function element-wise and then we apply the <code>sqrt</code> function element-wise.</p><pre><code class="language-julia-repl">julia&gt; [-4, 9, -16] .|&gt; abs .|&gt; sqrt
3-element Array{Float64,1}:
 2.0
 3.0
 4.0</code></pre><p>Or as in the next example, we can use broadcasting in combination with the pipe operator to apply a different function to each element of the given vector</p><pre><code class="language-julia-repl">julia&gt; [&quot;a&quot;, &quot;list&quot;, &quot;of&quot;, &quot;strings&quot;] .|&gt; [uppercase, reverse, titlecase, length]
4-element Array{Any,1}:
  &quot;A&quot;
  &quot;tsil&quot;
  &quot;Of&quot;
 7</code></pre><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Some text that describes the exercise</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Solution</p></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_02/exercises/">« Exercises</a><a class="docs-footer-nextpage" href="../methods/">Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 31 December 2020 17:40">Thursday 31 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
