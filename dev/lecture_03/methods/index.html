<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why_julia/">Why Julia?</a></li><li><a class="tocitem" href="../../howto/">How to...</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Mathematical operations and Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluation</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../functions/">Functions</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Method-Ambiguities"><span>Method Ambiguities</span></a></li></ul></li><li><a class="tocitem" href="../scope/">Scope of Variables</a></li><li><a class="tocitem" href="../exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/basics/">Package management</a></li><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Theory of optimization</a></li><li><a class="tocitem" href="../../lecture_07/gradients/">Visualization of gradients</a></li><li><a class="tocitem" href="../../lecture_07/numerical_methods/">Numerical methods</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Ordinary differential equations</span></li><li><span class="tocitem">12: Statistics I.</span></li><li><span class="tocitem">13: Statistics II.</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Functions and methods</a></li><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_03/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h1><p>So far, we have defined all functions (with some exceptions) without annotating types of their input arguments. The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code.</p><p>In Julia, functions consist of multiple methods. The choice of which method to execute when a function is applied is called dispatch. Julia allows the dispatch process to choose which of a function&#39;s methods to call based on</p><ul><li>the number of arguments given</li><li>types of all of the function&#39;s arguments.</li></ul><p>Using all of a function&#39;s arguments to choose which method should be invoked is known as <strong>multiple dispatch</strong>.</p><p>As an example of usage of multiple-dispatch, we will define a <code>product</code> function, that will computes the product of the given numbers</p><pre><code class="language-julia-repl">julia&gt; product(x, y) = x * y
product (generic function with 1 method)</code></pre><p>In the REPL, we can see the line, that tells us, that the function product has only one method. In this case,  we defined only the method for two input arguments without type specification</p><pre><code class="language-julia-repl">julia&gt; product(1, 4.5)
4.5

julia&gt; product(2.4, 3.1)
7.4399999999999995</code></pre><p>A list of all methods for a given function can be obtained using the <code>methods</code> function</p><pre><code class="language-julia-repl">julia&gt; methods(product)
# 1 method for generic function &quot;product&quot;:
[1] product(x, y) in Main.ex-methods at none:1</code></pre><p>Because we did not specify any types of input arguments, the <code>product</code> function accepts arguments of all types. However, the <code>*</code> operator will not work for example for symbols</p><pre><code class="language-julia-repl">julia&gt; product(:a, :b)
ERROR: MethodError: no method matching *(::Symbol, ::Symbol)
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:538</code></pre><p>We can avoid such errors by specifying types of input arguments. Since we want to create a function that computes the product of two numbers, it makes sense to allow input arguments to be only numbers.</p><pre><code class="language-julia">product(x::Number, y::Number) = x * y
product(x, y) = throw(ArgumentError(&quot;product is defined for numbers only.&quot;))</code></pre><p>Note that we also redefined the original definition of the <code>product</code> function to throw an error if we call the function with non-numeric input arguments.</p><pre><code class="language-julia-repl">julia&gt; methods(product)
# 2 methods for generic function &quot;product&quot;:
[1] product(x::Number, y::Number) in Main.ex-methods at none:1
[2] product(x, y) in Main.ex-methods at none:1</code></pre><p>Now, we have a function with two methods, that returns a product if the input arguments are numbers and throw an error otherwise.</p><pre><code class="language-julia-repl">julia&gt; product(1, 4.5)
4.5

julia&gt; product(:a, :b)
ERROR: ArgumentError: product is defined for numbers only.

julia&gt; product(&quot;a&quot;, &quot;b&quot;)
ERROR: ArgumentError: product is defined for numbers only.</code></pre><p>As in the previous example, it is always better to use abstract types like <code>Number</code> or <code>Real</code> instead of concrete types like <code>Float64</code>,<code>Float32</code>, <code>Int64</code> ... . This is because if we use an abstract type, the function will work for all its subtypes. To find an super type for a specific type, we can use  <code>supertype</code> function from <code>InteractiveUtils</code> package</p><pre><code class="language-julia-repl">julia&gt; using InteractiveUtils: supertype

julia&gt; supertype(Float64)
AbstractFloat</code></pre><p>The problem with the <code>supertype</code> function is, that it will not return the whole supertype hierarchy, but only the closest <em>larger</em> supertype for the given type. For <code>Float64</code> the closest large supertype is <code>AbstractFloat</code>. However, as in the example before, we do not want to use this supertype, since then the function will only work for floating-point numbers. Solve the following exercise to get the tool, which allows you to print the whole supertypes hierarchy.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Create a function <code>supertypes_tree</code> that prints the whole tree of all supertypes for the given type. If the given type <code>T</code> satisfies the following condition <code>T === Any</code>, then the function should do nothing. Use the following function declaration</p><pre><code class="language-julia">function supertypes_tree(T::Type, level::Int = 0)
    # code
end</code></pre><p>The optional argument <code>level</code> sets the level of indentation</p><p><strong>Hints:</strong></p><ul><li>use the <code>supertype</code> function in combination with recursion.</li><li>use function <code>repeat</code> and string with white space <code>&quot;    &quot;</code> to create a proper indentation.</li><li>look at the example placed after the solution, how the output of the function should look like.</li></ul></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The <code>supertypes_tree</code> function can be defined as follows</p><pre><code class="language-julia">function supertypes_tree(T::Type, level::Int = 0)
    T === Any &amp;&amp; return
    println(repeat(&quot;   &quot;, level), T)
    supertypes_tree(supertype(T), level + 1)
    return
end</code></pre><p>On the first line, we check if the given input type is <code>Any</code>, and if yes, then the function returns nothing. If the input type is not <code>Any</code>, then the function prints the type with a proper indentation which is given by <code>repeat(&quot;   &quot;, level)</code>, i.e. four white-spaces are repeated <code>level</code>-times. On the third-line, we call the <code>supertypes_tree</code> function recursively for the supertype of the type <code>T</code> and level of indentation <code>level + 1</code>.</p></p></details><p>Now we can use the <code>supertypes_tree</code> function to get the whole supertypes hierarchy for <code>Float64</code>.</p><pre><code class="language-julia-repl">julia&gt; supertypes_tree(Float64)
Float64
   AbstractFloat
      Real
         Number</code></pre><p>We can check the type hierarchy using <code>&lt;:</code> operator for comparing type, i.e. is <code>T1 &lt;: T2</code> is true, then <code>T1</code> is a subtype (or the same type) of <code>T2</code>.</p><pre><code class="language-julia-repl">julia&gt; Float64 &lt;: AbstractFloat &lt;: Real &lt;: Number
true</code></pre><p>Similarly to the <code>supertype</code> function, there is a function <code>subtypes</code>, that return all subtypes for the given type</p><pre><code class="language-julia-repl">julia&gt; using InteractiveUtils: subtypes

julia&gt; subtypes(Number)
2-element Array{Any,1}:
 Complex
 Real</code></pre><p>But there is the same problem as for the <code>supertype</code> function: It is not possible to get the whole hierarchy of all subtypes using only this function. Solve the following exercise to get the tool, which allows you to print the whole subtypes hierarchy.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Create a function <code>subtypes_tree</code> that prints the whole tree of all subtypes for the given type. Use the following function declaration</p><pre><code class="language-julia">function subtypes_tree(T::Type, level::Int = 0)
    # code
end</code></pre><p>The optional argument <code>level</code> sets the level of indentation</p><p><strong>Hints:</strong></p><ul><li>use the <code>subtypes</code> function in combination with recursion.</li><li>use function <code>repeat</code> and string with white space <code>&quot;    &quot;</code> to create a proper indentation.</li><li>look at the example placed after the solution, how the output of the function should look like.</li></ul></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The <code>subtypes_tree</code> function can be defined as follows</p><pre><code class="language-julia">function subtypes_tree(T::Type, level::Int = 0)
    println(repeat(&quot;   &quot;, level), T)
    subtypes_tree.(subtypes(T), level + 1)
    return
end</code></pre><p>The function prints the type with a proper indentation which is given by <code>repeat(&quot;   &quot;, level)</code>, i.e. four white-spaces are repeated <code>level</code>-times. On the second-line, we call the <code>subtypes_tree</code> function recursively for all subtypes of the type <code>T</code> and level of indentation <code>level + 1</code>. Note, that we use dot syntax to apply the <code>subtypes_tree</code> function to all elements of the tuple, that is returned by <code>subtypes(T)</code>.</p></p></details><p>Now we can use the <code>subtypes_tree</code> function to get the whole subtypes hierarchy for <code>Number</code></p><pre><code class="language-julia-repl">julia&gt; subtypes_tree(Number)
Number
   Complex
   Real
      AbstractFloat
         BigFloat
         Float16
         Float32
         Float64
      AbstractIrrational
         Irrational
      FixedPointNumbers.FixedPoint
         FixedPointNumbers.Fixed
         FixedPointNumbers.Normed
      Integer
         Bool
         GeometryBasics.OffsetInteger
         Signed
            BigInt
            Int128
            Int16
            Int32
            Int64
            Int8
         Unsigned
            UInt128
            UInt16
            UInt32
            UInt64
            UInt8
      Rational
      StatsBase.TestStat</code></pre><p>From the tree of all subtypes of the abstract type <code>Number</code>, we see the whole structure of numerical types in Julia. So if we want to define a function that accepts all numeric types, we should use inputs of type <code>Number</code>. However, many operations are restricted to only real numbers, in such a case, we want to use the <code>Real</code> type instead of <code>Number</code>.</p><p>Now we can go back to our example with the <code>product</code> function. The problem with this function is, that it is too restrictive since the product of two strings is a legitimate operation that should return their concatenation. So we should define a method for strings. To use the proper type, we can use the <code>supertypes_tree</code> function for the <code>String</code> type</p><pre><code class="language-julia-repl">julia&gt; supertypes_tree(String)
String
   AbstractString</code></pre><p>We see, that the <em>largest</em> supertype for <code>String</code> is the <code>AbstractString</code> and that is the type we should use</p><pre><code class="language-julia">product(x::AbstractString, y::AbstractString) = x * y
product(x, y) = throw(ArgumentError(&quot;product is defined for numbers and strings only.&quot;))</code></pre><p>We also redefined the original definition of the <code>product</code> function to throw an appropriate error.</p><pre><code class="language-julia-repl">julia&gt; product(1, 4.5)
4.5

julia&gt; product(&quot;a&quot;, &quot;b&quot;)
&quot;ab&quot;

julia&gt; product(:a, :b)
ERROR: ArgumentError: product is defined for numbers and strings only.</code></pre><p>Sometimes, it can be very complicated to guess, which method will be used for concrete inputs. In such a case, there is a useful macro <code>@which</code> that returns the method that would be called for given arguments</p><pre><code class="language-julia-repl">julia&gt; using InteractiveUtils: @which

julia&gt; @which product(1, 4.5)
product(x::Number, y::Number) in Main.ex-methods at none:1

julia&gt; @which product(&quot;a&quot;, :a)
product(x, y) in Main.ex-methods at none:1

julia&gt; @which product(&quot;a&quot;, &quot;b&quot;)
product(x::AbstractString, y::AbstractString) in Main.ex-methods at none:1</code></pre><p>The previous example with the <code>product</code> function shows, how methods in Julia works. However, it is a good practice to use type annotation only if we really want to have a specialized function or if we want to define a function, which does different things for different types of input arguments.</p><pre><code class="language-julia">g(x::Real) = x + 1
g(x::String) = repeat(x, 4)</code></pre><p>For example, the <code>g</code> function returns <code>x + 1</code> if the input <code>x</code> is a real number or repeats four times the input argument if it is a string. Otherwise, it will throw a method error, since we define only these two specific methods.</p><pre><code class="language-julia-repl">julia&gt; g(1.2)
2.2

julia&gt; g(&quot;a&quot;)
&quot;aaaa&quot;

julia&gt; g(:a)
ERROR: MethodError: no method matching g(::Symbol)
Closest candidates are:
  g(!Matched::String) at none:1
  g(!Matched::Real) at none:1</code></pre><div class = "info-body">
<header class = "info-header">Do not overuse type annotation!!!</header><p><p>The <code>product</code> function should be defined without the type annotation. It is a good practice to not restrict input argument types if it is not necessary. The reason is, that in this case, there is no benefit to using the type annotation. If we define a function <code>product_new</code> in the following way</p><pre><code class="language-julia">product_new(x, y) = x * y</code></pre><p>Then we can apply this function to the same inputs as the original <code>product</code> function and we will get the same results</p><pre><code class="language-julia-repl">julia&gt; product(1, 4.5)
4.5

julia&gt; product_new(1, 4.5)
4.5

julia&gt; product(&quot;a&quot;, &quot;b&quot;)
&quot;ab&quot;

julia&gt; product_new(&quot;a&quot;, &quot;b&quot;)
&quot;ab&quot;</code></pre><p>with only one exception</p><pre><code class="language-julia-repl">julia&gt; product(&quot;a&quot;, :a)
ERROR: ArgumentError: product is defined for numbers and strings only.

julia&gt; product_new(&quot;a&quot;, :a)
ERROR: MethodError: no method matching *(::String, ::Symbol)
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:538
  *(::Union{AbstractChar, AbstractString}, !Matched::Union{AbstractChar, AbstractString}...) at strings/basic.jl:251
  *(::Union{Regex, AbstractChar, AbstractString}, !Matched::Union{Regex, AbstractChar, AbstractString}...) at regex.jl:656
  ...</code></pre><p>Here we get a different error, but the error given by the <code>product_new</code> function is more useful since it tells us what is the real problem. We can see, that it is not possible to use the <code>*</code> operator to multiply <code>String</code> and <code>Symbol</code>. Now we can decide if it is the desired behavior and if not, we can define a method for the <code>*</code> operator that will fix it.</p></p></div><h2 id="Method-Ambiguities"><a class="docs-heading-anchor" href="#Method-Ambiguities">Method Ambiguities</a><a id="Method-Ambiguities-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Ambiguities" title="Permalink"></a></h2><p>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</p><pre><code class="language-julia">f(x::Float64, y) = x * y
f(x, y::Float64) = x + y</code></pre><p>Here, the <code>f</code> function has two methods. The first method applies if the first argument is of type <code>Float64</code>.</p><pre><code class="language-julia-repl">julia&gt; f(2.0, 3)
6.0</code></pre><p>The second method applies if the second argument is of type <code>Float64</code>.</p><pre><code class="language-julia-repl">julia&gt; f(2, 3.0)
5.0</code></pre><p>The case, where both arguments are of type <code>Float64</code> can be handled by both methods. The problem is that neither method is more specific than the other. In such cases, Julia raises a <code>MethodError</code> rather than arbitrarily picking a method.</p><pre><code class="language-julia-repl">julia&gt; f(2.0, 3.0)
ERROR: MethodError: f(::Float64, ::Float64) is ambiguous. Candidates:
  f(x::Float64, y) in Main.ex-methods_amb at none:1
  f(x, y::Float64) in Main.ex-methods_amb at none:1
Possible fix, define
  f(::Float64, ::Float64)</code></pre><p>We can avoid method ambiguities by specifying an appropriate method for the intersection case:</p><pre><code class="language-julia-repl">julia&gt; f(x::Float64, y::Float64) = x - y
f (generic function with 3 methods)</code></pre><p>If we can check again how many methods are defined for <code>f</code>, there will be three methods</p><pre><code class="language-julia-repl">julia&gt; methods(f)
# 3 methods for generic function &quot;f&quot;:
[1] f(x::Float64, y::Float64) in Main.ex-methods_amb at none:1
[2] f(x::Float64, y) in Main.ex-methods_amb at none:1
[3] f(x, y::Float64) in Main.ex-methods_amb at none:1

julia&gt; f(2, 3.0)
5.0

julia&gt; f(2.0, 3)
6.0

julia&gt; f(2.0, 3.0)
-1.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Functions</a><a class="docs-footer-nextpage" href="../scope/">Scope of Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 January 2021 15:11">Monday 4 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
