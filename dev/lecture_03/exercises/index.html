<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exercises · Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quick Start Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary Functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data Structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional Evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and Iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft Local Scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../scope/">Scope of Variables</a></li><li><a class="tocitem" href="../exceptions/">Exception Handling</a></li><li class="is-active"><a class="tocitem" href>Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/basics/">Package Management</a></li><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard Library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other Useful Packages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composit types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic Programming</a></li></ul></li><li><span class="tocitem">6: Modules and packages</span></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Statistics</span></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Functions and methods</a></li><li class="is-active"><a href>Exercises</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exercises</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_03/exercises.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Conway&#39;s-Game-of-Life"><a class="docs-heading-anchor" href="#Conway&#39;s-Game-of-Life">Conway&#39;s Game of Life</a><a id="Conway&#39;s-Game-of-Life-1"></a><a class="docs-heading-anchor-permalink" href="#Conway&#39;s-Game-of-Life" title="Permalink"></a></h1><p>The <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> (the following description is taken from Wikipedia), also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves. It is Turing complete and can simulate a universal constructor or any other Turing machine.</p><p>The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:</p><ol><li>Any live cell with two or three live neighbours survives.</li><li>Any dead cell with three live neighbours becomes a live cell.</li><li>All other live cells die in the next generation. Similarly, all other dead cells stay dead.</li></ol><p>The initial pattern constitutes the seed of the system. The first generation is created by applying the above rules simultaneously to every cell in the seed; births and deaths occur simultaneously, and the discrete moment at which this happens is sometimes called a tick. Each generation is a pure function of the preceding one. The rules continue to be applied repeatedly to create further generations.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a function <code>neighbours</code> that return the number of live neighbours of the given cell. The function should accept the <code>world</code> matrix of boolean values that represents state of all cells (<code>true</code> if cell is alive and <code>false</code> otherwise) and index of the row and column of the target cell.</p><p><strong>Hint:</strong> use the following properties of the <code>mod1</code> function to implement periodic boundaries</p><pre><code class="language-julia-repl">julia&gt; mod1(1, 4)
1

julia&gt; mod1(4, 4)
4

julia&gt; mod1(5, 4)
1</code></pre><p><strong>Bonus:</strong> define more general function that compute number of alive cells in a neighborhood of an arbitrary size.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>One way how to define the <code>neighbours</code> function is to manually write all neighbours indexes as follows</p><pre><code class="language-julia">function neighbours(world, row, col)
    n, m = size(world)

    # this implements periodic boundaries
    down  = mod1(row + 1, n)
    up    = mod1(row - 1, n)
    left  = mod1(col - 1, m)
    right = mod1(col + 1, m)

    return ( world[up,   left] + world[up,  col]  + world[up,   right]
           + world[row,  left] +                  + world[row,  right]
           + world[down, left] + world[down, col] + world[down, right])
end</code></pre><p>Note that it is possible to write an expression on multiple lines. However, the approach above can not be used to define a general version of the <code>neighbours</code> function. In this case, we can use nested loops. Firstly we compute proper row indexes using a linear range in combination with the <code>mod1</code> function</p><pre><code class="language-julia">rows = mod1.(row .+ (-r:r), size(world, 1))</code></pre><p>Column indexes can be computed similarly. Then we use nested loops to iterate through the rows and columns defined above. Do not forget to subtract the state of the middle cell.</p><pre><code class="language-julia">function neighbours(world, row, col; r = 1)
    rows = mod1.(row .+ (-r:r), size(world, 1))
    cols = mod1.(col .+ (-r:r), size(world, 2))

    return sum(world[i, j] for i in rows, j in cols) - world[row, col]
end</code></pre></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Add new method to the <code>neighbours</code> function that for the given <code>world</code> matrix returns matrix that contains numbers of living neighbours.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>We created a function that computes the number of living neighbours in the exercise above. One way how to create a matrix with numbers of living neighbours is as follows</p><pre><code class="language-julia">function neighbours(world)
    n, m = size(world, 1)
    return [neighbours(world, row, col) for row in 1:n, col in 1:m]
end</code></pre></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write a function <code>willsurvive</code> that returns <code>true</code> if the cell will survive based on the conditions described in the beginning of the section, and <code>false</code> otherwise. This function should accept two arguments: state of the cell (<code>true</code>/<code>false</code>) and the number of living neighbours.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>This function can be written using the <code>if-elseif-else</code> statement as follows</p><pre><code class="language-julia">function willsurvive(cell, k)
    if k == 3
        return true
    elseif k == 2 &amp;&amp; cell == 1
        return true
    else
        return false
    end
end</code></pre><p>But we can also write the function in simpler form. The first thing that we have to realize the first two conditions can be merged together using short-circuit evaluation. Since the function returns  only <code>true</code> or <code>false</code>, we can write the function on one line as follows</p><pre><code class="language-julia">willsurvive(cell, k) = k == 3 || k == 2 &amp;&amp; cell == 1</code></pre></p></details><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Use all functions defined above to write a function <code>evolve!</code> that evolve the given <code>world</code> matrix into a new generation.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The first thing we have to do is to compute the matrix  with numbers of living neighbours. Then we can iterate over all elements of the given <code>world</code> matrix and copute new state of the current element using the <code>willsurvive</code> function</p><pre><code class="language-julia">function evolve!(world)
    ks = neighbours(world)
    for i in eachindex(world)
        world[i] = willsurvive(world[i], ks[i])
    end
    return
end</code></pre></p></details><p>In the four exercises above, we defined a function that are necessary to create an animation of Game of Life. Use the following code to get the initialization of the <code>world</code></p><pre><code class="language-julia">world = zeros(Bool, 30, 30)
row, col = 15, 15

world[row, col] = 1
world[row, col + 1] = 1
world[row - 1, col + 6] = 1
world[row + 1, col + 1] = 1
world[row + 1, col + 5] = 1
world[row + 1, col + 6] = 1
world[row + 1, col + 7] = 1</code></pre><p>To create an animation, we will use the Plots package, that we introduced in the previous <a href="../../lecture_02/exercises/#Julia-set">lecture</a></p><pre><code class="language-julia">using Plots

anim = @animate for i in 1:150
    heatmap(world; axis = nothing, border = :none, cbar = false, ratio = :equal)
    evolve!(world)
end
gif(anim, &quot;gameoflife.gif&quot;; fps = 10)</code></pre><p><img src="../gameoflife.gif" alt/></p><p>Many different types of patterns occur in the Game of Life. For example, the following initialization is called pulsar</p><pre><code class="language-julia">world = zeros(Bool, 17, 17)
line = zeros(17)
line[5:7] .= 1
line[11:13] .= 1

for ind in [3,8,10,15]
    world[ind, :] .= line
    world[:, ind] .= line
end</code></pre><p><img src="../gameoflife_pulsar.gif" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../exceptions/">« Exception Handling</a><a class="docs-footer-nextpage" href="../../lecture_04/basics/">Package Management »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 17 February 2021 20:31">Wednesday 17 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
