<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Files and modules · Julia for Optimization and Learning</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Optimization and Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Optimization and Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Julia for Optimization and Learning</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_04/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Files and modules</a><ul class="internal"><li><a class="tocitem" href="#Files"><span>Files</span></a></li><li><a class="tocitem" href="#Modules"><span>Modules</span></a></li></ul></li><li><a class="tocitem" href="../pkg/">Package manager</a></li><li><a class="tocitem" href="../develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/sparse/">Linear regression with sparse constraints</a></li><li><a class="tocitem" href="../../lecture_11/monte/">Monte Carlo sampling</a></li><li><a class="tocitem" href="../../lecture_11/glm/">Linear regression revisited</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_12/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_12/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_12/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">6: Code organization</a></li><li class="is-active"><a href>Files and modules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Files and modules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Julia-for-Optimization-and-Learning/blob/master/docs/src/lecture_06/modules.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Files-and-modules"><a class="docs-heading-anchor" href="#Files-and-modules">Files and modules</a><a id="Files-and-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Files-and-modules" title="Permalink"></a></h1><p>When writing code, it is essential to organize it effectively. There are three main ways of achieving this:</p><ol><li>Split code into multiple files.</li><li>Use modules to create global scopes.</li><li>Create separate packages by extracting code with general functionality.</li></ol><p>These three approaches are often used together. This lecture describes how to use them in Julia.</p><h2 id="Files"><a class="docs-heading-anchor" href="#Files">Files</a><a id="Files-1"></a><a class="docs-heading-anchor-permalink" href="#Files" title="Permalink"></a></h2><p>The first and most basic approach is to split code into multiple files. Such files have to be of an appropriate type, i.e., Julia files with the <code>.jl</code> extension. These files can be loaded into the global scope by the <code>include</code> function.</p><pre><code class="language-julia hljs">include(&quot;/absolute/path/to/the/file/filename.jl&quot;)
include(&quot;../relative/path/to/the/file/filename.jl&quot;)</code></pre><p>The  <code>include</code> function evaluates the source file content in the global scope of the module, where the <code>include</code> call occurs. If a file is included multiple times, it is also evaluated multiple times.</p><p>Even though using separate files to organize code can be very useful, this approach also has several disadvantages. For example, since all files are evaluated in the same global scope, we have to avoid clashes of variable/function names from different files.  This problem can be solved by using modules as described in the following section.</p><div class="admonition is-info"><header class="admonition-header">Main module:</header><div class="admonition-body"><p>If we run a code in the REPL, the code is evaluated in the <code>Main</code> module, which serves as the default global scope. We can check this by the <code>@__MODULE__</code> macro that returns the module in which the macro is evaluated.</p><pre><code class="language-julia hljs">julia&gt; @__MODULE__
Main</code></pre><p>The <code>parentmodule</code> function determines the module containing the (first) definition of a generic function.</p><pre><code class="language-julia hljs">julia&gt; foo() = 1
foo (generic function with 1 method)

julia&gt; parentmodule(foo)
Main</code></pre></div></div><h2 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h2><p>Modules allow users to specify which data from the module is visible outside of the module. In the section <a href="../../lecture_03/scope/#Scope-of-variables">Scope of variables</a>, we briefly mentioned that modules in Julia introduce a new global scope. In other words, modules in Julia are separate variable workspaces that provide three key features. They all help to prevent unexpected name clashes.</p><ul><li>They define top-level definitions (global variables) without worrying about name conflicts.</li><li>They control the visibility of variables/functions/types outside of the module via exporting.</li><li>They control the visibility of variables/functions/types from other modules via importing.</li></ul><p>The following example defines the module <code>Points</code>. We create it with the <code>module</code> keyword and load the <code>LinearAlgebra</code> package by the <code>using</code> keyword. Then we use the <code>export</code> keyword to export the <code>Point</code> type and the <code>distance</code> function. Finally, we write the actual content of the module.</p><pre><code class="language-julia hljs">module Points

using LinearAlgebra

export Point, distance

struct Point{T &lt;: Real}
    x::T
    y::T
end

coordinates(p::Point) = (p.x, p.y)
Base.show(io::IO, p::Point) = print(io, coordinates(p))
distance(p::Point, q::Point) = norm(coordinates(q) .- coordinates(p), 2)

end</code></pre><p>Assume now that we want to load this module from a different file. Since each package core is a module, packages are loaded in the same way as modules. We need to specify <code>using Main.Points</code> or <code>using .Points</code> because we defined the package in the <code>Main</code> scope. If we loaded an external package <code>Points</code>, we would use <code>using Points</code>. After loading a package, we can directly access all the exported data.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using .Points # alternatively using Main.Points</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = Point(4,2)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Point(2,2)</code><code class="nohighlight hljs ansi" style="display:block;">(2, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; distance(p, q)</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code></pre><p>It is also possible to access all non-exported functions and types. To do so, we need to specify which module they are defined in. For example, we can call the non-exported <code>coordinates</code> function by the following syntax:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Points.coordinates(p)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Points.coordinates(q)</code><code class="nohighlight hljs ansi" style="display:block;">(2, 2)</code></pre><p>When writing a module, we have to decide which functions and types we want to export. The rule of thumb is that we export only the data end-users should use.</p><p>To redefine or extend an imported function, we need to specify the module. We can use the following way to redefine the <code>distance</code> function:</p><pre><code class="language-julia hljs">using .Points: coordinates

function Points.distance(p::Point, q::Point)
    d = sqrt(sum(abs2, coordinates(q) .- coordinates(p)))
    return &quot;Distance is $d&quot;
end</code></pre><p>We can see the same syntax in the <code>Points</code> module, where we extend the <code>show</code> function from the <code>Base</code> module. We used the <code>using .Points: coordinates</code> syntax to call the <code>coordinates</code> function without specifying the module name.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = Point(4,2)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Point(2,2)</code><code class="nohighlight hljs ansi" style="display:block;">(2, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; distance(p, q)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Distance is 2.0&quot;</code></pre><p>Besides the <code>using</code> keyword, Julia also provides the <code>import</code> keyword to import modules and packages. Its behaviour is slightly different; for more information, see the <a href="https://docs.julialang.org/en/v1/manual/modules/#Summary-of-module-usage">official documentation</a>.</p><div class="admonition is-category-bonus"><header class="admonition-header">Relative and absolute module paths:</header><div class="admonition-body"><p>In the previous section, we added a dot before the module name in the <code>using</code> keyword. The reason is that if we import a module, the system consults an internal table of top-level modules to find the given module name. If the module does not exist, the system attempts to <code>require(:ModuleName)</code>, which typically results in loading code from an installed package. However, if we evaluate code in the REPL, the code is evaluated in the <code>Main</code> module. Then <code>Points</code> are not in a top-level module but in a submodule of <code>Main</code>.</p><pre><code class="language-julia hljs">julia&gt; Points
Main.Points

julia&gt; parentmodule(Points)
Main</code></pre><p>Non-top-level modules can be loaded by both absolute and relative paths.</p><pre><code class="language-julia hljs">using Main.Points
using .Points</code></pre><p>Adding one more leading dot moves the path one additional level up in the module hierarchy. For example, <code>using ..Points</code> would look for <code>Points</code> in the enclosing module for <code>Main</code> rather than <code>Main</code> itself.</p></div></div><div class="admonition is-category-bonus"><header class="admonition-header">Modules and files:</header><div class="admonition-body"><p>Since modules are associated only with module expressions, files are largely unrelated to modules. One can have multiple files in a module.</p><pre><code class="language-julia hljs">module MyModule

include(&quot;file1.jl&quot;)
include(&quot;file2.jl&quot;)

end</code></pre><p>It is also possible to have multiple modules in a file.</p><pre><code class="language-julia hljs">module MyModule1
...
end

module MyModule2
...
end</code></pre></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_05/currencies/">« Generic programming</a><a class="docs-footer-nextpage" href="../pkg/">Package manager »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Tuesday 21 September 2021 08:23">Tuesday 21 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
