var documenterSearchIndex = {"docs":
[{"location":"lecture_01/strings/#Strings","page":"Strings","title":"Strings","text":"","category":"section"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"In Julia as in other programming languages, a string a sequence of one or more characters. Strings can be created using quotes","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str = \"Hello, world.\"","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"The strings are immutable and therefore cannot be changed after creation. However, it is very easy to create a new string from parts of existing strings. Individual characters of a string can be accessed via square brackets and indices (the same syntax as for arrays)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str[1] # returns the first character","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"The return type, in this case, is a Char","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"typeof(str[1])","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"A Char value represents a single character. It is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors. Chars can be created using apostrophe","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"'x'","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Characters can be converted to a numeric value representing a Unicode code point and vice versa","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Int('x')\nChar(120)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"It is also possible to extract a substring from an existing string. It is done using square brackets and multiple indexes","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str[1:5] # returns the first five characters\nstr[[1,2,5,6]]","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Notice that the expressions str[k] and str[k:k] do not give the same result:","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str[1] # returns the first character as Char\nstr[1:1] # returns the first character as String","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"When using strings, we have to pay attention to some special characters, specifically to the following three characters: \\, \" and $. If we want to use any of these three characters, we have to use a backslash before them. The reason is that these characters have a special meaning. For example, if we use quote inside a string, then the rest of the string will be interpreted as a Julia code and not a string.","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str1 = \"This is how a string is created: \\\"string\\\".\"","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Similarly, the dollar sign is reserved for string interpolation and if we want to use it as a character we have to use a backslash too","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str2 = \"\\$\\$\\$ dollars everywhere \\$\\$\\$\"","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"If we want to see how the string will be printed, we can use print or println function","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"println(str1)\nprintln(str2)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"There is one exception to using quotes inside a string: quotes without a backslashes can be used in multiline strings. Multiline strings are created using triple quotes syntax","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"mstr = \"\"\"\nThis is how a string is created: \"string\".\n\"\"\"\nprint(mstr)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"This syntax is usually used for docstring for functions. It is possible to write a string in the same way as it will appear after printing in REPL","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str = \"\"\"\n      Hello,\n      world.\n    \"\"\"\nprint(str)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></details>","category":"page"},{"location":"lecture_01/strings/#Splitting-and-joining-strings","page":"Strings","title":"Splitting and joining strings","text":"","category":"section"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"One of the most common operations on strings is their concatenation. It can be done using string function that accepts any number of input arguments and returns a string.","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"string(\"Hello,\", \" world\")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Note, that it is possible to concatenate strings with numbers and other types, that can be converted to a string","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"a = 1.123\nstring(\"The variable a is of type \", typeof(a), \" and its value is \", a)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"In general, it is not possible to perform mathematical operations on strings, even if the strings look like numbers. But there are two exceptions. The * operator performs string concatenation","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"\"Hello,\"*\" world\"","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"This approach is applicable only to string as opposed to string function that also works for other types. The second exeption is ^ operator, which performs repetition","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"\"Hello\"^3","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"This is equivalent to calling repeat function","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"repeat(\"Hello\", 3)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Another very useful function is the join function. This function also performs string concatenation, however, it supports defining custom separator and also it supports different separator for the last element","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Similarly as string function,  the join function can be used also for other types than strings","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"join([1,2,3,4,5], \", \", \" or \")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"To split a string, the function split function can be used","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str = \"JuliaLang is a pretty cool language!\"\nsplit(str)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"By default, the split function splits the given string based on spaces. But it can be changed by defining custom delimiter","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"split(str, \" a \")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"If you want to split a string into separate single-character strings, use the empty string (\"\") which splits the string between the characters","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"split(str, \"\")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></details>","category":"page"},{"location":"lecture_01/strings/#String-interpolation","page":"Strings","title":"String interpolation","text":"","category":"section"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></details>","category":"page"},{"location":"lecture_01/strings/#Find-and-replace","page":"Strings","title":"Find and replace","text":"","category":"section"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"There are multiple functions that can be used to find specific characters or substring in the given string. To check if the string contains a specific substring or character, the functions contains or occursin can be used","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"contains(\"JuliaLang is pretty cool!\", \"Julia\")\ncontains(\"Julia\", \"JuliaLang is pretty cool!\")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"These two function differ only in the order of arguments. A very useful function is the endswith function, which cheks if the given string ends with the given substring or character. It can be used for example to check, that the file has a proper suffix","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"endswith(\"figure.png\", \"png\")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"Index of a specific character in a string can be found using find functions","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"str = \"JuliaLang is a pretty cool language!\"\nfindall(isequal('a'), str)\nfindfirst(isequal('a'), str)\nfindlast(isequal('a'), str)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"As we said before, strings are immutable and cannot be changed. However, we can easily create new strings. The replace function returns a new string with a substring of characters replaced with something else","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"replace(\"Sherlock Holmes\", \"e\" => \"ee\")","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"It is also possible to apply a function to a specific substring using replace function. The following example shows how to change all e  in the given string to uppercase","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"replace(\"Sherlock Holmes\", \"e\" => uppercase)","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/strings/","page":"Strings","title":"Strings","text":"</p></details>","category":"page"},{"location":"lecture_08/logistic/#Logistic-regression","page":"Logistic regression","title":"Logistic regression","text":"","category":"section"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"The previous part dealt with predicting a continous variables. This part will handle predicting one of two classes.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Load the data as before","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"using BSON: @load\n\nfile_name = joinpath(\"data\", \"iris.bson\")\n@load file_name X y y_name","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"The data contain three classes [1 2 3]. However, in the theory we considered only binary problems with two classes. We therefore cheat.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Write function modify_data which converts X and y into binary dataset in the following way: label 1 will be deleted, label 2 will be the negative class and label 3 will be the positive class. For X consider only columns 3 and 4. This will create a two-dimensional feature vector, which will enable nice visualizations.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Since we want to keep yin23, we store the indices into i. Then we consider reduce X, y and y_name into the correct rows and columns.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"function modify_data(X, y, y_name)\n    ii = y .> 1.5\n    return X[ii,3:4], y[ii] .> 2.5, y_name[2:3]\nend\nnothing # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Finally, we call the function","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"X, y, y_name = modify_data(X, y, y_name)\nnothing # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></details>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"When designing a classification method, a good practice is to perform an analysis of the data. That may include checking for NaNs, infinite values, obvious errors, standard deviations of features or others. Here, we only plot the data.  ","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Since X has two features (columns), it is simple to visualize. Use scatter plot to show the data. Use different colours for different classes. Try to produce a nice graph by including names of classes (in y_name) and axis labels (petal length and petal width).","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"This should be known by now. The only possibly unknown command is legend=:topleft to move the legend to the top-left corner.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"using Plots\n\nscatter(X[y.==0,1], X[y.==0,2], label=y_name[1], legend=:topleft,\n    xlabel=\"Petal length\", ylabel=\"Petal width\")\nscatter!(X[y.==1,1], X[y.==1,2], label=y_name[2])\n\nsavefig(\"iris1.svg\") # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></details>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"(Image: )","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"We see that the classes are almost perfectly separable. It would not be difficult to estimate the separating hyperplane by hand. However, we will do it automatically.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Write a function log_reg which takes as an input the dataset, an initial point and uses the Newton's method to find the optimal weights w. Print the result when started from the zero point.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"It would be possible to use the code optim(f, g, x, s::Step) from the previous lecture and define only the step function s for the Newton's method. However, sometimes it may be better to write simple functions separately instead of using more complex machinery.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"To write the desired function, we need to implement the gradient and Hessian from derived in the theoretical lecture. First we need to create hat y. We may use for loop notation [1/(1+exp(-w'*x)) for x in eachrow(X)]. However, in this case, it is simpler to use matrix operations 1 ./(1 .+exp.(-X*w)) to get the same result. The gradient can be written in the same way. Again, there are two ways, we use the matrix notation. For the Hessian, we first create X_mult = [row*row' for row in eachrow(X)] which computes all products x_ix_i^top. Note that this is outside the for loop for iterations, as it can be computed only once. This will create an array of length 100, each element of this array will be a 2times matrix. Since it is an array, we may multiply it by y_hat.*(1 .-y_hat). Since mean from the Statistics package operates on any array, we can call it (or similarly sum). We may use mean(???) but we find the alternative  ??? |> mean more readable in this case. To update we use hess \\ grad as explained in the previous lecture for the Newton's method.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"using Statistics\n\nfunction log_reg(X, w; max_iter=100)\n    X_mult = [row*row' for row in eachrow(X)]\n    for i in 1:max_iter\n        y_hat = 1 ./(1 .+exp.(-X*w))\n        grad = X'*(y_hat.-y) / size(X,1)\n        hess = y_hat.*(1 .-y_hat).*X_mult |> mean\n        w -= hess \\ grad\n    end\n    return w\nend\nnothing # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"After the tough work, it remains to call the it.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"w0 = zeros(size(X,2))\nw_wrong = log_reg(X, w0)\nnothing # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"The name w_wrong suggests that something is wrong. The problem is that the logistic regression was called with the original dataset. However, in doing so, there is no intercept. For this reason, we need to modify X first by including the column of all ones and then calling it again.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"X_ext = hcat(X, repeat([1],size(X,1)))\nw = log_reg(X_ext, zeros(size(X_ext,2)))\nnothing # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Hooray, this time it is correct.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></details>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"If you obtained","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"println(round.(w_wrong, digits=4)) # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"the function for solving the logistic regression is correct. But you call it in a wrong way. The correct solution is","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"println(round.(w, digits=4)) # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"We can now show the solution. Since the intercept is the third component (therefore x_3=1), the separating hyperplane takes form","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"w_1x_1 + x_2x_2 + w_3 = 0","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"To express it as a function, we obtain","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"operatornamesep(x_1) = frac-w_1x_1 - w_3w_2","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Now we plot it.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"scatter(X[y.==0,1], X[y.==0,2], label=y_name[1], legend=:topleft,\n    xlabel=\"Petal length\", ylabel=\"Petal width\")\nscatter!(X[y.==1,1], X[y.==1,2], label=y_name[2])\n\nf_hyper = x -> (-w[3]-w[1]*x)/w[2]\nx_lim = [minimum(X[:,1])-0.1; maximum(X[:,1])+0.1]\nplot!(x_lim, f_hyper.(x_lim), label=\"Separating hyperplane\", line=(:black,3),\n    ylim=(minimum(X[:,2])-0.1,maximum(X[:,2])+0.1))\n\nsavefig(\"iris2.svg\") # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"(Image: )","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"This is the optimal solution obtained by the logistic regression. Since the norm of the gradient","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"using LinearAlgebra\n\ny_hat = 1 ./(1 .+exp.(-X_ext*w))\ngrad = X_ext'*(y_hat.-y) / size(X_ext,1)\nnorm(grad)","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"equals to zero, we found a stationary point. It can be shows that logistic regression is a convex problem and therefore, we found a global solution.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"The picture shows that there are misclassified samples. The mext example analyses them.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Print how mnay samples were correctly and incorrectly classified.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"Since hat y_i is a probability that sample is of the positive class, we will predict that it is positive if this probability is greater than frac 12. Then it suffices to compare the predictions pred with the correct labels y.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"pred = y_hat .>= 0.5\n\"Correct number of predictions: \" * string(sum(pred .== y))\n\"Wrong   number of predictions: \" * string(sum(pred .!= y))\n\nnothing # hide","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"There is an alternative (but equivalent way). Since the separating hyperplane is of form w^top x, we predict that a sample is positive whenever w^top xge 0. Write the code and try to reason why these two approaches ar equivalent.","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"</p></details>","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"The correct answer is","category":"page"},{"location":"lecture_08/logistic/","page":"Logistic regression","title":"Logistic regression","text":"println(\"Correct number of predictions: \" * string(sum(pred .== y))) # hide\nprintln(\"Wrong   number of predictions: \" * string(sum(pred .!= y))) # hide","category":"page"},{"location":"lecture_01/operators/#Mathematical-operations-and-Elementary-functions","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"","category":"section"},{"location":"lecture_01/operators/#Arithmetic-operators","page":"Mathematical operations and Elementary functions","title":"Arithmetic operators","text":"","category":"section"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Basic arithmetic operations are defined in Julia standard libraries and all these operators are supported on all primitive numeric types","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Expression Name Description\nx + y binary plus performs addition\nx - y binary minus performs subtraction\nx * y times performs multiplication\nx / y divide performs division\nx ÷ y integer divide x / y, truncated to an integer\nx \\ y inverse divide equivalent to y / x\nx ^ y power raises x to the yth power\nx % y remainder equivalent to rem(x,y)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Here are some simple examples using arithmetic operators","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"1 + 2\n2*3\n4/3","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"All of these operators can be also applied directly to any variable that represents numeric value","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 1;\ny = 3;\n(x + 2)/(y - 1) - 4*(x - 2)^2","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"A numeric literal placed directly before an identifier or parentheses is treated as a multiplication (except with higher precedence than other binary operations):","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"2(3 + 4) # equivalent to 2*(3 + 4)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"What is the value and type of y given by the following expression","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"y = frac(x + 2)^2 - 4(x - 2)^p - 2","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"where x = 4 and p = 5.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"First, we define variables x and p","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 4\np = 5","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"and then we can simply use the combination of basic arithmetic operators to compute the value of y","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"y = ((x + 2)^2 - 4)/(x - 2)^(p - 2)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"The type of y can be determined using typeof function","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"typeof(y)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Note that the resulting type of y is Float64 even though the result can be represented as an integer. The reason is, that we divide two integers","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"typeof((x + 2)^2 - 4)\ntypeof((x - 2)^(p - 2))","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Because this operation generally does not result in an integer, dividing two integers always returns a floating-point number.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></details>","category":"page"},{"location":"lecture_01/operators/#Promotion-system","page":"Mathematical operations and Elementary functions","title":"Promotion system","text":"","category":"section"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"As said in the section about variables, there are many numeric types in Julia. To ensure that the correct type is always used, Julia has a promotion system that converts input values of mixed types to a type that can correctly represent all values. This can be done by promote function. As an example, we can mention the conversion of multiple numeric types","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 1.0 # Float64\ny = 2 # Int64\nxp, yp = promote(x, y)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"In this case, the resulting type of variables xp and yp is Float64 as can be chcked using typeof function","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"typeof(xp)\ntypeof(yp)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"even though strictly, not all Int64 values can be represented exactly as Float64 values. The promotion system generally tries to return a type that can at least approximate most values of either input type without excessively widening.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Note, that promotion function will accept any number of input arguments","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"promote(1, 2f0, true, 4.5, Int32(1))","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"The resulting type of promotion can be determined by promotion_type function. This function is similar to promote function and will accept any number of input arguments, but the inputs have to be types and not values.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"promote_type(Float64, Int64, Bool, Int32)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Although this may seem complicated, type promotion is done automatically in most cases and the user does not have to worry about it. This can be demonstrated in the following example, where we sum two values. The first one is of type Int64 and the second one of type Float32.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 1 # Int64\ny = 2f0 # Float32","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Since the \"smallest\" type that can represent both values correctly is Float32, the result is of type Float32","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"z = x + y\ntypeof(z)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"What is the smallest type, that can represent the following values","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 1\ny = 2f0\nz = true\nw = Int32(1)\nnothing # hide","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"To get the smallest promotion type, we can use a combination of promote and typeof function","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"xp, yp, zp, wp = promote(x, y, z, w)\ntypeof(xp)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"or a combination of promote_type and typeof function","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"promote_type(typeof(x), typeof(y), typeof(z), typeof(w))","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></details>","category":"page"},{"location":"lecture_01/operators/#Updating-operators","page":"Mathematical operations and Elementary functions","title":"Updating operators","text":"","category":"section"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Every binary arithmetic operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a = immediately after the operator. For example, writing x += 3 is equivalent to writing x = x + 3:","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 1\nx += 3 # x = x + 3\nx *= 4 # x = x * 4\nx /= 2 # x = x / 2\nx \\= 16 # x = x \\ 16 = 16 / x","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Compute the value of y given by the following expression","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"y = frac(x + 4)^frac32(x + 1)^p - 1","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"where x = 5 and p = 3. Then multiply the result by 8, add 3, divide by 3, and subtract 1. What are all the intermediate results and the final result?","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"First, we calculate the value of y","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 5;\np = 3;\ny = (x + 4)^(3/2)/(x + 1)^(p - 1)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Then we can use the update operators to get all the intermediate results as well as the final result","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"y *= 8\ny += 3\ny /= 3\ny -= 1","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></details>","category":"page"},{"location":"lecture_01/operators/#Numeric-comparison","page":"Mathematical operations and Elementary functions","title":"Numeric comparison","text":"","category":"section"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"In addition to arithmetic and updating operators, basic comparison operators are also defined in Julie's standard libraries.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Operator Name\n== equality\n!=, ≠ inequality\n< less than\n<=, ≤ less than or equal to\n> greater than\n>=, ≥ greater than or equal to","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"All these operators always return boolean value (true or false) as can be seen in the following example","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"1 == 1\n1 == 1.0\n-1 <= 1\n-1 ≥ 1","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"In most programming languages, comparison operators are strictly binary, i.e. they can be used to compare with only two values at a time. As an example, we can use a comparison of three numbers in Matlab","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":">> 3 > 2 > 1\n\nans =\n\n  logical\n\n   0","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Even though the condition holds, the result is false (logical 0). The correct way to write such a condition in Matlab is as follows","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":">> 3 > 2 & 2 > 1\n\nans =\n\n  logical\n\n   1","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"In Julia (and Python, for example), both ways of writing conditions are correct and lead to the same result","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"3 > 2 > 1\n3 > 2 & 2 > 1","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"In fact, comparison operators can be arbitrarily chained as in the following example","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"It may be quite convenient in numerical code, however, it can also easily decrease code readability. So if you want to use such syntax, always take code readability in your consideration.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Comparison of special values such as NaN can lead to unexpected behavior","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"NaN == NaN\nNaN != NaN\nNaN < NaN","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"To avoid unexpected result, Julia provides additional functions to compare numbers for special values","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Function Tests if\nisequal(x, y) x and y are identical\nisfinite(x) x is a finite number\nisinf(x) x is infinite\nisnan(x) x is not a number","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Function isequal considers NaNs equal to each other","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"isequal(NaN, NaN)\n!isequal(NaN, NaN)","category":"page"},{"location":"lecture_01/operators/#Rounding-functions","page":"Mathematical operations and Elementary functions","title":"Rounding functions","text":"","category":"section"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Function Description\nround(x) round x to the nearest integer\nfloor(x) round x towards -Inf\nceil(x) round x towards +Inf\ntrunc(x) round x towards zero","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"All these functions can be used without a specified output type. In such a case, the output will have the same type as the input variable","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 3.1415\nround(x)\nfloor(x)\nceil(x)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"However, in many cases, it makes sense to convert the rounded value to an integer. To do this, we can simply pass the appropriate integer type as the first argument","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"round(Int64, x)\nfloor(Int32, x)\nceil(Int16, x)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"All rounding functions also support additional keyword arguments:","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"If the digits keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base specifide by base keyword argument.\nIf the sigdigits keyword argument is provided, it rounds to the specified number of significant digits, in base specifide by base keyword argument.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"round(x; digits = 3)\nround(x; sigdigits = 3)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Use rounding operators to solve the following tasks","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Round 1252.1518 to the nearest larger integer and convert the resulting value to Int64.\nRound 1252.1518 to the nearest smaller integer and convert the resulting value to Int16.\nRound 1252.1518 to 2 digits after the decimal point.\nRound 1252.1518 to 3 significant digits.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"The ceil function rounds numbers to the nearest larger value and since we want the result to be of type Int64, we have to pass this type as a first argument","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"x = 1252.1518\nceil(Int64, x)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"Similarly, the floor function rounds numbers to the nearest smaller value","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"floor(Int16, x)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"The number of digits after the decimal point can be controlled using digits keyword","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"round(x; digits = 2)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"and the number of significant digits using sigdigits keyword","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"round(x; sigdigits = 3)","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"</p></details>","category":"page"},{"location":"lecture_01/operators/#Numerical-Conversions","page":"Mathematical operations and Elementary functions","title":"Numerical Conversions","text":"","category":"section"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"As was shown in the previous section, the numerical conversion can be done using rounding functions with a specified type of output variable. However, it only works for converting floating-point numbers to integers. Julia also provides a more general way how to perform the numerical conversion: the notation T(x) or convert(T,x) converts x to a value of type T.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"If T is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.\nIf T is an integer type, an InexactError is raised if x is not representable by T.","category":"page"},{"location":"lecture_01/operators/","page":"Mathematical operations and Elementary functions","title":"Mathematical operations and Elementary functions","text":"convert(Float32, 1.234)\nFloat32(1.234)\nconvert(Float64, 1)\nFloat64(1)\nconvert(Int64, 1.234)\nInt64(1.234)","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"using Plots","category":"page"},{"location":"lecture_08/theory/#Theory-of-regression-and-classification","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"","category":"section"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Regression and classification are a branch of machine learning which try to predict certain variable based on labelled data. Regression predicts a continuous variable (such as height based on weight) while classification predict a variable with finite number of states (such as cat/dog/none from images).","category":"page"},{"location":"lecture_08/theory/#Data-representation","page":"Theory of regression and classification","title":"Data representation","text":"","category":"section"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"The dataset is usually stored in a matrix XinmathbbR^ntimes m. Each row of this matrix is one sample (observation). Each column is one feature (such as height, weight or age). Therefore, we have n samples, each with m features. Each sample x_i has a label y_i. Labels are arranged into a vector yinmathbbR^n. The goal of machine learning methods is to find a classifier f such that the prediction f(x_i) is a good approximation of the true label y_i.","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"This lecture considers only linear classifiers in the form","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"tilde f(x) = w^top x + b","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"while the next one on neural network considers non-linear classifiers as well.  The standard trick assumes that the first column of X contains all ones. Then we have","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"f(x) = w^top x = w_1 + sum_j=2^m w_jx_j","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"By this trick, we do not need to consider the intercept (shift) b because it is contained in w_1. In this case, the class of all considered classifiers is parameterized by a vector w. The rest of this lecture shows how to write regression and classification problems to find the optimal weights w.","category":"page"},{"location":"lecture_08/theory/#Linear-regression","page":"Theory of regression and classification","title":"Linear regression","text":"","category":"section"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"The linear regression uses the mean square error between the prediction and the label. This is","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"(w^top x_i - y_i)^2","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Since we are interested in average performance, we sum this error over all samples","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"operatornameminimizeqquad sum_i=1^n (w^top x_i - y_i)^2","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Many algorithms use average instead of sum. However, both these formulations are equivalent.","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"In this case, it is simpler to work in the matrix notation. It is not difficult to show that the previous problem is equivalent to","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"operatornameminimizeqquad normXw - y^2","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"where the norm is the l_2 norm. Since this is a convex quadratic problem, it is equivalent to its optimality condition. Setting the derivative to zero yields","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"2X^top (Xw-y) = 0","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"From here, we obtain the closed-form solution to the linear regression","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"w = (X^top X)^-1X^top y","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"<div class = \"info-body\">\n<header class = \"info-header\">Closed-form solution</header><p>","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Linear regression is probably the only machine learning model with a closed-form solution. All other models must be solved with iterative algorithms such as the gradient descent. In some case, it may be advantageous to use iterative algorithms even for linear regression. This include for example the case of a large number of features m because then X^top X is an mtimes m matrix which may be difficult to invert.","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"</p></div>","category":"page"},{"location":"lecture_08/theory/#Logistic-regression","page":"Theory of regression and classification","title":"Logistic regression","text":"","category":"section"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"The name logistic regression is misleading because it is actually a classification problem. In its simplest form, it assumes binary labels yin01. It considers the linear classifier f(x)=w^top x and predict the positive class with probability","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"mathbbP(y=1mid x) = sigma(f(w)) = frac11+e^-w^top x","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"where sigma is the sigmoid function. The probability of the negative class is then","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"mathbbP(y=0mid x) = 1 - sigma(f(w)) = frace^-w^top x1+e^-w^top x","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Denoting hat y to equal the probabily of predicting 1, the loss function is the cross-entropy loss","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"operatornameloss(yhat y) = - ylog hat y - (1-y)log(1-hat y)","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"It is not difficult to show that then the logistic regression problems reads","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"operatornameminimizeqquad frac1nsum_i=1^nleft(log(1+e^-w^top x_i) + (1-y_i)w^top x_i right)","category":"page"},{"location":"lecture_08/theory/#Numerical-method","page":"Theory of regression and classification","title":"Numerical method","text":"","category":"section"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Denoting the loss function L(w), its partial derivative equals to","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"beginaligned\nfracpartial Lpartial w_j(w) = frac1nsum_i=1^nleft(-frac11+e^-w^top x_ie^-w^top x_ix_ij + (1-y_i)x_ij right) \n= frac1nsum_i=1^nleft(-frac11+e^w^top x_ix_ij + (1-y_i)x_ij right)\nendaligned","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"where x_ij is the j-th component of x_i. The second partial derivative amounts to","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"fracpartial^2 Lpartial w_j partial w_k(w) = frac1nsum_i=1^n frac1(1+e^w^top x_i)^2e^w^top x_ix_ijx_ik = frac1nsum_i=1^n hat y_i(1-hat y_i)x_ijx_ik","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Now we will write it in a more compact notation. We have","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"beginaligned\nnabla L(w) = frac1n sum_i=1^n left((hat y_i-1)x_i + (1-y_i)x_i right) = frac1n sum_i=1^n (hat y_i-y_i)x_i  \nnabla^2 L(w) = frac 1n sum_i=1^nhat y_i(1-hat y_i)x_i x_i^top\nendaligned","category":"page"},{"location":"lecture_08/theory/","page":"Theory of regression and classification","title":"Theory of regression and classification","text":"Note that if the fit is perfect, y_i=hat y_i, then the Jacobian nabla L(w) equals to zero which is precisely the optimality condition.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"using Plots","category":"page"},{"location":"lecture_07/theory/#Theory-of-optimization","page":"Theory of optimization","title":"Theory of optimization","text":"","category":"section"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"The goal of an optimization problem is to minimize of maximize a function f over a set X. Namely","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"    beginaligned\n    textminimizeqquad f(x) \n    textsubject toqquad xin X\n    endaligned","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Should we consider both minimization and maximization problems? No. Because","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"    textmaximizeqquad f(x)","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"is equivalent to ","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"    -textminimizeqquad -f(x)","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Therefore, it suffices to consider minimization problems.","category":"page"},{"location":"lecture_07/theory/#Gradients","page":"Theory of optimization","title":"Gradients","text":"","category":"section"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"As we will see later, gradients are crucial to optimization. For a function fmathbbRto mathbbR it is defined by","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"f(x) = lim_hto 0fracf(x+h)-f(x)h","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"For a mapping  fmathbbR^nto mathbbR^m, the Jacobian is a matrix nabla f(x) of size mtimes n which satisfies","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"    lim_hto 0fracf(x+h)-f(x) - nabla f(x)h h = 0","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"If a function f=(f_1dotsf_m) is differentiable, then","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"(nabla f(x))_ij = fracpartial f_ipartial x_j(x) = lim_hto 0fracf_i(x_1dotsx_j-1x_j+hx_j+1dotsx_n)-f(x_1dotsx_n)h","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"<div class = \"info-body\">\n<header class = \"info-header\">Confusion</header><p>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Gradient nabla f(x) of a function fmathbbR^ntomathbbR should be of size  1times n but it is commonly considered as ntimes 1.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"</p></div>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"To compute the gradient, the chain rule is crucial.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"<div class = \"theorem-body\">\n<header class = \"theorem-header\">Theorem: Chain</header><p>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Consider two differentiable functions fmathbbR^mtomathbbR^s and gmathbbR^ntomathbbR^m. Then its composition h(x) = f(g(x)) is differentiable with Jacobian","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"nabla h(x) = nabla f(g(x))nabla g(x)","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"</p></div>","category":"page"},{"location":"lecture_07/theory/#Unconstrained-optimization","page":"Theory of optimization","title":"Unconstrained optimization","text":"","category":"section"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"What do we look for when we minimize a function f over some X? The optimal point would be a global minimum, which is a point xin X which satisfies","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"f(x) le f(y) text for all yin X","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"This point is often very difficult to find. Sometimes we are able to find a local minimum, which is a global minimum on some small neighborhood of x.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"<div class = \"theorem-body\">\n<header class = \"theorem-header\">Theorem: Connection between optimization problems and gradients</header><p>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Consider a differentiable function f over X=mathbbR^n. If x is its local minimum, then nabla f(x)=0. Conversely, if f is convex, then every point x with nabla f(x)=0 is a global minimum of f.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"</p></div>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Points with nabla f(x)=0 are known as stationary points. Optimization algorithms often try to find them with the hope that they minimize the function f.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"(Image: )","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"<div class = \"info-body\">\n<header class = \"info-header\">Take care</header><p>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"This theorem does not hold if X is not the whole space.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"</p></div>","category":"page"},{"location":"lecture_07/theory/#Constrained-optimization","page":"Theory of optimization","title":"Constrained optimization","text":"","category":"section"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"The usual formulation of constrained optimization is in the form","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"tagP\nbeginaligned\ntextminimizeqquad f(x) \ntextsubject toqquad g_i(x) le 0 i=1dotsI \nh_j(x) = 0 j=1dotsJ\nendaligned","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"This optimization problem is also called the primal formulation. It is closely connected with the Lagrangian","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"L(xlambdamu) = f(x)  + sum_i=1^I lambda_i g_i(x) + sum_j=1^J mu_j h_j(x)","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Namely, it is simple to show that the primal formulation (P) is equivalent to","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"operatorname*minimize_xquad operatorname*maximize_lambdage 0muquad L(xlambdamu)","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"The dual problem then switches the minimize and maximize operators to arrive at","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"tagD operatorname*maximize_lambdage 0mu quadoperatorname*minimize_xquad L(xlambdamu)","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"<div class = \"info-body\">\n<header class = \"info-header\">Linear programming</header><p>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"The linear program","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"beginaligned\ntextminimizeqquad c^top x \ntextsubject toqquad Ax=b \nxge 0\nendaligned","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"is equivalent to","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"beginaligned\ntextmaximizeqquad b^top mu \ntextsubject toqquad A^top mule c\nendaligned","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"We can observe several things:","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Primal and dual problems switch minimization and maximization.\nPrimal and dual problems switch variables and constraints.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"</p></div>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"The optimality conditions for constrained optimization take a more complex form.","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"<div class = \"theorem-body\">\n<header class = \"theorem-header\">Theorem: Karush-Kuhn-Tucker conditions</header><p>","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"Let f, g_i and h_j be differentiable function and let a constraint qualification hold. If x is a local minimum of the primal problem (P), then there are lambdage 0 and mu such that","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"    beginaligned\n    textOptimality  nabla_x L(xlambdamu) = 0 \n    textFeasibility  nabla_lambda L(xlambdamu)le 0 nabla_mu L(xlambdamu) = 0 \n    textComplementarity  lambda^top g(x) = 0\n    endaligned","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"If f and g are convex and h is linear, then every stationary point is a global minimum of (P).","category":"page"},{"location":"lecture_07/theory/","page":"Theory of optimization","title":"Theory of optimization","text":"</p></div>","category":"page"},{"location":"howto/#How-to-use-special-html-elements","page":"How to...","title":"How to use special html elements","text":"","category":"section"},{"location":"howto/#Exercise","page":"How to...","title":"Exercise","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Some text that describes the exercise","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Solution","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"</p></details>","category":"page"},{"location":"howto/#Info","page":"How to...","title":"Info","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"<div class = \"info-body\">\n<header class = \"info-header\">???</header><p>","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Some info","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"</p></div>","category":"page"},{"location":"howto/#Homework","page":"How to...","title":"Homework","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"<div class = \"homework-body\">\n<header class = \"homework-header\">Homework</header><p>","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Homework text","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"</p></div>","category":"page"},{"location":"howto/#Theorem","page":"How to...","title":"Theorem","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"<div class = \"theorem-body\">\n<header class = \"theorem-header\">???</header><p>","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Some info","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"</p></div>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"using Plots\n\nf(x) = sin(x[1] + x[2]) + cos(x[1])^2\ng(x) = [cos(x[1] + x[2]) - 2*cos(x[1])*sin(x[1]); cos(x[1] + x[2])]\n\nxs = range(-3, 1, length = 40)\nys = range(-2, 1, length = 40)\nf_mod = (x, y) -> f([x; y])","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"f(x) = sin(x[1] + x[2]) + cos(x[1])^2\ng(x) = [cos(x[1] + x[2]) - 2*cos(x[1])*sin(x[1]); cos(x[1] + x[2])]","category":"page"},{"location":"lecture_07/numerical_methods/#Numerical-methods","page":"Numerical methods","title":"Numerical methods","text":"","category":"section"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"This part introduces the most basic optimization algorithm called gradient (or steepest) descent.","category":"page"},{"location":"lecture_07/numerical_methods/#Gradient-descent","page":"Numerical methods","title":"Gradient descent","text":"","category":"section"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"We learnt that the gradient is the direction of the steepest descent. The straightforward idea is to move in the opposite direction. This gives rise to the gradient descent algorithm","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"x^k+1 = x^k - alpha^knabla f(x^k)","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"The stepsize alpha^k0 can be tuned as a hyperparameter.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Gradient descent</header><p>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Implement function optim which takes function f, its gradient g, starting point x^0 and fixed stepsize alpha and runs the gradient descent. It should return first 100 iterations of the algorithm.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"This example is rather artificial because often only the last iteration is returned and some stopping criterion is employed instead of the fixed number of iterations.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"First we need to create an empty array into which we store the iterates. Then at every iteration we compute the gradient g(x), perform the update and save the new value of x. ","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"function optim(f, g, x, α; max_iter=100)\n    xs = zeros(length(x), max_iter+1)\n    xs[:,1] = x\n    for i in 1:max_iter\n        x -= α*g(x)\n        xs[:,i+1] = x\n    end\n    return xs\nend\nnothing # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"</p>\n</details>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Note that the implementation does not use the values of f but only of the gradient nabla f. Moreover, if the algorithm converges x^k to bar x, then passing the the limit in the gradient update results in nabla f(bar x)=0. Therefore, as most optimization methods, gradient descent looks for stationary points.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Gradient descent</header><p>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Use the implementation of the gradient descent to minimize the function","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"f(x) = sin(x_1 + x_2) + cos(x_1)^2","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"from the starting point x^0=(0-1) and constant stepsize alpha=01. Store all iterations into variable xs.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Plot again the contours pf f and all iterations xs.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Use one line of code to evaluate the function values for all iterations xs (hint: you need to iterate via eachcol(xs) or eachrow(xs) depending on how you repserent xs). Plot these values. ","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"We call optim written in the previous exercise. Then we plot the contours as before. Since x_gd[1,:] stores the x coordinate of all iterations and similarly x_gd[2,:], we plot them. Again, we need to use plot! instead of plot to add the line to the contour plot.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"x_gd = optim([], g, [0; -1], 0.1)\n\ncontourf(xs, ys, f_mod, color = :jet)\n\nplot!(x_gd[1,:], x_gd[2,:], line=(4,:black), label = \"\")\n\nsavefig(\"numer1.svg\") # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"This example is similar to [? for h in hs] encountered earlier. To iterate over all columns, we use [? for x in eachcol(x_gd)] and apply f(x) instead of ?. Another way is to iterate over indices instead of vectors and write [f(x_gs[:,i]) for i in 1:size(x_gd,2)].","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"f_gd = [f(x) for x in eachcol(x_gd)]\n\nplot(f_gd, label=\"\", xlabel=\"Iteration\", ylabel=\"Function value\")\n\nsavefig(\"numer2.svg\") # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"</p></details>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"(Image: )","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"(Image: )","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"The convergence looks very nice and the function value decreases. First, the decrease is faster but when the iterations get closer to the minimum, it slows down.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"What happens if we choose a different stepsize though? Let us try with two different values. First let us try alpha=001.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"x_gd = optim([], g, [0; -1], 0.01)\n\ncontourf(xs, ys, f_mod, color = :jet)\n\nplot!(x_gd[1,:], x_gd[2,:], line=(4,:black), label = \"\")\n\nsavefig(\"numer3.svg\") # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"(Image: )","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"We see that when the stepsize is reduced, the steps are shorter and we would need to increase the number of iterations (and thus time) to converge. When the stepsize is larger, say alpha=1, the situation is different. ","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"x_gd = optim([], g, [0; -1], 1)\n\ncontourf(xs, ys, f_mod, color = :jet)\n\nplot!(x_gd[1,:], x_gd[2,:], line=(4,:black), label = \"\")\n\nsavefig(\"numer4.svg\") # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"(Image: )","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"For a large stepsize, the algorithm gets close to the solution and then starts jumping around. If you further increase the stepsize, it will even diverge to infinite. Try it :)","category":"page"},{"location":"lecture_07/numerical_methods/#Adaptive-stepsize","page":"Numerical methods","title":"Adaptive stepsize","text":"","category":"section"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"To handle this numerical instability, safeguards were introduced. One of the possibilities is the Armijo condition which automatically select the stepsize. It looks for alpha^k which satisfies","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"f(x^k - alpha^knabla f(x^k)) le f(x^k) - c alpha^k nabla f(x^k)^2","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Here  cin(01) is a small contant, usually c=10^-4. Since the left-hand side is the function value at the new iterate x^k+1, the Armijo condition ensures that the sequence of function values is strictly decreasing. This prevents oscillations.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"The implementation of optim(f, g, x, α; max_iter=100) from the exercise above is rather stupid because it does not allow to modify the selection of the step. The simplest solution to this problem would be to include if conditions inside the function. However, this would result in a long function, which may be difficult to debug and modify. More elegant solution is to create an abstract class","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"abstract type Step end","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"and for each possible step selection method implement a optim_step method, which selects the step. First, we create the gradeint descent class GD as a subclass of Step by","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"struct GD <: Step\n    α::Real\nend","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"It is a structure with parameter α. Then we create the optim_step function by","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"optim_step(s::GD, f, g, x) = -s.α*g(x)\nnothing # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Due to the first input argument, it will be called only for the  GD stepsize. To access the parameter α, we need to retrieve it from the structure by s.α. Now we can modify the optim function by","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"function optim(f, g, x, s::Step; max_iter=100)\n    for i in 1:max_iter\n        x += optim_step(s, f, g, x)\n    end\n    return x\nend\nnothing # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Note that the input is s::Step which allows for any subclass of the abstract class Step. Using this implentation results in","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"gd = GD(0.1)\nx_opt = optim(f, g, [-1;0], gd)\nprintln(x_opt) # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"We obtained the same results as in the previous case. This is not surprising as the code does exactly the same things; it is only written differently. The next exercise shows the power of defining the Step class.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Armijo condition</header><p>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Implement the Armijo subclass of the Step class. It should have two parameters c from the definition and α_max which will be the initial value of alpha. The value alpha should be divided by two until the Armijo condition is satisfied.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Then run the optimization with the Armijo selection of the stepsize.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"We define the class in the same way as with GD","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"struct Armijo <: Step\n    c::Real\n    α_max::Real\nend","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"For the search for the stepsize, we first save the values for the function value f(x) and the gradient nabla f(x). If we do not do this, it will be recomputed at every step. Then we initialize the value of alpha and run the while loop until the Armijo condition is satisfied. We added a termination condition (also a safe check) α <= 1e-6 to prevent the loop for continuing indefinitely.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"function optim_step(s::Armijo, f, g, x)\n    fun = f(x)\n    grad = g(x)\n    α = s.α_max\n    while f(x .- α*grad) > fun - s.c*α*(grad'*grad)\n        α /= 2\n        if α <= 1e-6\n            warning(\"Armijo line search failed.\")\n            break\n        end\n    end\n    return -α*grad\nend\nnothing # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"Then we create the Armijo object and run the optimization again.","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"gd = Armijo(1e-4, 1)\nx_opt = optim(f, g, [-1;0], gd)\nnothing # hide","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"</p></details>","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"The correct solution is","category":"page"},{"location":"lecture_07/numerical_methods/","page":"Numerical methods","title":"Numerical methods","text":"println(round.(x_opt, digits=4)) # hide","category":"page"},{"location":"lecture_07/gradients/#Visualization-of-gradients","page":"Visualization of gradients","title":"Visualization of gradients","text":"","category":"section"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"For the numerical experiments, we will consider the following function","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"f(x) = sin(x_1 + x_2) + cos(x_1)^2","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"on domain -31times -21.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Contour plot</header><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Write a function g(x) which computes the derivative of f at a point  x.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Plot the contours of f on the given domain. Use the optional argument color = :jet for better visualization.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Function f(x) takes as an input a vector of two dimensions and returns a scalar. Therefore, the gradient is a two-dimensional vector, which we create by [?; ?]. Its components are computed from the chain rule. To plot, we need to use the Plots package, create the discretization xs and ys of both axis and then call the contourf function. Since the third argument of contourf requires a function of two variables, we need to modify f into f_mod.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"using Plots\n\nf(x) = sin(x[1] + x[2]) + cos(x[1])^2\ng(x) = [cos(x[1] + x[2]) - 2*cos(x[1])*sin(x[1]); cos(x[1] + x[2])]\n\nxs = range(-3, 1, length = 40)\nys = range(-2, 1, length = 40)\nf_mod = (x, y) -> f([x; y])\n\ncontourf(xs, ys, f_mod, color = :jet)\n\nsavefig(\"grad1.svg\") # hide","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></details>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"(Image: )","category":"page"},{"location":"lecture_07/gradients/#Computation-of-gradients","page":"Visualization of gradients","title":"Computation of gradients","text":"","category":"section"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"The simplest way to compute the gradients is to use a finite difference approximation. It replaces the limit in","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"f(x) = lim_hto 0fracf(x+h)-f(x)h","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"by fixing some h and approximates the gradient by","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"f(x) approx fracf(x+h)-f(x)h","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Finite difference approximation</header><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Write a function finite_difference which computes the approximation of f(x) by finite differences. The inputs are a function fmathbb Rtomathbb R and a point xinmathbbR. It should have an optional input hinmathbbR, for which you need to choose a reasonable value. ","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"We just need to rewrite the formula above. Since the argument h should be optional, it needs to be after ;. Its good default value is anything between 10^-10 and 10^-5. We specify x::Real as a sanity check for the case when a function of more variables is passed as input.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"finite_difference(f, x::Real; h=1e-8) = (f(x+h) - f(x)) / h\nnothing # hide","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></details>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"This way of computing the gradient has two diadvantages:","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"It is slow. For a function of n variables, we need to evaluate the function at least n+1 times to get the whole gradient.\nIt is not precise. We will show this in the next example.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Finite difference approximation</header><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Fix a point x=(-2-1) and compute the finite difference approximation of the partial derivative of f with respect to the second variable. Do this for h=10^k with k=-15dots-1. Plot the dependence of the approximation on the choice of h. Add the true derivative computed from g.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"To compute the partial derivative with respect to the second argument, we need to fix the first argument and vary only the second one. The resulting function is f_y.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"It is possible to use a for loop but there is a more efficient way. We first store all the values of h in hs. Then [? for h in hs] runs the function ? for all h in hs and stores the results in an array with the same size as hs. Since we need to get finite differences, the function ? will be replaced by finite_difference(f_y, -1; h=h).","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"The true gradient is computed by g([-2;1]) and returns an array of length two. Since we need only the partial derivative with respect to the second component, we need to select it by adding  [2].","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"It is possible to call plot twice. However, we concatenate the true gradient true_grad and its finite difference approximation fin_diff by hcat. It is also possible to use [? ?] (but not [?, ?] or [?; ?] -> try it). To get the same shape of the arrays, we need to repeat true_grad from a scalar to a vector of the same dimension as fin_diff. Since repeat requires the input to be an array, we need to create it by [true_grad].","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"f_y = x -> f([-2; x])\nhs = 10. .^(-15:-1)\nfin_diff = [finite_difference(f_y, -1; h=h) for h in hs]\ntrue_grad = g([-2,-1])[2]\n\nplot(hs, hcat(fin_diff, repeat([true_grad], length(fin_diff))),\n    xlabel = \"h\",\n    ylabel = \"Partial gradient wrt y\",\n    label = [\"Approximation\" \"True gradient\"],\n    xscale = :log10,\n)\n\nsavefig(\"grad2.svg\") # hide","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></details>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"(Image: )","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"We see that the approximation is good if the value h is not too small or too large. It cannot be too large because the definition of the gradient considers the limit to zero. It cannot be too small because then the numerical errors kick in. This is connected with machine precision, which is most vulnerable to the subtraction of two numbers of almost the same value. A simple example shows","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"(x + h)^2 - x^2 = 2xh + h^2","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"but the numerical implementation","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"x = 1;\nh = 1e-13;\n(x+h)^2 - x^2\n2*x*h + h^2","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"gives an error already on the third decimal point.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Finally, we show how the gradients look like.","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Direction of gradients</header><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"Plot the contours of f and its gradient at (-2-1).","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"We use the same functions as before. Since we want to add a line, we use plot! instead of plot. We specify the parameters of the line in an optional argument line = (:arrow, 4, :black). These parameters specify the pointed arrow, the thickness and the color of the line. Since we do not want any legend, we add label = \"\".","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"x = [-2; -1]\nx_grad = g(x)\n\ncontourf(xs, ys, (x, y) -> f([x; y]), color = :jet)\n\nplot!([x[1]; x[1]+0.25*x_grad[1]], [x[2]; x[2]+0.25*x_grad[2]],\n    line = (:arrow, 4, :black),\n    label = \"\",\n)\n\nsavefig(\"grad3.svg\") # hide","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"</p></details>","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"(Image: )","category":"page"},{"location":"lecture_07/gradients/","page":"Visualization of gradients","title":"Visualization of gradients","text":"The gradient is perpendicular to the contour lines. This makes perfect sense. Since the gradient is the direction of the steepest ascent and the contours have constant values, it needs to be like this. Try this with different values of x.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"n_digits = 4\nround_a(x::Number) = round(x, digits=n_digits)\nround_a(x) = round_a.(x)","category":"page"},{"location":"lecture_09/nn/#Neural-networks","page":"Neural networks","title":"Neural networks","text":"","category":"section"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We start with loading the iris dataset in the same way as last lecture.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"using BSON: @load\n\nfile_name = joinpath(\"data\", \"iris.bson\")\n@load file_name X y y_name","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Since we will use random function, we fix the seed. Since Julia uses one global seed (unlike Python, which uses different seeds in each package), we all should see the same results. However, if you obtain slightly different results, it may have happened due to a different Julia version or operating system.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"using Random\n\nRandom.seed!(666)\nnothing # hide","category":"page"},{"location":"lecture_09/nn/#Prepare-data","page":"Neural networks","title":"Prepare data","text":"","category":"section"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The first exercise splits the dataset into the training and testing set.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Write the split function, which splits the dataset and the labels into training and testing set. Include 80% of data in the training set and 20% of data in the testing set. Its input should be the dataset X and the labels y. It should have four outputs. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Since the input may have different forms, we assume that y is a vector and the samples of  X and y are across the first dimension. If this is not satisfied, the @assert statement returns an error. This is not necessary to include but it makes the code much more error-prone.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"To split the dataset, we first determine the number n_train in the training set. We need to round it and convert it to integer. To split, probably the best way is to create a random permumation of indeces and then select the first n_train as the indices of the training set and the remaining as the indices of the testing set.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"function split(X::AbstractMatrix, y::AbstractVector; ratio_train=0.8)\n    @assert size(X,1) == size(y,1)\n    \n    n = size(X,1)\n    n_train = Int.(round(ratio_train*n))\n    i_rand = randperm(n)\n    i_train = i_rand[1:n_train]\n    i_test = i_rand[n_train+1:end]\n\n    return X[i_train,:], y[i_train], X[i_test,:], y[i_test]\nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Then we split the dataset by calling the split function","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"X_train, y_train, X_test, y_test = split(X, y)\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The next exercises normalizes the data. In the previous lecture we have already normalized the training set. In this one, we will normalize the testing set as well. Since the testing data are not available during training, the testing data need to be normalized with the same constants as the training set.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Normalize the training and testing data so that each feature has zero mean and unit variance.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Print the first feature of the first sample in the testing set.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Since the features are in columns, we compute the mean and standard deviation of each column. However, using [??? for ??? in ???] creates a (column) vector and we need to transpose it. Otherwise it could not be broadcasted. Then we normalize the columns. Due to the reason mentioned above, we need to use the same normalizing constant for the training and testing sets.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"using Statistics\n\nfunction normalize(X_train, X_test)\n    col_means = [mean(X_col) for X_col in eachcol(X_train)]'\n    col_std = [std(X_col) for X_col in eachcol(X_train)]'\n\n    return (X_train .- col_means) ./ col_std, (X_test .- col_means) ./ col_std\nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Now we run the normalize function.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"X_train, X_test = normalize(X_train, X_test)\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The correct answer is","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"println(round_a(X_test[1,1])) # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The standard representation of data in linear or logistic regression is that each row (first dimension) is one sample. However, neural networks work with more dimensional data (each image is represented with three dimension). The convention changed and the samples are represented in the last dimension.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The next exercise modifies the data into a standard form for machine learning.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Modify the data so that the first dimension of X are features and the second one the samples.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Write onehot function which converts y into the one-hot representation. Write onecold function which converts the one-hot representation into the one-cold (original) represenation. Both these functions need to have two arguments, the second one will be classes which will equal to unique(y).","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Write a one-line check that both work correctly.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Finally, convert y into its one-hot representation.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We need to transpose X by X'. Since this creates an Adjoint type (check typeof(X')), we convert it to a standard matrix by calling Matrix(X').","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"X_train = Matrix(X_train')\nX_test = Matrix(X_test')\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The onehot function takes the one-hot representation of y as input. Then it determines all classes classes = unique(y) and cretes an array where the first dimension is the number of classes. Since all but one entries of each column will be zeros, we initialize it by zeros. Then we run a for loop to fill one into each column. We perform the for loop over all classes but it is also possible to perform it over all columns.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"function onehot(y, classes)\n    y_onehot = zeros(length(classes), length(y))\n    for i in 1:length(classes)\n        y_onehot[i,y.==classes[i]] .= 1\n    end\n    return y_onehot\nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The onehot function takes the one-cold representation of y as input. Then for each column y_col it finds the index of its maximum value (the only one) via the findmax function. This is repeated for every column to get the onehot function.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"onecold(y, classes) = [classes[findmax(y_part)[2]] for y_part in eachcol(y)]\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Functions onehot and onecold should be inverse to each other. That means that if we call them in succession, we obtain the original input. We could manually check","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"classes = unique(y)\n\nisequal(onecold(onehot(y, classes), classes), y)\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"but it is better to automatically perform this check by including the error message ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"!isequal(onecold(onehot(y, classes), classes), y) && error(\"Function onehot or onecold is wrong.\") \nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Now, the modification of  the labels is straigforward. As in the case of the matrix, we need to modify the splitted data. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"y_train = onehot(y_train, classes)\ny_test = onehot(y_test, classes)\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Preparing the data is at seven lines. It is better to combine it into one function","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"function prepare_data(X, y; do_normal=true, kwargs...)\n    X_train, y_train, X_test, y_test = split(X, y; kwargs...)\n\n    if do_normal\n        X_train, X_test = normalize(X_train, X_test)\n    end\n\n    X_train = Matrix(X_train')\n    X_test = Matrix(X_test')\n\n    classes = unique(y)\n\n    y_train = onehot(y_train, classes)\n    y_test = onehot(y_test, classes)\n\n    return X_train, y_train, X_test, y_test, classes\nend","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Then all the code so far, can be summarized in just three lines.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"file_name = joinpath(\"data\", \"iris.bson\")\n@load file_name X y y_name\n\nX_train, y_train, X_test, y_test, classes = prepare_data(X, y)","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Writing function prepare_data as above has other advantages, we will get back to them in the exercises.","category":"page"},{"location":"lecture_09/nn/#Create-the-network","page":"Neural networks","title":"Create the network","text":"","category":"section"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We will now construct a simple neural network. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Construct the following network:","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The first layer is a dense layer with the relu activation function.\nThe second layer is a dense layer with identity activation function.\nThe third layer is the softmax. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Write is as m(x, ???), where x is the input and ??? stands for all weights.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The dense layer is just a linear function z1 = W1*x .+ b1 followed by an activation function. If we assume that x is a vector, then + would work the same as .+ as both W1*x and b are of the same dimension. However, if we want x to be a matrix (each columns corresponds to one sample), then we need to write .+ because W1*x is a matrix and the vector b needs to be broadcasted. The activation function is a relu which needs to be applied componentwise. The second layer is the same but this time, we need to finish it with a softmax. This is similar to the sigmoid but it is normalized and may contain multiple inputs (in the case of more classes). If x is a matrix, then z2 is a matrix and we need to specify that we want to normalize along the first dimension. If we assume only for one-sample inputs, then specifying the dimension is not necessary.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"function m(x, W1, b1, W2, b2)\n    z1 = W1*x .+ b1\n    a1 = max.(z1, 0)\n    z2 = W2*a1 .+ b2\n    a2 = exp.(z2) ./ sum(exp.(z2), dims=1)\nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Before we can use one of the numerical methods from the previous lectures to train the neural network, we need to initialize the weights.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Initialize all the weights randomly following the standard normal distribution. The first layer should have 5 hidden (output) neurons. You need to specify the number of neurons for the other layers correctly.  ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Evaluate the model m for the first datum from the training set.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We write a simple initialize function which takes the number of neurons in each layer as input and randomly generates the matrices. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"function initialize(n1, n2, n3)\n    W1 = randn(n2,n1)\n    b1 = randn(n2)\n    W2 = randn(n3,n2)\n    b2 = randn(n3)\n    return W1, b1, W2, b2\nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"To initialize, we need to realize the numbers n1, n2 and n3. The first one is the number of features, the second one is specified to be 5 and the last one must equal to the number of classes (the length of the labels in the one-hor representation).","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"W1, b1, W2, b2 = initialize(size(X_train,1), 5, size(y_train,1))\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"To evaluate the model, we call the m function with the first sample in the training set","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"m(X_train[:,1], W1, b1, W2, b2)\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The correct answer is","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"println(round_a(m(X_train[:,1], W1, b1, W2, b2))) # hide","category":"page"},{"location":"lecture_09/nn/#Train-the-network","page":"Neural networks","title":"Train the network","text":"","category":"section"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"To train, we need to compute the gradients. It is rather complicated, it can be written as follows. When going through the code, it becomes clear that it is just a different form of the chain rule derived in the theoretical part.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"function grad(x::AbstractVector, y, W1, b1, W2, b2; ϵ=1e-10)\n    z1 = W1*x .+ b1\n    a1 = max.(z1, 0)\n    z2 = W2*a1 .+ b2\n    a2 = exp.(z2) ./ sum(exp.(z2))\n    l = -sum(y .* log.(a2 .+ ϵ))\n\n    e_z2 = exp.(z2)\n    l_part = (- e_z2 * e_z2' + Diagonal(e_z2 .* sum(e_z2))) / sum(e_z2)^2\n\n    l_a2 = - y ./ (a2 .+ ϵ)\n    l_z2 = l_part * l_a2 \n    l_a1 = W2' * l_z2\n    l_z1 = l_a1 .* (a1 .> 0)\n    l_x = W1' * l_z1\n\n    l_W2 = l_z2 * a1'\n    l_b2 = l_z2\n    l_W1 = l_z1 * x'\n    l_b1 = l_z1\n\n    return l, l_W1, l_b1, l_W2, l_b2\nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The function returns the function value l and derivatives with respect to all four variables.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"info-body\">\n<header class = \"info-header\">That's it? I thought neural networks are magic...</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Well, for a network with two layers and a loss, you can compute the function value and its derivative with only 16 lines of code. And it could be even shorter :)","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"info-body\">\n<header class = \"info-header\">Simple implementation</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The previous function grad can compute the gradient for only one sample and not for more. Since the objective in training neural network is a mean over all samples, this mean needs to be included externally. This is NOT the correct way of writing function. However, we decided to present it in the current way to keep the presentation (relatively) simple.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Any time when a simplication like this is included in the code, a check such as x::AbstractVector or an @assert statement should be included to prevent unexpected errors.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Having the gradient at hand, we can finally train the network.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Train the network with a gradient descent with stepsize alpha=01 for 1000 iterations. Save the objective value at each iteration and plot the results.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Due to the simple way of the grad function, calling grad(X_train[:,k], y_train[:,k], W1, b1, W2, b2) returns a tuple of five objects. We can use the standard trick to create an array of such tuples by going through all columns [grad(X_train[:,k], y_train[:,k], W1, b1, W2, b2) for k in 1:size(X_train,2)]. To obtain a mean from this array, we write the mean_tuple function. To make sure that everything is correct, we specify the input type. If d is the input data, then d[k] is an element of the array while d[i][k] is an element of the tuple. Therefore, the inner for loop needs to be with respect to k while the outer one with respect to i. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"using LinearAlgebra\nusing Statistics\n\nmean_tuple(d::AbstractArray{<:Tuple}) = [mean([d[k][i] for k in 1:length(d)]) for i in 1:length(d[1])]","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Now the process is simple. We compute the gradient grad_all, then its mean grad_mean via the already written function mean_tuple. The first value of the tuple grad_mean is the objective, the remaining are gradient. Thus, we save the first value to an array and use the remaining one to update the weights.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"α = 1e-1\nmax_iter = 1000\nL = zeros(max_iter)\n@time for iter in 1:max_iter\n    grad_all = [grad(X_train[:,k], y_train[:,k], W1, b1, W2, b2) for k in 1:size(X_train,2)]\n    grad_mean = mean_tuple(grad_all)\n\n    L[iter] = grad_mean[1]\n    \n    W1 .-= α*grad_mean[2]\n    b1 .-= α*grad_mean[3]\n    W2 .-= α*grad_mean[4]\n    b2 .-= α*grad_mean[5] \nend\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We used the @time macro to measure the time. Try to use @showprogress from the ProgressMeter.jl package. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"using Plots # hide\nplot(L, xlabel=\"iteration\", ylabel=\"loss function\", label=\"\", title=\"Loss function on the training set\") # hide\nsavefig(\"loss.png\") # hide\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"(Image: )","category":"page"},{"location":"lecture_09/nn/#Prediction","page":"Neural networks","title":"Prediction","text":"","category":"section"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We have trained our first network. We saw that the loss function keeps decreasing, which is a good sign of a good training procedure. Now we will evaluate the performance.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"Write a function which predict the labels for samples. Show the accuracy on both training and testing sets. ","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The predicted probabilities are obtained by using the m function. The prediction (highest predicted probability) is obtain by converting the one-hot representation into the one-cold representation. Finally, the accuracy compute in how many cases the prediction equals to the label.","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"predict(X) = m(X, W1, b1, W2, b2)\naccuracy(X, y) = mean(onecold(predict(X), classes) .== onecold(y, classes))\n\nprintln(\"Train accuracy = $(accuracy(X_train, y_train))\")\nprintln(\"Test accuracy = $(accuracy(X_test, y_test))\")\n\nnothing # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"</p></details>","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"The correct answer is","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"println(\"Train accuracy = $(round_a(accuracy(X_train, y_train)))\") # hide\nprintln(\"Test accuracy = $(round_a(accuracy(X_test, y_test)))\") # hide","category":"page"},{"location":"lecture_09/nn/","page":"Neural networks","title":"Neural networks","text":"We see that the testing accuracy is smaller than the training one. This is quite a common phnomenon which is named overfitting. The problem is that the algorithm sees only the data from the training set. If it fits this data \"too perfectly\", it is not able to generalize into unseen samples (the testing set). We will discuss this in one of the exercises.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"using Plots\nusing BSON\nusing BSON: @load\nusing Statistics\nusing LinearAlgebra\n\nfunction modify_data(X, y, y_name)\n    ii = y .> 1.5\n    return X[ii,3:4], y[ii] .> 2.5, y_name[2:3]\nend\n\nfile_name = joinpath(\"data\", \"iris.bson\")\n@load file_name X y y_name\n\nX, y, y_name = modify_data(X, y, y_name)\n\nfunction log_reg(X, w; max_iter=100)\n    X_mult = [row*row' for row in eachrow(X)]\n    for i in 1:max_iter\n        y_hat = 1 ./(1 .+exp.(-X*w))\n        grad = X'*(y_hat.-y) / size(X,1)\n        hess = y_hat.*(1 .-y_hat).*X_mult |> mean\n        w -= hess \\ grad\n    end\n    return w\nend\n\nX_ext = hcat(X, repeat([1],size(X,1)))\nw = log_reg(X_ext, zeros(size(X_ext,2)))","category":"page"},{"location":"lecture_08/exercises/#Exercises","page":"Exercises","title":"Exercises","text":"","category":"section"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"homework-body\">\n<header class = \"homework-header\">Homework: Data normalization</header><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Data are often normalized. Each feature subtracts its mean and then divides the result by its standard deviation. The normalized features have zero mean and unit standard deviation. This may help in several cases:","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"It may help when each feature has different order of dimension (such as milimeters and kilometers). Then the gradient would ignore the feature with the smaller values.\nIt may help with problems described in Exercise 4.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Write a function normalize which takes as an input a dataset and normalizes it. Do you see any differences with the input is the original and normalized dataset when","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"the linear regression is optimized via the gradient descent?\nthe logistic regression is optimized via the Newton's method?","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Do you have any intuition as to why?","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 1</header><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Show the details for the derivation of the logistic regression.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Since hat y equals the probability of predicting 1, we have","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"hat y = frac11+e^-w^top x","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Then the cross-entropy loss reduces to","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\noperatornameloss(yhat y) = - ylog hat y - (1-y)log(1-hat y) \n= ylog(1+e^-w^top x) - (1-y)log(e^-w^top x) + (1-y)log(1+e^-w^top x) \n= log(1+e^-w^top x) + (1-y)w^top x\nendaligned","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Then it remains to sum this term over all samples.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 2</header><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Show that if the Newton's method converge for the logistic regression, then it found a point globally minimizing the logistic loss. ","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"We derived that the Hessian of the objective function for logistic regression is","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"nabla^2 L(w) = frac 1n sum_i=1^nhat y_i(1-hat y_i)x_i x_i^top","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"For any vector a, we have","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"a^top x_i x_i^top a = (x_i^top a)^top (x_i^top a) = x_i^top a^2 ge 0","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"which implies that x_i x_i^top is a positive semidefinite matrix (it is known as rank-1 matrix as its rank is always 1 if x_i is a non-zero vector). Since y_i(1-hat y_i)ge 0, it follows that nabla^2 L(w) is a positive semidefinite matrix. If a Hessian of a function is positive semidefinite everywhere, the function is immediately convex.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 3</header><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"The logistic regression on the iris dataset failed in 6 out of 100 samples. But the visualization shows the failure only in 5 cases. How is it possible?","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"We use the same code as before and find indices of the miclassified samples","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"y_hat = 1 ./(1 .+exp.(-X_ext*w))\npred = y_hat .>= 0.5\nii = findall(pred .!= y)\n\nnothing # hide","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Then we show the values of the data and labels at these indices. We sort the rows by sortslices. You cannot use sort as it would not sort rows but it would perform the sorting operator on every column independently.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"aux = hcat(X[ii,:], y[ii])\nsortslices(aux, dims=1)","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"A short look at the image shows that the point (48 18) is misclassified but the image shows it correctly. Let us show all such points","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"ii = findall((X[:,1].==4.8) .& (X[:,2].==1.8))\naux = hcat(X[ii,:], y[ii])","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"As we can see, there are three samples with the same data. Two of them have label 1 and one label 0. Since the incorrectly classified sample wa redrawn, it was not possible to see it.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 4: Why not use sigmoid</header><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Show that the Newton's method fail when started from the vector (123). Can you guess why it happened? What are the consequences for optimization? Is gradient descent going to suffer from the same problems?","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"First, we run the logistic regression as before, only with a different starting point","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"log_reg(X_ext, [1;2;3])","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"This resulted in NaNs.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"When something fail, it may be a good idea to run a step-by-step analysis. In this case, we will make one iteration of the Newton's method","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"w = [1;2;3];\nX = X_ext;\nX_mult = [row*row' for row in eachrow(X)];\ny_hat = 1 ./(1 .+exp.(-X*w))\ngrad = X'*(y_hat.-y) / size(X,1)\nhess = y_hat.*(1 .-y_hat).*X_mult |> mean\nw -= hess \\ grad","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Starting from bottom, we can see that even though we started with relatively small w, the next iteration is four degrees of magnitude larger. This happened because the Hessian hess is much smaller than the gradient grad. This indicated that there is some kind of numerical instability. The prediction y_hat should be distribution in the interval 01 but it seems that it is almost always close to 1. Let us verify this my showing the extrema of y_hat","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"extrema(y_hat)","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"They are indeed too large.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"Now we explain the reaosn. We know that the prediction equals to","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"hat y_i = sigma(w^top x_i)","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"where sigma is the sigmoid function. Since the mimimum from w^top x_i","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"minimum(X*[1;2;3])","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"is large, all w^top x_i are large. But plotting the sigmoid funtion","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"σ(z) = 1/(1+exp(-z))\nxs = -10:0.01:10\nplot(xs, σ.(xs), label=\"\", ylabel=\"Sigmoid function\")\n\nsavefig(\"sigmoid.svg\") # hide","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"it is clear that all w^top x_i hit the part of the sigmoid which is flat. This means that derivative is zero and the Hessian is even smaller zero. Then the ratio of the gradient and Hessian is huge as we observed above.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"The gradient descent will probably run into the same difficulty. Since the gradient will be too small, it will take a very large number of iteration for sigmoid to escape the flat region.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"This is a known problem of the sigmoid function. It is also the reason why it was replaced in neural networks by other functions.","category":"page"},{"location":"lecture_08/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"n_digits = 4\nround_a(x::Number) = round(x, digits=n_digits)\nround_a(x) = round_a.(x)\n\nusing BSON: @load\n\nfile_name = joinpath(\"data\", \"iris.bson\")\n@load file_name X y y_name\n\nusing Random\n\nRandom.seed!(666)\n\nfunction split(X::AbstractMatrix, y::AbstractVector; ratio_train=0.8)\n    @assert size(X,1) == size(y,1)\n    \n    n = size(X,1)\n    n_train = Int.(round(ratio_train*n))\n    i_rand = randperm(n)\n    i_train = i_rand[1:n_train]\n    i_test = i_rand[n_train+1:end]\n\n    return X[i_train,:], y[i_train], X[i_test,:], y[i_test]\nend\n\nusing Statistics\n\nfunction normalize(X_train, X_test)\n    col_means = [mean(X_col) for X_col in eachcol(X_train)]'\n    col_std = [std(X_col) for X_col in eachcol(X_train)]'\n\n    return (X_train .- col_means) ./ col_std, (X_test .- col_means) ./ col_std\nend\n\nfunction onehot(y, classes)\n    y_onehot = zeros(length(classes), length(y))\n    for i in 1:length(classes)\n        y_onehot[i,y.==classes[i]] .= 1\n    end\n    return y_onehot\nend\n\nonecold(y, classes) = [classes[findmax(y_part)[2]] for y_part in eachcol(y)]\n\nfunction m(x, W1, b1, W2, b2)\n    z1 = W1*x .+ b1\n    a1 = max.(z1, 0)\n    z2 = W2*a1 .+ b2\n    a2 = exp.(z2) ./ sum(exp.(z2), dims=1)\nend\n\nloss(y_hat, y; ϵ=1e-10) = -sum(y .* log.(y_hat .+ ϵ), dims=1)\n\nfunction initialize(n1, n2, n3)\n    W1 = randn(n2,n1)\n    b1 = randn(n2)\n    W2 = randn(n3,n2)\n    b2 = randn(n3)\n    return W1, b1, W2, b2\nend\n\nfunction grad(x::AbstractVector, y, W1, b1, W2, b2; ϵ=1e-10)\n    z1 = W1*x .+ b1\n    a1 = max.(z1, 0)\n    z2 = W2*a1 .+ b2\n    a2 = exp.(z2) ./ sum(exp.(z2))\n    l = loss(a2, y; ϵ=ϵ)\n\n    e_z2 = exp.(z2)\n    l_part = (- e_z2 * e_z2' + Diagonal(e_z2 .* sum(e_z2))) / sum(e_z2)^2\n\n    l_a2 = - y ./ (a2 .+ ϵ)\n    l_z2 = l_part * l_a2 \n    l_a1 = W2' * l_z2\n    l_z1 = l_a1 .* (a1 .> 0)\n    l_x = W1' * l_z1\n\n    l_W2 = l_z2 * a1'\n    l_b2 = l_z2\n    l_W1 = l_z1 * x'\n    l_b1 = l_z1\n\n    return l, l_W1, l_b1, l_W2, l_b2\nend\n\nusing LinearAlgebra\nusing Statistics\n\nmean_tuple(d::AbstractArray{<:Tuple}) = [mean([d[k][i] for k in 1:length(d)]) for i in 1:length(d[1])]\n\npredict(X) = m(X, W1, b1, W2, b2)\naccuracy(X, y) = mean(onecold(predict(X), classes) .== onecold(y, classes))","category":"page"},{"location":"lecture_09/exercises/#Exercises","page":"Exercises","title":"Exercises","text":"","category":"section"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"homework-body\">\n<header class = \"homework-header\">Homework: Optimal setting</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Perform an analysis of hyperparameters of the neural network such as network architecture, learning rate (stepsize), activation function or normalization.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Write a short summary of your suggestions.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 1: Universal approximation of neural networks</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Proof the theorem about universal approximation of neural networks.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Since piecewise linear functions are compact in continuous functions, there is a piecewise linear function h such that h-g_inftyle varepsilon. Assume that h has kinks at x_1dotsx_n with function values h(x_i)=y_i for i=1dotsn. Definiting","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"d_i = fracy_i+1-y_ix_i+1-x_i","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"then h has the form","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"h(x) = y_i + d_i(x-x_i) qquadtext for xin x_ix_i+1","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"It is not difficult to show that","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"h(x) = y_1 + sum_i=1^n(d_i-d_i-1)operatornamemaxx-x_i0","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"where we defined d_0=0.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Then h can be represented as the following network with two layers:","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Dense layer with n hidden neurons and ReLU activation function. Neuron i has weight 1 and bias -x_i.\nDense layer with 1 ouput neurons and identity activation function. Connection i has weight d_i-d_i-1 and the joint bias isy_1.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"This finishes the proof.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 2: Keyword arguments</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Keyword arguments (often denoted as kwargs... but any name may be used) specify additional arguments which do not need to be speficied by its name in function declaration. We recall the prepare_data function which we wrote earlier.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"function prepare_data(X, y; do_normal=true, kwargs...)\n    X_train, y_train, X_test, y_test = split(X, y; kwargs...)\n\n    if do_normal\n        X_train, X_test = normalize(X_train, X_test)\n    end\n\n    X_train = Matrix(X_train')\n    X_test = Matrix(X_test')\n\n    classes = unique(y)\n\n    y_train = onehot(y_train, classes)\n    y_test = onehot(y_test, classes)\n\n    return X_train, y_train, X_test, y_test, classes\nend\nnothing # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"All the keyword argumetns will be passed to the split function. They could also be passde to normalize or any other function. The benefit is that we do not need to specify the keyword arguments for split in prepare_data.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Recall that split takes ratio_split as an optional argument. Write an one-line function ratio_train which gets the training and testing sets and computes the ratio of samples in the training set. Then call the prepare_data with:","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"no normalization and default split ratio;\nnormalization and split ratio of 50/50;\nno normalization and split ratio of 50/50.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"The ratio_train function reads","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"ratio_train(X_train, X_test) = size(X_train, 2) / (size(X_train,2) + size(X_test,2))\nnothing # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"For the first call, we want to use the default ratio, hence we do not pass ratio_split. Since we want do not want to use normalization, we need to pass do_normal=false.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"X_train, y_train, X_test, y_test, classes = prepare_data(X, y; do_normal=false)\nprintln(\"Ratio train/test = \" * string(ratio_train(X_train, X_test)))","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"For the second call, it is the other way round. We use the default normalization, thus we do not need to specify do_normal=true (even though it may be a good idea to do so). We need to pass ratio_train=0.5.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"X_train, y_train, X_test, y_test, classes = prepare_data(X, y; ratio_train=0.5)\nprintln(\"Ratio train/test = \" * string(ratio_train(X_train, X_test)))","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"For the final call, we need to use both arguments. Note that  do_normal is passed an optional argument and therefore, its default value will be overwritten while ratio_train is passed in kwargs and goes into the split function.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"X_train, y_train, X_test, y_test, classes = prepare_data(X, y; do_normal=false, ratio_train=0.5)\nprintln(\"Ratio train/test = \" * string(ratio_train(X_train, X_test)))","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 3: Showing the contours</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"The goal of this exercise will be to show the separation graphically. For this reason, we need to consider only two features. The description may be a bit unclear. If you are uncertain, check the correct answer and try to reproduce the graph.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"First, use the same data and the same training procedure as during lecture with the exception that we will consider only the last two features of X. Train the network with five hidden neurons.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Second, write a function rectangles(x, y, r) where x and y are vectors of the same size and r is a positive number. It should return two outputs of size (5,n) where n is length of x and y. Column i of the outputs forms the edges of the rectangle with center (x[i],y[i]) and length 2r. The first and second outputs correspond to x and y coordinates, respectively. For plotting, the outputs need to have five edges (instead of four), where the first and the last one are the same.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Thirs, create a uniform discretization of -22times -22 with grid 01 and convert it into rectangles using the rectangle function. Assign one of three colours (blue, red, green) to each rectangle based on the prediction of its center. Plot all rectangle using the corresponding colour. Use fill=(0,0.2,???), where ??? is the colour. Finally, using the scatter plot, show the testing data in the same colours.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"The procedure for training the network is the same as during the lecture","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"X_train, y_train, X_test, y_test, classes = prepare_data(X[:,3:4], y)\n\nW1, b1, W2, b2 = initialize(size(X_train,1), 5, size(y_train,1))\n\nα = 1e-1\nmax_iter = 1000\nfor iter in 1:max_iter\n    grad_all = [grad(X_train[:,k], y_train[:,k], W1, b1, W2, b2) for k in 1:size(X_train,2)]\n    grad_mean = mean_tuple(grad_all)\n\n    W1 .-= α*grad_mean[2]\n    b1 .-= α*grad_mean[3]\n    W2 .-= α*grad_mean[4]\n    b2 .-= α*grad_mean[5] \nend\n\nnothing # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"For the rectangles function, we first create realize that if a rectangle is centered at zero, its x and y coordinates are [-r; r; r; -r; -r] and [-r; -r; r; r; -r], respectively. Then we reshape the input x vector into a row vector and move the rectangle derived above into the proper center. Note that the implementation adds a column vector reshape(x, 1, :) and a row vector [-r; r; r; -r; -r]. The result is a matrix with an appropriate dimension.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"function rectangles(x::AbstractVector, y::AbstractVector, r::Number)\n    xs = reshape(x, 1, :) .+ [-r; r; r; -r; -r]\n    ys = reshape(y, 1, :) .+ [-r; -r; r; r; -r]\n    return xs, ys\nend\n\nnothing # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"To create the discretization, we first discretize the x axis via x = collect(-2:x_diff:2). To get the grid, we then create all combinations of x with x. To have a proper dimension for the neural network, it should be dimension (1,n^2). Finally, we evaluate all these points via the model m and convert the one-hot into the one-cold representation.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"x_diff = 0.1\nx = collect(-2:x_diff:2)\nn = length(x)\nxy = hcat(repeat(x, n, 1), repeat(x', n, 1)[:])'\nz = m(xy, W1, b1, W2, b2)\nz = onecold(z, classes)\n\nnothing # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Finally, for plotting, we first define the three colours as three symbols. Then we create a loop over all three classes. In the first plot, we need to call plot while in the remaining ones, we call plot!. For each predicted class, we find the indices with the predicted class z.==classes[i] and plot the corresponding rectangles. Besides the fill parameter, we specify the line as well via line. For the prediction on the testing set, we repeat the same procedure. This time the indices are found by onecold(y_test, classes) .== classes[i] and we use the scatter plot. We specify the marker for a better visualization.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"using Plots\n\ncolours = (:blue, :red, :green)\n\nfor i in 1:length(classes)\n    i == 1 ? p = plot : p = plot!\n    ii1 = z .== classes[i]\n    ii2 = onecold(y_test, classes) .== classes[i]\n    p(rectangles(xy[1,ii1], xy[2,ii1], x_diff/2)..., line=(0, 0.2, colours[i]), fill=(0, 0.2, colours[i]), label=\"\")\n    scatter!(X_test[1,ii2][:], X_test[2,ii2][:], marker=(8, 0.8, colours[i]), label=y_name[classes[i]], legend=:topleft)\nend\n\nsavefig(\"Separation.png\") # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 4: Overfitting</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"This exercise will show the well-known effect of overfitting. Since the model sees only the testing set, it may happen that it fits it too perfectly (overfits it) and generalizes poorly to unseen examples (testing set).","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"As in the previous exercise, consider only the last two features and train the network with 50 hidden neurons for 5000 iterations. Plot the evolution of the objective (loss) function on the training and testing sets.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Make two countour plots as in the previous exercise. The first one depicts the scatter plot for the testing set while the second one depicts it for the training set. Describe what went wrong.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"The first part of the exercise is the same as before. The only change is that we need to save the training and testing objective. Note that the training loss could be extracted from grad_all. ","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"X_train, y_train, X_test, y_test, classes = prepare_data(X[:,3:4], y)\n\nW1, b1, W2, b2 = initialize(size(X_train,1), 50, size(y_train,1))\n\nα = 1e-1\nmax_iter = 5000\nL_train = zeros(max_iter)\nL_test = zeros(max_iter)\nfor iter in 1:max_iter\n    grad_all = [grad(X_train[:,k], y_train[:,k], W1, b1, W2, b2) for k in 1:size(X_train,2)]\n    grad_mean = mean_tuple(grad_all)\n    \n    W1 .-= α*grad_mean[2]\n    b1 .-= α*grad_mean[3]\n    W2 .-= α*grad_mean[4]\n    b2 .-= α*grad_mean[5] \n\n    L_train[iter] = mean(loss(m(X_train, W1, b1, W2, b2), y_train)[:])\n    L_test[iter] = mean(loss(m(X_test,  W1, b1, W2, b2), y_test)[:])\nend","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Then we plot it. We ignore the first nine iterations. ","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"plot(L_train[10:end], xlabel=\"Iteration\", label=\"Training loss\", legend=:topleft)\nplot!(L_test[10:end], label=\"Testing loss\")\n\nsavefig(\"Train_test.png\") # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"We see the classical procedure of overfitting. While the loss function on the training set decreases steadily, on the testing set, it decreases first and after approximately 100 iterations, it starts increasing. This behaviour may be prevented by several techniques which we discuss in the next lecture. ","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"We create the contour plot in the same way as in the previous exercise.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"z = m(xy, W1, b1, W2, b2)\nz = onecold(z, classes)\n\nfor i in 1:length(classes)\n    i == 1 ? p = plot : p = plot!\n    ii1 = z .== classes[i]\n    ii2 = onecold(y_test, classes) .== classes[i]\n    p(rectangles(xy[1,ii1], xy[2,ii1], x_diff/2)..., line=(0, 0.2, colours[i]), fill=(0, 0.2, colours[i]), label=\"\", title=\"Testing set\")\n    scatter!(X_test[1,ii2][:], X_test[2,ii2][:], marker=(8, 0.8, colours[i]), label=y_name[classes[i]], legend=:topleft)\nend\nsavefig(\"Over1.png\") # hide\n\nfor i in 1:length(classes)\n    i == 1 ? p = plot : p = plot!\n    ii1 = z .== classes[i]\n    ii2 = onecold(y_train, classes) .== classes[i]\n    p(rectangles(xy[1,ii1], xy[2,ii1], x_diff/2)..., line=(0, 0.2, colours[i]), fill=(0, 0.2, colours[i]), label=\"\", title=\"Training set\")\n    scatter!(X_train[1,ii2][:], X_train[2,ii2][:], marker=(8, 0.8, colours[i]), label=y_name[classes[i]], legend=:topleft)\nend\n\nsavefig(\"Over2.png\") # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"We see that the separation on the testing set is very good but it could be better for the two bottommost green circles (iris virginica). The model predicted (in background) the red color (iris versicolor) there. This is wrong. The reason is clear from the picture depicting the training set. The classifier tried to fit perfectly the boundary between the green and red points, making a outward-pointing tip there from otherwise a rather flat boundary. This is precisely overfitting and the reason of the misclassification on the testing set.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"plot(L_train, xlabel=\"Iteration\", label=\"Training loss\", legend=:topleft) # hide\nplot!(L_test, label=\"Testing loss\") # hide\n\nsavefig(\"Train_test0.png\") # hide","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"(Image: )","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 5: Generalization</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Compare the contour plots from Exercises 2 and 3. They are strikingly different, especially in the top-left and bottom-right corners. Why is that?","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"Since the dataset does not contain any data in the top-left or bottom-right corners, it does not know what to put there. From its perspective, both separations are very good. This raises an important take-away message.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"info-body\">\n<header class = \"info-header\">Generalization</header><p>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"If a classifier does not have any data in some region, it may predict anything there. Including predictions with no sense.","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>","category":"page"},{"location":"lecture_09/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_01/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"In Julia (as in other languages), a variable is a name that refers to a value. Contrary to languages like C or C++ and similar to Python or MATLAB, variables can be created without the type specification, i.e. variable can be declared simply by using = sign:","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> x = 2\n2","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"The type of the object is inferred automatically and can be checked using typeof function:","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> typeof(x)\nInt64","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"In this case, the variable x is of type Int64, which is a type that represents signed integers. Since x is a number, we can apply basic mathematical operations to it:","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> y = x + 1\n3\n\njulia> typeof(y)\nInt64","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"The type of the variable x is preserved because the sum of two integers is also an integer. We can also reuse the variable name x and assign a new value to it","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> x = 4\n4","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"The type of the variable x is still Int64, but it is also possible to assign a value of a different type to x","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> x = 3.1415\n3.1415\n\njulia> typeof(x)\nFloat64","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"In this case, the variable x is of type Float64, which is a type that represents floating-point numbers.","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Create the following variables:","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Variable x with value 1.234.\nVariable y with value 1//2.\nVariable z with value x + y*im.","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"What are the types of these three variables?","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"All three variables can be declared simply by assigning the value to the given variable name","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> x = 1.234\n1.234\n\njulia> y = 1//2\n1//2\n\njulia> z = x + y*im\n1.234 + 0.5im","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"and types can be checked using the typeof function","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> typeof(x)\nFloat64\n\njulia> typeof(y)\nRational{Int64}\n\njulia> typeof(z)\nComplex{Float64}","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"</p></details>","category":"page"},{"location":"lecture_01/variables/#Primitive-numeric-types","page":"Variables","title":"Primitive numeric types","text":"","category":"section"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"There is a huge amount of types in Julia. In fact, every object in Julia has its type. As an example, we can mention the hierarchy of primitive numeric types","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"<img src=\"types.svg\" width=\"100%\"/>","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"⠀","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"All types shown in blue are abstract types, i.e. it is not possible to create an instance of such a type. Abstract types are useful for creating logical type hierarchy. Types highlighted in green are concrete types. In many cases, it is useful to have the choice to choose which type to use. As an example, we can see floating-point numbers. There are four concrete types for floating-point numbers. If we want to maximize the precision of some calculations, we can use BigFloat. Using BigFloat increases precision but also increases computational time. On the other hand, if we want to speed up the code, we can use the type with lower precision such as Float32. But in most cases, the user does not have to take care of types at all. But in most cases, the user does not have to take care of types at all and just use the default type.","category":"page"},{"location":"lecture_01/variables/#Variable-Names","page":"Variables","title":"Variable Names","text":"","category":"section"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> I_am_float = 3.1415\n3.1415\n\njulia> CALL_ME_RATIONAL = 1//3\n1//3\n\njulia> MyString = \"MyVariable\"\n\"MyVariable\"","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Here I_am_float contains a floating point number, CALL_ME_RATIONAL is a rational number (can be used, if the exact accuracy is needed) and MyString contains a string (a piece of text).","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Moreover, in the Julia REPL and several other Julia editing environments, you can type many Unicode (UTF-8 encoding) math symbols by typing the backslashed LaTeX symbol name followed by tab. You can also type many other non-math symbols. For example, the variable name δ can be entered by typing \\delta<tab>","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> δ = 1\n1","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"or pizza symbol 🍕 can be entered by typing \\:pizza:<tab>","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> 🍕 = \"It's time for pizza!!!\"\n\"It's time for pizza!!!\"","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type ? and then paste the symbol (works only for basic LaTeX symbols)","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"help?> α\n\"α\" can be typed by \\alpha<tab>\n[...]","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Here is the list of all Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL.","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions)","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> π = 2\n2\n\njulia> π\n2","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"However, if you try to redefine a built-in constant or function already in use, Julia will give you an error","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> π\nπ = 3.1415926535897...\n\njulia> π = 2\nERROR: cannot assign a value to variable MathConstants.π from module Main\n[...]","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"The only explicitly disallowed names for variables are the names of built-in statements","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"julia> struct = 3\nERROR: syntax: unexpected \"=\"\n[...]","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"The complete list of all reserved keywords is in the following table","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Reserved words:     \nbaremodule begin break catch const continue\ndo else elseif end export false\nfinally for function global if import\nlet local macro module quote return\nstruct true try using while ","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"In many cases, it is very beneficial to have the choice to use special symbols as variable names. It may increase the readability of the code especially when the user needs to implement some mathematical algorithms, where it is common to use the greek alphabet. However, excessive use of special symbols can cause confusion.","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"<div class = \"info-body\">\n<header class = \"info-header\">Stylistic Conventions:</header><p>","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"While there are almost no restrictions on valid names in Julia, it is useful to adopt the following conventions:","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"Names of variables are in lower case.\nWord separation can be indicated by underscores (_), but use of underscores is discouraged unless the name would be hard to read otherwise.\nDo not overuse special symbols, i.e. avoid using symbols like 🍕 as variable names.","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"For more information about stylistic conventions, see the official style guide or Blue Style.","category":"page"},{"location":"lecture_01/variables/","page":"Variables","title":"Variables","text":"</p></div>","category":"page"},{"location":"why_julia/#Why-Julia?","page":"Why Julia?","title":"Why Julia?","text":"","category":"section"},{"location":"why_julia/#How-to-install-Julia?","page":"Why Julia?","title":"How to install Julia?","text":"","category":"section"},{"location":"why_julia/#Install-Julia","page":"Why Julia?","title":"Install Julia","text":"","category":"section"},{"location":"why_julia/#Install-VS-Code","page":"Why Julia?","title":"Install VS Code","text":"","category":"section"},{"location":"why_julia/#Introduction-to-the-REPL","page":"Why Julia?","title":"Introduction to the REPL","text":"","category":"section"},{"location":"why_julia/#REPL","page":"Why Julia?","title":"REPL","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"using Plots","category":"page"},{"location":"lecture_09/theory/#Theory-of-neural-networks","page":"Theory of neural networks","title":"Theory of neural networks","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"Neural network appeared for the first time decades ago but were almost forgotten after a few years. Their resurgence in the last one or two decades is mainly due to the available computational power and their impressive list of applications which include","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"One of the first application was an automatic reading of postal codes to automatize the sorting of postcards. Since only ten black and white digits can appear at five predetermined locations, simple networks could be used.\nA similar type of neural networks (convolutional) is used in autonomous vehicles to provide information about cars, pedestrians or traffic signs. These networks also use bounding boxes to specify the position of the desired object.\nWhile the previous techniques used 2D structure of the input (image), recurrent neural networks are used for series (text, sound). The major application are automatic translations.\nAnother applications include generating new content. While there may exist useful applications such as artistic composition (music or writing scripts), these networks are often used to generate fake content (news, images).","category":"page"},{"location":"lecture_09/theory/#Neural-networks","page":"Theory of neural networks","title":"Neural networks","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"The first three bullets from the previous paragraph are all used for classification. Even though neural networks can be similarly used for regression, this usage is not so developed. The idea is the same as for linear networks. For an input x with a label y and a classifier f, it minimizes the loss between the prediction f(x) and label y. Having n samples, this results in","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"operatornameminimizeqquad sum_i=1^n operatornameloss(f(x_i) y_i)","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"The previous lecture used the linear classifier f(x)=w^top x and the cross-entropy loss for classification and the squared l_2 norm operatornameloss(hat y y) = (hat y - y)^2 for regression.","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"The main ideas of neural networks is to use more complex function f with a certain structure such that:","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"It has a good approximative quality.\nIt does not contain many parameters to learn (train).\nThe computation of derivatives (training) is simple.","category":"page"},{"location":"lecture_09/theory/#Layers","page":"Theory of neural networks","title":"Layers","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"The previous three bullets were achieved in an ellegant way by representing the neural network via  a layered structure. The input goes into the first layers, the output of the first layer goes into the second layer and so on. Mathematically speaking, a network f with M layers has the structure","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"f(x) = (f_M circ dots circ f_1)(x)","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"where f_1dotsf_M are individual layers. Since two layers which are not next to each other (such as the first and the third layer) are never directly connected (with the exception of skip connections), the function value can be propagrated through the network in a simple way. The same holds true for the gradients which can be easily computed via chain rules.","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"(Image: )","category":"page"},{"location":"lecture_09/theory/#Dense-layer","page":"Theory of neural networks","title":"Dense layer","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"Dense layer is the simplest layer which has the form","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"f_m(z) = l(W_mz + b_m)","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"where W_m is a matrix of appropriate dimensions, b_m is the bias (shift) and l is an activation function. The activation function is usually written as lmathbbRtomathbbR and its operation on a vector W_mz + b_m is understood componentwise. Examples of the activation functions include:","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"beginaligned\ntextSigmoidl(x) = frac11+e^-x \ntextReLUl(x) = operatornamemax0x \ntextSoftplusl(x) = log(1+e^x) \ntextSwishl(x) = fracx1+e^-x \nendaligned","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"using Plots\n\nxs = -4:0.01:4\nylim = (-1,4)\n\np1 = plot(xs, 1 ./(1 .+exp.(-xs)), title=\"Sigmoid\", ylim=ylim, label=\"\")\np2 = plot(xs, max.(xs,0), title=\"ReLU\", ylim=ylim, label=\"\")\np3 = plot(xs, log.(1 .+exp.(xs)), title=\"Softplus\", ylim=ylim, label=\"\")\np4 = plot(xs, xs ./(1 .+exp.(-xs)), title=\"Swish\", ylim=ylim, label=\"\")\n\nplot(p1, p2, p3, p4; layout=(2,2))\n\nsavefig(\"Activation.png\")","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"(Image: )","category":"page"},{"location":"lecture_09/theory/#Other-layers","page":"Theory of neural networks","title":"Other layers","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"There are many other layers (convolutional, recurrent, pooling, ...) which we will go through in the next lesson.","category":"page"},{"location":"lecture_09/theory/#Approximation-quality","page":"Theory of neural networks","title":"Approximation quality","text":"","category":"section"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"Even shallow neural networks (not many layers) are able to approximate any continuous function as the next theorem states.","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"<div class = \"theorem-body\">\n<header class = \"theorem-header\">Theorem: Universal approximation of neural networks</header><p>","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"Let gabto mathbbR be a continuous function defined on an interval. Then for every varepsilon0, there is a neural network f such that f-g_inftyle varepsilon.","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"Moreover, this network can be chosen as a chain of the following two layers:","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"Dense layer with ReLU activation function.\nDense layer with identity activation function.","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"</p></div>","category":"page"},{"location":"lecture_09/theory/","page":"Theory of neural networks","title":"Theory of neural networks","text":"As the proof suggest (Exercise 1), the price to pay is that the network needs to be extremely wide (lots of hidden neurons). x","category":"page"},{"location":"lecture_09/theory/#Gradient-computation","page":"Theory of neural networks","title":"Gradient computation","text":"","category":"section"},{"location":"lecture_03/methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"So far, we have defined all functions (with some exceptions) without annotating types of their input arguments. The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously \"untyped\" code.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"In Julia, functions consist of multiple methods. The choice of which method to execute when a function is applied is called dispatch. Julia allows the dispatch process to choose which of a function's methods to call based on","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"the number of arguments given\ntypes of all of the function's arguments.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Using all of a function's arguments to choose which method should be invoked is known as multiple dispatch.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"As an example of usage of multiple-dispatch, we will define a product function, that will computes the product of the given numbers","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(x, y) = x * y","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"In the REPL, we can see the line, that tells us, that the function product has only one method. In this case,  we defined only the method for two input arguments without type specification","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(1, 4.5)\nproduct(2.4, 3.1)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"A list of all methods for a given function can be obtained using the methods function","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"methods(product)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Because we did not specify any types of input arguments, the product function accepts arguments of all types. However, the * operator will not work for example for symbols","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(:a, :b)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"We can avoid such errors by specifying types of input arguments. Since we want to create a function that computes the product of two numbers, it makes sense to allow input arguments to be only numbers.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(x::Number, y::Number) = x * y\nproduct(x, y) = throw(ArgumentError(\"product is defined for numbers only.\"))\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Note that we also redefined the original definition of the product function to throw an error if we call the function with non-numeric input arguments.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"methods(product)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Now, we have a function with two methods, that returns a product if the input arguments are numbers and throw an error otherwise.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(1, 4.5)\nproduct(:a, :b)\nproduct(\"a\", \"b\")","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"As in the previous example, it is always better to use abstract types like Number or Real instead of concrete types like Float64,Float32, Int64 ... . This is because if we use an abstract type, the function will work for all its subtypes. To find an super type for a specific type, we can use  supertype function from InteractiveUtils package","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"using InteractiveUtils: supertype\nsupertype(Float64)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The problem with the supertype function is, that it will not return the whole supertype hierarchy, but only the closest larger supertype for the given type. For Float64 the closest large supertype is AbstractFloat. However, as in the example before, we do not want to use this supertype, since then the function will only work for floating-point numbers. Solve the following exercise to get the tool, which allows you to print the whole supertypes hierarchy.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Create a function supertypes_tree that prints the whole tree of all supertypes for the given type. If the given type T satisfies the following condition T === Any, then the function should do nothing. Use the following function declaration","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"function supertypes_tree(T::Type, level::Int = 0)\n    # code\nend","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The optional argument level sets the level of indentation","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Hints:","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"use the supertype function in combination with recursion.\nuse function repeat and string with white space \"    \" to create a proper indentation.\nlook at the example placed after the solution, how the output of the function should look like.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The supertypes_tree function can be defined as follows","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"function supertypes_tree(T::Type, level::Int = 0)\n    T === Any && return\n    println(repeat(\"   \", level), T)\n    supertypes_tree(supertype(T), level + 1)\n    return\nend\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"On the first line, we check if the given input type is Any, and if yes, then the function returns nothing. If the input type is not Any, then the function prints the type with a proper indentation which is given by repeat(\"   \", level), i.e. four white-spaces are repeated level-times. On the third-line, we call the supertypes_tree function recursively for the supertype of the type T and level of indentation level + 1.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"</p></details>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Now we can use the supertypes_tree function to get the whole supertypes hierarchy for Float64.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"supertypes_tree(Float64)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"We can check the type hierarchy using <: operator for comparing type, i.e. is T1 <: T2 is true, then T1 is a subtype (or the same type) of T2.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Float64 <: AbstractFloat <: Real <: Number","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Similarly to the supertype function, there is a function subtypes, that return all subtypes for the given type","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"using InteractiveUtils: subtypes\nsubtypes(Number)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"But there is the same problem as for the supertype function: It is not possible to get the whole hierarchy of all subtypes using only this function. Solve the following exercise to get the tool, which allows you to print the whole subtypes hierarchy.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Create a function subtypes_tree that prints the whole tree of all subtypes for the given type. Use the following function declaration","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"function subtypes_tree(T::Type, level::Int = 0)\n    # code\nend","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The optional argument level sets the level of indentation","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Hints:","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"use the subtypes function in combination with recursion.\nuse function repeat and string with white space \"    \" to create a proper indentation.\nlook at the example placed after the solution, how the output of the function should look like.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The subtypes_tree function can be defined as follows","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"function subtypes_tree(T::Type, level::Int = 0)\n    println(repeat(\"   \", level), T)\n    subtypes_tree.(subtypes(T), level + 1)\n    return\nend\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The function prints the type with a proper indentation which is given by repeat(\"   \", level), i.e. four white-spaces are repeated level-times. On the second-line, we call the subtypes_tree function recursively for all subtypes of the type T and level of indentation level + 1. Note, that we use dot syntax to apply the subtypes_tree function to all elements of the tuple, that is returned by subtypes(T).","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"</p></details>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Now we can use the subtypes_tree function to get the whole subtypes hierarchy for Number","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"subtypes_tree(Number)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"From the tree of all subtypes of the abstract type Number, we see the whole structure of numerical types in Julia. So if we want to define a function that accepts all numeric types, we should use inputs of type Number. However, many operations are restricted to only real numbers, in such a case, we want to use the Real type instead of Number.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Now we can go back to our example with the product function. The problem with this function is, that it is too restrictive since the product of two strings is a legitimate operation that should return their concatenation. So we should define a method for strings. To use the proper type, we can use the supertypes_tree function for the String type","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"supertypes_tree(String)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"We see, that the largest supertype for String is the AbstractString and that is the type we should use","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(x::AbstractString, y::AbstractString) = x * y\nproduct(x, y) = throw(ArgumentError(\"product is defined for numbers and strings only.\"))\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"We also redefined the original definition of the product function to throw an appropriate error.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(1, 4.5)\nproduct(\"a\", \"b\")\nproduct(:a, :b)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Sometimes, it can be very complicated to guess, which method will be used for concrete inputs. In such a case, there is a useful macro @which that returns the method that would be called for given arguments","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"using InteractiveUtils: @which\n\n@which product(1, 4.5)\n@which product(\"a\", :a)\n@which product(\"a\", \"b\")","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The previous example with the product function shows, how methods in Julia works. However, it is a good practice to use type annotation only if we really want to have a specialized function or if we want to define a function, which does different things for different types of input arguments.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"g(x::Real) = x + 1\ng(x::String) = repeat(x, 4)\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"For example, the g function returns x + 1 if the input x is a real number or repeats four times the input argument if it is a string. Otherwise, it will throw a method error, since we define only these two specific methods.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"g(1.2)\ng(\"a\")\ng(:a)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"<div class = \"info-body\">\n<header class = \"info-header\">Do not overuse type annotation!!!</header><p>","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The product function should be defined without the type annotation. It is a good practice to not restrict input argument types if it is not necessary. The reason is, that in this case, there is no benefit to using the type annotation. If we define a function product_new in the following way","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product_new(x, y) = x * y\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Then we can apply this function to the same inputs as the original product function and we will get the same results","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(1, 4.5)\nproduct_new(1, 4.5)\nproduct(\"a\", \"b\")\nproduct_new(\"a\", \"b\")","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"with only one exception","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"product(\"a\", :a)\nproduct_new(\"a\", :a)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Here we get a different error, but the error given by the product_new function is more useful since it tells us what is the real problem. We can see, that it is not possible to use the * operator to multiply String and Symbol. Now we can decide if it is the desired behavior and if not, we can define a method for the * operator that will fix it.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"</p></div>","category":"page"},{"location":"lecture_03/methods/#Method-Ambiguities","page":"Methods","title":"Method Ambiguities","text":"","category":"section"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"f(x::Float64, y) = x * y\nf(x, y::Float64) = x + y\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"Here, the f function has two methods. The first method applies if the first argument is of type Float64.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"f(2.0, 3)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The second method applies if the second argument is of type Float64.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"f(2, 3.0)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"The case, where both arguments are of type Float64 can be handled by both methods. The problem is that neither method is more specific than the other. In such cases, Julia raises a MethodError rather than arbitrarily picking a method.","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"f(2.0, 3.0)","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"We can avoid method ambiguities by specifying an appropriate method for the intersection case:","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"f(x::Float64, y::Float64) = x - y\nnothing # hide","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"If we can check again how many methods are defined for f, there will be three methods","category":"page"},{"location":"lecture_03/methods/","page":"Methods","title":"Methods","text":"methods(f)\nf(2, 3.0)\nf(2.0, 3)\nf(2.0, 3.0)","category":"page"},{"location":"lecture_01/arrays/#Arrays","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Arrays are the most common container used for storing data.","category":"page"},{"location":"lecture_01/arrays/#Vectors","page":"Arrays","title":"Vectors","text":"","category":"section"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A vector is a special case of an array with only one dimension and is represented as a list of ordered data which share a common type (Int64, Float64, Any,...). A vector in Julia can be constructed directly using square brackets and a comma (or semicolon) as value separators","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = [1, 2, 3, 4, 5, 6, 7, 8] # or equivalently v = [1; 2; 3; 4; ...]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Information about the number of dimension or type of elements of a given vector can be obtained using typeof function","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"typeof(v)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"We can see, that the general description of any array in Julia is as follows: Array{T,N} denotes N-dimensional dense array with elements of type T. From this description, we can immediately see, that vector v has one dimension and contains elements of type In64. Another way how to get this information is to use ndims and eltype function","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"ndims(v)\neltype(v)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"We can also check the size and the length of a vector using size and length function","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"size(v)\nlength(v)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"The size function returns a tuple containing the sizes of the given array along each dimension. The length function returns total number of elements in the given array.","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Elements of a vector can be accessed via square brackets and the index of the element. Contrary to other programming languages like C or Python and similarly to Matlab, arrays are indexed from 1. To access the third element of vector v, we simply use the following syntax","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v[3]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"There are also special keywords to access first and last element of a given vector","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v[begin] # the first element\nv[end] # the last element","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It is also possible to access multiple elements at once using the same syntax. The only difference is that instead of only one index, we use a vector of multiple indexes. For example, to access the second and third element of vector v, we can do","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v[[2, 3]]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Multiple indexes can be also selected using range function. The range function always accepts the starting point as a first argument and then keyword arguemnt stop or length. The user can also set the step length using keyword argument step. If length, stop, and step are all specified, they must agree. For example, to generate integers from 1 to 10 with step length 2 we can use following code","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"range(1; stop = 10, step = 2)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Ranges can also be constructed using the shorter syntax start:step:stop (the step can be omitted if it is equal to 1). Then the previous example can be equivalently rewritten as","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"1:2:10","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"This shorter syntax is very useful for accessing array elements","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v[1:3] # the first three elements\nv[1:2:end] # select all elements with odd index\nv[:] # all elements","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It is possible to add new elements to a vector using append! function. Notice the !, this is a Julia convention to say that the function will modify the first argument given to the function. In this case, the append! function appends one or more elements to the end of the given vector","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = [1,2,3]\nappend!(v, 4)\nappend!(v, [5,6])\nappend!(v, 7:8)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"As has already been said, the elements of a vector share the same type. In this case, we have a vector with elements of type Int64. If we want to append a value to a vector with a different type it will result in an error","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = Int64[]; # hide\nappend!(v, 3.1415)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"In this case, we cannot convert a Float64 to an Int64 without losing precision, thus the error. Our vector v can store only values of type Int64 or values that can be safely converted to Int64 (such as Int32 for example). To avoid these errors, we can initialize the type of elements when creating a vector. It can be done using a type name followed by a square bracket.","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = Float64[1, 2, 3]\nappend!(v, 3.1415)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It is possible to change the value of an element of a given vector. This can be done simply by assigning a new value to the desired element","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = [1,2,3, 4]\nv[2] = 4\nv","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It is also possible to assign one value to multiple elements of a vector at once. However, in this case, we have to use so-called dot syntax which is in Julia used for element-wise operations","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v[3:4] .= 11\nv","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Create a vector of integers that contains all odd numbers smaller than 10. Then changed the first element to 4 and the last two elements to 1.","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"The vector can be created manually as follows","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = [1,3,5,7,9]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"or we can use range function to create a range with given properties and then use collect function to create a vector or use Vector type to convert range to a vector","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"collect(1:2:9)\nVector(1:2:9)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Then we can easily assign new values to the desired positions","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v[1] = 4\nv[end-1:end] .= 1\nv","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"</p></details>","category":"page"},{"location":"lecture_01/arrays/#Matrices","page":"Arrays","title":"Matrices","text":"","category":"section"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A matrix is a special case of an array with exactly two dimensions. In Julia, we can construct a matrix using square brackets similarly to vectors. Matrices are constructed row by row and all rows are separated by semicolons. Elements in a row are separated by space","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"m = [1  2  3  4; 5  6  7  8]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"We can use the same functions as for vectors to obtain basic information about the matrices","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"typeof(m)\neltype(m)\nndims(m)\nsize(m)\nlength(m)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"To access elements of a matrix, we can use the same syntax as for vectors","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"m[1] # the first element, equivalent to m[begin]\nm[2] # the second element\nm[end-1] # the last element","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Note that the second element is 5. The reason is, that Julia is column-oriented. Element at specific position in a matrix can accessed by matrix[row_index, column_index], i.e. the following code returns the second element in the first row","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"m[1, 2]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It is also possible to access multiple elements at once","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"m[1, [2, 3]] # the second and third element in the first row\nm[1:3] # the first three elements according to linear indexing\nm[:, 1:3] # the first three columns\nm[1, :] # the first row\nm[:] # all elements","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It is not possible to append new elements into arrays (with exception of vectors) directly. However, arrays with matching sizes along some dimension can be concatenated in this dimension. For example, we can horizontally concatenate our matrix m using function hcat","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"hcat(m, m)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"or vertically using function vcat","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"vcat(m, m)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"There is also a general function cat that concatenate given arrays along dimension specified by keyword argument dims","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"cat(m, m; dims = 2) # equivalent to hcat(m, m)\ncat(m, m; dims = 1) # equivalent to vcat(m, m)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"If the sizes of arrays do not match, an error occurs","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v = [11, 12]\nvcat(m, v)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Create two vectors: vector all odd numbers smaller than 10 and vector of all even numbers smaller than 10. Then concatenate these two vectors horizontally and fill the third row with 4.","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"First, we have to create the two vectors. We can do it manually or ve can use ranges and collect function as in the exercise in the previous section","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"v1 = collect(1:2:9)\nv2 = collect(2:2:10)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Then we use function hcat to horizontally concatenate these two vectors","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"m = hcat(v1, v2)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"and finally, we select all elements in the third row and assign a new value to them","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"m[3,:] .= 4\nm","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"</p></details>","category":"page"},{"location":"lecture_01/arrays/#N-dimensional-arrays","page":"Arrays","title":"N-dimensional arrays","text":"","category":"section"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"In many cases, it is useful to use arrays with more dimensions to store data. As an example, we can mention RGB images, which are typically stored in 3-dimensional arrays. In julia, there is no explicit way to create N-dimensional arrays. The typical way how to create such an array is to create an empty array of appropriate size and then fill it either manually of using a loop. In this lecture, we will focus only on the basics of creating arrays. The lecture focused on loops will be later in the course.","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"There are several ways to initialize an array. The simplest and most common is using zeros function. This function by default creates an array of given size filled with zeros of type Float64","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = zeros(3, 5, 2) # equivalent to A = zeros((3, 5, 2))","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"The type of elements can be changed by passing the desired type as a first argument","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"B = zeros(Int64, 3, 5, 2)  # equivalent to B = zeros(Int64, (3, 5, 2))","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"As in the case of vectors and matrices, we can use the same functions to obtain basic information about the arrays","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"typeof(A)\neltype(A)\nndims(A)\nsize(A)\nlength(A)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"The process of assigning a new value to the element of an array is the same as in the case of a vector or matrixs","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"B[1] = 1 # assign 1 to the first element\nB[1, 2, 2] = 2 # assign 2 to the element at position (1,2,2)\nB[2,:,1] .= 4\nB","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"There are other useful functions which can be used to initialize an array. The ones function is similar to the zeros function, but instead of an array filled with zeros, it creates an array filled with ones","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"ones(Float32, 2, 3, 1)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Function fill creates an array of given size filled with the given value","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"fill(1.234, 2, 2)","category":"page"},{"location":"lecture_01/arrays/#Broadcasting","page":"Arrays","title":"Broadcasting","text":"","category":"section"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"In Julia, with broadcasting we indicate the action of mapping a function or an operation (which are the same in Julia) over an array or a matrix element by element. There is no speed gain in doing so, as it will be exactly equivalent to writing a for loop, but its conciseness may be useful sometimes. So the core idea in Julia is to write functions that take single values and use broadcasting when needed, unless the functions must explicitly work on arrays (for example to compute the mean of a series of values, perform matrix operations, vector multiplications, etc).","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"The broadcasting notation for operators consists of adding a dot . before the operator (for example .*)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"a = [1,2,3] # column vector\na .-= 4 # from each element of vector subtracts 4","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Without the dot, we get an error, since we cannot multiply substract a number from a vector","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"a -= 1","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"This syntax can be applied to any function in Julia. it is extremely useful for basic operations. For example, we can compute the absolute value of all elements simply by the following code","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"abs.(a)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"It can be also used for matrix multiplication. Consider the following example","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"a = [1,2,3] # column vector\nb = [4,5,6] # column vector\na * b","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"This makes perfectly sense from a mathematical point of view and operators behave how we would mathematically expect. If we want to use matrix multiplication, we have to transpose one of the vectors","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"a' * b\na * b'","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Nonetheless, in programming it is often useful to write operations which work on an element by element basis, and for this reason broadcasting comes to our help","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"a .* b","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Construct the matrix whose elements are given by the following formula","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A_i j = frac12exp(x_i j + 1)^2 quad i in 1 2  j in  1 2 3","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"where","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"x = [\n    -1  0  2;\n    2  -3  1;\n]\nnothing # hide","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"There are several ways to create matrix A. The most obvious one is to use for loop (we will talk about loops later)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = zeros(2, 3);\n\nfor i in eachindex(A)\n    A[i] = exp((x[i] + 1)^2)/2\nend\nA","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"or using list comprehension (this topic will be discussed later too)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = [exp((xi + 1)^2)/2 for xi in x]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"But the most elegant way (subjectively) is to use broadcasting","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = exp.((x .+ 1) .^ 2) ./ 2","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"There is a macro @. in Julia, that adds a dot before each operator and each function in an expression","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = @. exp((x + 1) ^ 2) / 2","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"</p></details>","category":"page"},{"location":"lecture_01/arrays/#Views","page":"Arrays","title":"Views","text":"","category":"section"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"As in other programming languages, arrays are pointers to location in memory, thus we need to pay attention when we handle them. If we create an array A and we assign it to a variable B, the elements of the original array can be modified be modified by accessing B:","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = [1 2 3; 4 5 6]\nB = A\nB[2] = 42","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"We can check that both arrays are equal even though we modified only the array B","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A == B","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"This is particularly useful because it lets us save memory, but may have undesirable effects. If we want to make a copy of an array we need to use the function copy","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"C = copy(A)\nC[4] = 10\nA == C","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"The different behavior occurs when accessing elements. Everytime we access multiple elements of an array at once, a new array is created","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"D = A[1:2, 1:2]\nD[1] = 15","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"In this case, we modified only the array D, and array A remains unchanged","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"D == A[1:2, 1:2]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"However, even if we want to select some subarray, it may be useful to create only a link to the original array and not a new array. In Julia, this can be done using view function","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"E = view(A, 1:2, 1:2)\nE[4] = 78","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"We see that even if we change only the array in D, the change is propagated to A","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"E == A[1:2, 1:2]","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"To simplify the process of creating views, there is a handy macro @views","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"@views A[1:2, 1:2] # equivalet to view(A, 1:2, 1:2)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Note that  function view creates a special type SubArray","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"typeof(E)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"Since SubArray is a subtype of AbstractArray, we can apply any function defined for Abstract Arrays to SubArray too. In other words, (almost) all functions that work for arrays will also work for subarray.","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"A = [1 2 3; 4 5 6]\nA_view = @views A[:, :]\nsum(A)\nsum(A_view)\nminimum(A; dims = 1)\nminimum(A_view; dims = 1)","category":"page"},{"location":"lecture_01/arrays/","page":"Arrays","title":"Arrays","text":"This means that we can use arrays and subarray interchangeably without the necessity of changing existing code. Of course, there are some limitations, but we will talk about it later.","category":"page"},{"location":"lecture_07/exercises/#Exercises","page":"Exercises","title":"Exercises","text":"","category":"section"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"homework-body\">\n<header class = \"homework-header\">Homework: Newton's method</header><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The Newton's method for solving equation g(x)=0 is an iterative procedure which at every iteration x^k approximates the function g(x) by its first-order (linear) expansion g(x) approx g(x^k) + nabla g(x^k)(x-x^k) and finds the zero point of this approximation.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The Newton's method for unconstrained optimization replaces the optimization problem by its optimality condition and solves the resulting equation.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Implement the Newton's method to minimize","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"f(x) = sin(x_1 + x_2) + cos(x_1)^2","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"with the starting point x^0=(0-1).","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 1</header><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Show that the primal formulation for a problem with no inequalities is equivalent to the min-max formulation.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The primal problem with no inequalities reads","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\ntextminimizeqquad f(x) \ntextsubject toqquad h_j(x) = 0 j=1dotsJ\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The Lagrangian has form","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"L(xlambdamu) = f(x) + sum_j=1^J mu_j h_j(x)","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Now consider the min-max formulation","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"operatorname*minimize_xquad operatorname*maximize_muquad f(x) + sum_j=1^J mu_j h_j(x)","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"If h_j(x)neq 0, then it is simple to choose mu_j in such a way that the inner maximimization problem has the optimal value +infty. But since the outer problem minimizes the objective, the value of +infty is irrelevant. Therefore, we can ignore all points with h_j(x)neq 0 and prescribe h_j(x)=0 as a hard constraint. But that is precisely the primal formulation.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 2</header><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Derive the dual formulation for the linear programming.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The linear program","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\ntextminimizeqquad c^top x \ntextsubject toqquad Ax=b \nxge 0\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"has the Lagrangian","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"L(xlambdamu) = c^top x - lambda^top x + mu^top (b-Ax) = (c - lambda - A^topmu)^top x + b^top mu","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Note that we need to have - lambda^top x because we require constraints g_i(x)le 0 or in other words -xle 0. The dual problem from its definition reads","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"operatorname*maximize_lambdage0 mu quad operatorname*minimize_x quad (c - lambda - A^topmu)^top x + b^top mu","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Since the minimization with respect to x is unconstrained, the same arguments as the previous exercise imply the hard constraint c - lambda - A^topmu=0. Then we may simplify the dual problem into","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\ntextmaximizeqquad b^top mu \ntextsubject toqquad c - lambda - A^topmu = 0 \nlambdage 0\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"From this formulation we may remove lambda and obtain A^top mule c. This is the desired dual formulation.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 3: Bisection method</header><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Similarly to the Newton's method, the bisection method is primarily designed to solve equations by finding its zero point. It is only able to solve equations f(x)=0 where fmathbbRtomathbbR. It starts with an interval ab where f has opposite values f(a)f(b)0. Then it selects the middle point on ab and halves the interval so that the new interval again satisfies the constraint on opposite signs f(a)f(b)0. This is repeated until the function value is small or until the interval has a small length.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Implement the bisection method and use it to minimize f(x) = x^2 - x on -11.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"First, we write the bisection method. We initialize it with arguments f and the initial interval ab. We also specify the optional tolerance. First, we save the function value fa = f(a) so that we do not need to recompute every time. The syntax fa == 0 && return a is a bit complex. Since && is the and operator, this first checks whether fa == 0 is satisfied and if so, it evaluates the second part. But the second part just returns a. Since we need to have f(a)f(b)0, we check this condition and if it is not satistied, we return an error message. Finally, we run the while loop where in every iteration, the interval is halved. The condition on opposite signs is enforced in the if condition inside the loop. Note that this implementation is efficient in the way that only one function evaluation is needed inside the loop. The price to pay are additional variables f(a), f(c) and f(c).","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"function bisection(f, a, b; tol=1e-6)\n    fa = f(a)\n    fb = f(b)\n    fa == 0 && return a\n    fb == 0 && return b\n    fa*fb > 0 && error(\"Wrong initial values for bisection\")\n    while b-a > tol\n        c = (a+b)/2\n        fc = f(c)\n        fc == 0 && return c\n        if fa*fc > 0\n            a = c\n            fa = fc\n        else\n            b = c\n            fb = fc\n        end\n    end\n    return (a+b)/2\nend\nnothing # hide","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"To use the bisection method to minimize a function f(x), we use it find the solution of the optimality condition f(x)=0.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"f(x) = x^2 - x\ng(x) = 2*x - 1\nx_opt = bisection(g, -1, 1)\nnothing # hide","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The correct solution is","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"println(round(x_opt, digits=4)) # hide","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 4: JuMP</header><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The library to perform optimization is called JuMP. Install it and use it to solve the linear optimization problem","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\ntextminimizeqquad x_1 + x_2 + x_5 \ntextsubject toqquad x_1+2x_2+3x_3+4x_4+5x_5 = 8 \nx_3+x_4+x_5 = 2 \nx_1+x_2 = 2\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The best start is the official documentation of the JuMP package. Since JuMP is only an interface for solvers, we need to include an actual solver as well. For linear programs, we can use using GLPK, for non-linear ones, we would need to use using Ipopt. We specify the constraints in a matrix form. It is possible to write them directly via @constraint(model, x[1] + x[2] == 2). This second way is more pleasant for complex constraints. Since x is a vector, we need to use value.(x) instead of the wrong value(x).","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"using JuMP\nusing GLPK\n\nA = [1 2 3 4 5; 0 0 1 1 1; 1 1 0 0 0]\nb = [8; 2; 2]\nc = [1; 1; 0; 0; 1]\nn = size(A, 2)\n\nmodel = Model(GLPK.Optimizer)\n\n@variable(model, x[1:n] >= 0)\n\n@objective(model, Min, c'*x)\n@constraint(model, A*x .== b)\noptimize!(model)\n\nx_val = value.(x)\nnothing # hide","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The correct solution is","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"println(round.(x_val, digits=4)) # hide","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 5: SQP method</header><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Derive the SQP method for optimization problem with only equality constraints","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\ntextminimizeqquad f(x) \ntextsubject toqquad h_j(x) = 0 j=1dotsJ\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"SQP writes the optimality (KKT) conditions and the applies the Newton's method to solve the resulting system of equations. ","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Apply the obtained algorithm to","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\ntextminimizeqquad sum_i=1^10 ix_i^4 \ntextsubject toqquad sum_i=1^10 x_i = 1\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Verify that the numerically obtained solution is correct.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The Lagrangian reads","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"L(xmu) = f(x) + sum_j=1^Jmu_j h_j(x)","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"Since there are no inequality constraints, the optimality conditions contain no complementarity and read","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginaligned\nnabla f(x) + sum_j=1^Jmu_j nabla h_j(x) = 0\nh_j(x) = 0\nendaligned","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The Newton method's at iteration k has some pair (x^kmu^k) and performs the update","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"beginpmatrix x^k+1  mu^k+1 endpmatrix = beginpmatrix x^k  mu^k endpmatrix - beginpmatrix nabla^2 f(x^k) + sum_j=1^J mu_j^k nabla^2 h_j(x^k)  nabla h(x^k)  nabla h(x^k)^top  0 endpmatrix^-1 beginpmatrix nabla f(x^k) + sum_j=1^Jmu_j^k nabla h_j(x^k)  h(x^k) endpmatrix ","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"For the numerical implementation, we define functions f and h and their derivates and Hessians. The simplest way to create a diagonal matrix is Diagonal from the LinearAlgebra package. It can be of course done manually as well. ","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"using LinearAlgebra\n\nn = 10\nf(x) = sum((1:n) .* x.^4)\nf_grad(x) = 4*(1:n)[:].*x.^3\nf_hess(x) = 12*Diagonal((1:n)[:].*x.^2)\nh(x) = sum(x) - 1\nh_grad(x) = ones(n)\nh_hess(x) = zeros(n,n)\nnothing # hide","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"To implement SQP we first randomly generate initial x and mu and then write the procedure derived above. Since we update x in a for loop, we need to define it as a global variables; otherwise, it will be a local variable and the global (outside of the loop) will not update. We can write inv(A)*b or the more efficient A\\b. To subtract from x, we use the shortened notation x -= ?, which is the same as x = x - ?.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"x = randn(n)\nμ = randn()\nfor i in 1:100\n    global x, μ\n    A = [f_hess(x) + μ*h_hess(x) h_grad(x); h_grad(x)' 0]\n    b = [f_grad(x) + μ*h_grad(x); h(x)]\n    step = A \\ b\n    x -= step[1:n]\n    μ -= step[n+1] \nend","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"To validate we need to verify the optimality and the feasibility; both need to equal to zero. These are the same as the b variable. However, we cannot call b directly, as it is inside the for loop and therefore local only.","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"f_grad(x) + μ*h_grad(x)\nh(x)","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"The correct solution is","category":"page"},{"location":"lecture_07/exercises/","page":"Exercises","title":"Exercises","text":"println(round.(x, digits=4)) # hide","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"abstract type Step end\n\nstruct GD <: Step\n    α::Real\nend\n\noptim_step(s::GD, f, g, x) = -s.α*g(x)\n\nfunction optim(f, g, x, s::Step; max_iter=100)\n    for i in 1:max_iter\n        x += optim_step(s, f, g, x)\n    end\n    return x\nend","category":"page"},{"location":"lecture_08/linear/#Linear-regression","page":"Linear regression","title":"Linear regression","text":"","category":"section"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"To experiment with machine learning models, we first need to load the data by","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"using BSON\n\nfile_name = joinpath(\"data\", \"iris.bson\")\ndata = BSON.load(file_name)","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"This creates a dictionary data whose entries can be accessed via data[:X]. The simpler way of loading is","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"using BSON: @load\n\n@load file_name X y y_name","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The columns of X (features) are sepal length, sepal width, petal length and petal width (in this order).","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"When designing a classification method, a good practice is to perform an analysis of the data. That may include checking for NaNs, infinite values, obvious errors, standard deviations of features or others. Here, we only plot the data. ","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"For simplicity of visualization, remove all features besides petal length and petal width. Since we need to include the bias (intercept), add a column of ones as the last column.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"Then plot the dataset.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"Since the peral length and width are the third and fourth columns, respectively, we use X[:,3:4]. Then we need to cat it with a vector of ones.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"y = X[:,4]\nX = hcat(X[:,3], repeat([1], size(X,1)))\nnothing # hide","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The best plot in this case is the scatter plot.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"using Plots\n\nscatter(X[:,1], y, label=\"\", xlabel=\"Petal length\", ylabel=\"Petal width\")\n\nsavefig(\"iris_lin1.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"</p></details>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"(Image: )","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The figure shows a positive correlation between length and width. This is natural as bigger petals means both longer and wider petals. We will estimate the dependence of the linear regression.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"Use the closed-form formula to solve the coefficient for the linear regression. Then use the optim method derived in the previous lecture to solve the optimization problem via gradient descent. The results should be identical. Compare the elapsed time.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The closed-form expression is (X^top X)^-1X^top y. This can be coded as (X'*X) \\ (X'*y). To measure the time, we use the @time macro.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"@time w = (X'*X) \\ (X'*y)","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"For using the gradient, we first realize that the formula for the derivate is X^top *(Xw-y). Defining the derivative function in g, we call the optim method in the same way as last lecture. Note that we needed to use much smaller stepsize this time.  ","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"g(w) = (X'*(X*w-y))\n@time w2 = optim([], g, zeros(size(X,2)), GD(1e-4); max_iter=10000)","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The difference between the solutions is","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"using LinearAlgebra\n\nnorm(w-w2)","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"which is acceptable.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"</p></details>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The correct solution is","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"w # hide","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"This gives an advice how to predict the petal width if only petal length is known.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"Write the dependence on the petal width on the petal length. Plot it on the previous graph.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"The desired dependence is","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"textwidth = -03665 + 04164*textlength","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"To plot the prediction, we save the function into f_pred, then create the limits x_lim and finally plot a function which connects the two points. We move the legend to the top-left corner and we prescribe the limits on the y axis.","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"scatter(X[:,1], y, label=\"\", xlabel=\"Petal length\", ylabel=\"Petal width\")\n\nf_pred(x) = w[1]*x + w[2]\nx_lim = [minimum(X[:,1])-0.1; maximum(X[:,1])+0.1]\nplot!(x_lim, f_pred.(x_lim), label=\"Prediction\", legend=:topleft, line=(:black,3))\n\nsavefig(\"iris_lin2.svg\") # hide","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"</p></details>","category":"page"},{"location":"lecture_08/linear/","page":"Linear regression","title":"Linear regression","text":"(Image: )","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"using Random\nRandom.seed!(1234)","category":"page"},{"location":"lecture_02/control_flow/#Iteration","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"lecture_02/control_flow/#for-loop","page":"Iteration","title":"for loop","text":"","category":"section"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"for i in [1,2,3,4]\n    println(i)\nend","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Use the for loop to print integers from 1 to 100, which are divisible by 3 and 7.","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Firstly we generate integers from 1 to 100. It can be done using range function that accept positional argument start point and keyword arguemnt stop point or length. The user can also set the step length using keyword argument step. If length, stop, and step are all specified, they must agree. To generate integers from 1 to 100 we can use following code","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"range(1; stop = 100) # or equivalently range(1; length = 100)","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"which is equivalent to using shorter syntax start:step:stop (the step can be omitted if it is equal to 1)","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"1:100 # or equivalently 1:1:100","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Now we have to select only integers that are divisible by 3 and 7. That can be done using the modulo function, for loop and if statement","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"for i in 1:100\n    if mod(i, 3) == 0 && mod(i, 7) == 0\n        println(i)\n    end\nend","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"or we can use short-circuit evaluation and chain of conditions","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"for i in 1:100\n    mod(i, 3) == mod(i, 7) == 0 && println(i)\nend","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></details>","category":"page"},{"location":"lecture_02/control_flow/#while-loop","page":"Iteration","title":"while loop","text":"","category":"section"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Use the while loop to print integers from 1 to 100, which are divisible by 3 and 7.","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"i = 0\nwhile i < 100\n    i += 1\n    mod(i, 3) == mod(i, 7) == 0 && println(i)\nend","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></details>","category":"page"},{"location":"lecture_02/control_flow/#Iterators","page":"Iteration","title":"Iterators","text":"","category":"section"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"for i in eachindex(A)\n    @show i\nend\nfor (i, a) in enumerate(A)\n    @show (i, a)\nend","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"For matrix A defined as","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"A = [i + j for i in 1:10, j in 1:10]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"compute the sum of all elements in each row and print the following message","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Sum of all elements in row i is i_sum","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"where i represents the number of the row and i_sum the sum of all elements in this row.","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"A = [i + j for i in 1:10, j in 1:10];\nfor (i, row) in enumerate(eachrow(A))\n    println(\"Sum of all elements in row $(i) is $(sum(row))\")\nend","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></details>","category":"page"},{"location":"lecture_02/control_flow/#List-comprehension","page":"Iteration","title":"List comprehension","text":"","category":"section"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"[x + y for x in 1:10, y in 1:4]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"f(x, y) = 2 + x*y\n[f(x,y) for x in 1:10, y in 11:14]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"[x^2 for x in 1:10 if isodd(x)]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"[x^2 + y^2  for x in 1:10, y in 1:10 if x + y < 5]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Use the list comprehension to select integers from 1 to 100, which are divisible by 3 and 7.","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"[i for i in 1:100 if mod(i, 3) == mod(i, 7) == 0]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></details>","category":"page"},{"location":"lecture_02/control_flow/#Generator-expressions","page":"Iteration","title":"Generator expressions","text":"","category":"section"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see Iteration). For example, the following expression sums a series without allocating memory:","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"sum(1/n^2 for n in 1:1000)","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Ranges in generators and comprehensions can depend on previous ranges by writing multiple for keywords:","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"[(i,j) for i in 1:3 for j in 1:i]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"In such cases, the result is always 1-d. Generated values can also be filtered using the if keyword:","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"[(i,j) for i in 1:3 for j in 1:i if i+j == 4]","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"Use a generator to sum the square of all integers from 1 to 100, which are divisible by 3 and 7.","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"sum(i^2 for i in 1:100 if mod(i, 3) == mod(i, 7) == 0)","category":"page"},{"location":"lecture_02/control_flow/","page":"Iteration","title":"Iteration","text":"</p></details>","category":"page"},{"location":"lecture_02/control_flow/#map-function","page":"Iteration","title":"map function","text":"","category":"section"},{"location":"lecture_02/control_flow/#mapreduce-function","page":"Iteration","title":"mapreduce function","text":"","category":"section"},{"location":"lecture_01/exercises/#Exercises","page":"Exercises","title":"Exercises","text":"","category":"section"},{"location":"lecture_03/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In Julia, a function is an object that maps a tuple of argument values to a return value. There are multiple ways how to create a function and each of them is useful in different situations. The first way is to use function ... end syntax","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function plus(x,y)\n    x + y\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In the previous example, we created a function plus that accepts two arguments x, y and returns their sum.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus(2, 3)\nplus(2, -3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"By default, the function in Julia returns the last evaluated expression, which in our example is x + y. However, in many situations, it is useful to return something other than the last expression. For such a case there is an return keyword. The previous example can be equivalently rewritten as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function plus(x,y)\n    return x + y\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Even though both function definitions do exactly the same, it is a good practice to always use return keyword. Using the return keyword usually improves the readability of the code and can prevent potential confusion.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function plus(x, y)\n    return x + y\n    println(\"I am a useless line of code!!\")\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"We can see, that there is println function used on the last line in the previous example. However, if the function is called, nothing is printed into the REPL","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus(4, 5)\nplus(3, -5)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The reason is, that the expressions after the return keyword are never evaluated","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"It is also possible to return multiple values at once. This can be done by simply writing multiple comma-separated values after the return keyword (or on the last line when return is not used)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function powers(x)\n    return x, x^2, x^3, x^4\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In fact, this syntax creates a tuple of values and then this tuple is returned as a function output. It can be seen, if we call the powers function that returns the first four powers of the given x","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"ps = powers(2)\ntypeof(ps)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Since the function returns a tuple, returned values can be directly unpacked into multiple variables. It can be done in the same way as unpacking tuples","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"x1, x2, x3, x4 = powers(2)\nx3","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Write a function that for a given real number x and integer p computes x^p without using the ^ operator. You can use only basic arithmetic operators +, -, *, / and if condition.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Hint: use recursion.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"To use recursion, we have to split the computation into three parts:","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"p = 0: the function should return 1.\np  0: the function should be called recursively with arguments x, p - 1 and the result should be multiplied by x.\np  0: then it is equivalent to call the power function with arguments 1x, - p.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"These three cases can be defined simply using one if condition as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function power(x::Real, p::Integer)\n    if p == 0\n        return 1\n    elseif p > 0\n        return x * power(x, p - 1)\n    else\n        return power(1/x, - p)\n    end\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note, that we use type annotation for function arguments. In this case, it will assure, that the first argument is always a real number and the second argument is always an integer.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"power(2, 5)\npower(2, -2)\npower(2, 5) == 2^5\npower(5, -3) == 5^(-3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"If we call the function with arguments of inappropriate types, an error will occur","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"power(2, 2.5)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"We will discuss the type annotation later in the section about multiple-dispatch.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_03/functions/#One-line-functions","page":"Functions","title":"One-line functions","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Besides the traditional function declaration syntax above, it is possible to define a function in a compact one-line form","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus(x, y) = x + y\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"that is equivalent to the previous definition of plus function","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus(4, 5)\nplus(3, -5)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"This syntax is very similar to the mathematical notation especially in combination with the greek alphabet. For example the following function","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"f(varphi) = - 4 cdot sinleft(varphi - fracpi12right)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"can be in Julia defined in almost identical form","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"f(φ) = -4sin(φ - π/12)\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Even with one-line syntax, it is possible to create more complex functions with some intermediate calculations. It can be done, using brackets and semicolons to separate expressions. The last expression in brackets is then returned  as a function output","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"g(x) = (x -= 1; x *= 2; x)\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In this example, the g function subtracts 1 from the given x and then multiply the result by 2","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"g(3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"However, for better code readability, the traditional multiline syntax should be used for more complex functions.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Write a one-line function, that returns true if the input argument is an odd number and false otherwise","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Hint: use modulo function and ternary operator ? (for more info, use help for symbol ?).","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In help, we can find the syntax for the ternary operator","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"a ? b : c","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"This expression can be read as follows: if a is true, evaluate b otherwise evaluate c. We also know that even numbers are divisible by 2 and we can check it using the modulo, i.e. the given integer x is even if mod(x, 2) == 0.  Altogether, we get the following function definition","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"even(x::Integer) = mod(x, 2) == 0 ? true : false\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note, that we use type annotation to assure, that the argument is always an integer.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"even(11)\neven(14)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_03/functions/#Optional-arguments","page":"Functions","title":"Optional arguments","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Another very useful thing is optional arguments. Similarly to python, optional arguments can be created by assigning a default value to the normal argument. The following function has only one argument, which is optional with a default value world","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"hello(x = \"world\") = println(\"Hello $(x).\")\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Since the only argument is optional, we can call the function without any argument. In such a case, the function prints \"Hello $(x).\", where x is replaced by the default value","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"hello()","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"If we call the function with the argument, it will change the printed sentence","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"hello(\"people\")","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In the same way, it is possible to define multiple optional arguments. It is even possible to define optional arguments, that depend on other arguments","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"powers(x, y = x*x, z = y*x, v = z*x) = x, y, z, v\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"This function has one mandatory argument and three optional ones. If only the first argument s is provided, then the function returns the first four powers of the given x","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"powers(2)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Otherwise, the function output depends on the given input arguments. For example, if two arguments x and y are provided, the function returns these two arguments unchanged, their product x*y and also x^2*y","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"powers(2, 3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Write a function, that computes the value of the following quadratic form","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"q_abc(x) = ax^2 + bxy + cy^2","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"where a b c x in mathbbR. Use optional arguments to set default values for parameters","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"a = 1 quad b = 2a quad c = 3(a + b)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"What is the function value at point (4 2) for default parameters? What is the function value at the same point, if we use c = 3?","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The quadratic form can be implemented as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"q(x, y, a = 1, b = 2*a, c = 3*(a + b)) = a*x^2 + b*x*y + c*y^2\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Since we want to evaluate the function q at point (4, 2) with default parameters, we can simply use only first two arguments","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"q(4, 2)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"However, it is not possible to set only the last optional argument. We have to also set all previous optional arguments too. For the first two optional arguments, we use the default values, i.e. a = 1 and b = 2*a = 2.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"q(4, 2, 1, 2, 3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_03/functions/#Keyword-arguments","page":"Functions","title":"Keyword arguments","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The exercise from the previous section shows the biggest disadvantage of using optional arguments, i.e. it is not possible to change only one optional argument unless it is the first one. Luckily there are also keyword arguments, that can be used instead of optional arguments. The syntax is exactly the same as for optional arguments with one exception: we have to use a semicolon before the first keyword argument","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"linear(x; a = 1, b = 0) = a*x + b\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"This function is a simple linear function, where a parameter is called slope and b parameter is called intercept. As with functions with optional arguments, we can call the function only with the mandatory arguments","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"linear(2)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"or we can change the value of any keyword argument by assigning a new value to its name","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"linear(2; a = 2)\nlinear(2; b = 4)\nlinear(2; a = 2, b = 4)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note that the semicolon, in this case, is not mandatory and can be omitted. Also, the order of keyword arguments can be arbitrary as can be seen i the following example","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"linear(2, b = 4, a = 2)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"It is even possible to mix keyword arguments with positional arguments","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"linear(a = 2, 2, b = 4)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"However, it's a good practice to always separate keyword arguments from optional arguments with a semicolon.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Julia also provides one very nice feature, that can be used to pass keyword arguments. Imagine, that we have two variable a, b, that represents the keyword arguments of the linear function. The standard way how to pass these arguments to the function is the following","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"a, b = 2, 4\nlinear(2; a = a, b = b)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"However, in Julia, we can use the shorter version, that can be used if the variable name is the same as the name of the keyword argument we want to set","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"linear(2; a, b)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Write a probability density function for the Gaussian distribution, that is given by the following formula","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"f_mu sigma(x) = frac1sigma sqrt 2pi  expleft -frac12 left( fracx - musigma right) ^2 right","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"where mu in mathbbR and sigma^2  0. Use keyword arguments to set the default values mu = 0 and sigma = 1.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Bonus: check that this function is really a probability density function","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The probability density function for the Gaussian distribution can be simply written as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function f(x::Real; μ::Real = 0, σ::Real = 1)\n    σ^2 == 0 && error(\"the variance `σ^2` must be nonzero\")\n    return exp(-1/2 * ((x - μ)/σ)^2)/(σ * sqrt(2*π))\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note, that we use type annotation to  assure, that all input arguments will be real numbers and we also check whether the given arguments do not lead to a zero variance (the first line in the function body).","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"f(0)\nf(0.1; μ = 1, σ = 1)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"We know, that the integral over all real numbers from the probability density function should be equal to one. We can check it numerically as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"x = -100:0.1:100;\nsum(f, x) * 0.1\n\ng(x) = f(x; μ = -1, σ = 1.4)\nsum(g, x) * 0.1","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"We use the sum function, which can accept a function as a first argument a then this function is applied to each value before summation. The result is always multiplied by 0.1. It is because we use a range with stepsize 0.1  to approximate continuous interval [-100, 100].","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Finally, we can use the following code to visualize the probability density functions","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"using Plots\n\nx = -15:0.1:15\n\nplot(x, f.(x); label = \"μ = 0, σ = 1\", linewidth = 2, xlabel = \"x\", ylabel = \"f(x)\");\nplot!(x, f.(x; μ = 4, σ = 2); label = \"μ = 4, σ = 2\", linewidth = 2);\nplot!(x, f.(x; μ = -3, σ = 2); label = \"μ = -3, σ = 2\", linewidth = 2);\nsavefig(\"gauss.svg\") # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"We use a lot of things that will be discussed later in the course. So for now, just enjoy a nice picture of the Gaussian probability density functions","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"(Image: )","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_03/functions/#Variable-number-of-arguments","page":"Functions","title":"Variable number of arguments","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Sometimes, it is very convenient to be able to define a function, that can accept any number of arguments. Such functions are traditionally known as \"varargs\" functions, which is short for \"variable number of arguments\". In Julia, varargs functions can be defined using triple-dot syntax after the last positional argument as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"foo(x...) = x\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The foo function defined above, accepts any number of input arguments, wraps them in a tuple a returns them","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"foo()\nfoo(1, 2, \"a\", :b, [1,2,3])","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The following example is more useful. In that example, we define basicinfo function, that accepts any number of input arguments and then prints basic information like the number of given arguments, their sum, mean and standard deviation.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"using Statistics\n\nfunction basicinfo(x...)\n    println(\"\"\"\n      - number of arguments: $(length(x))\n      - sum: $(round(sum(x); digits = 2))\n      - mean: $(round(mean(x); digits = 2))\n      - std: $(round(std(x); digits = 2))\n    \"\"\")\n    return\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note, that we have to use package Statistics, since functions mean and std are not part of standard packages, that are loaded in every Julia session.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"basicinfo(0.158, 1.889, 1.246, 4.569)\nbasicinfo(0.158, 1.889, 1.246, 4.569, 5.189, -4.123)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"A similar syntax for a variable number of positional arguments can be used for keyword arguments as well. Functions that accept any number of keyword arguments can be very useful. Such functions can be used for example","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"shiftedsum(x; a = 1, kwargs...) = sum(x .- a; kwargs...)\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Here we define a function, that subtracts a from each element of the given input array x and then sums this array. This function also pass all given keyword arguments to the sum function.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"A = [1 2 3; 4 5 6]\nshiftedsum(A)\nshiftedsum(A; dims = 1)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Write a function wrapper, that accepts a number and applies the round, ceil or floor function based on the keyword argument type. Make sure that all optional and keyword arguments can be passed to these three functions.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Use the function to solve the following tasks","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Round 1252.1518 to the nearest larger integer and convert the resulting value to Int64.\nRound 1252.1518 to the nearest smaller integer and convert the resulting value to Int16.\nRound 1252.1518 to 2 digits after the decimal point.\nRound 1252.1518 to 3 significant digits.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The one way how to define such a function is to use if conditions as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function wrapper(x...; type = :round, kwargs...)\n    if type == :ceil\n        return ceil(x...; kwargs...)\n    elseif type == :floor\n        return floor(x...; kwargs...)\n    else\n        return round(x...; kwargs...)\n    end\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In this case, the type keyword argument is used to determine which function should be used. Note, that we use an optional number of arguments as well as an optional number of keyword arguments. The reason is, that we want to pass all given arguments to the appropriate function and this is the easiest way how to do it.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"x = 1252.1518\nwrapper(Int64, x; type = :ceil)\nwrapper(Int16, x; type = :floor)\nwrapper(x; digits = 2)\nwrapper(x; sigdigits = 3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The second way how to solve this exercise is to use the fact, that it is possible to pass functions as arguments. Using this fact, we can omit the if condition, and we can pass the appropriate function directly","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"wrapper_new(x...; type = round, kwargs...) = type(x...; kwargs...)\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note, that in the function definition, we use the type keyword argument as a function. It can be done since we assume that a function is assigned to the keyword argument type","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"wrapper_new(1.123; type = ceil)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"If we use for example Symbol instead of a function, the error will occur","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"wrapper_new(1.123; type = :ceil)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Finally, we can test wrapper_new function on the same arguments as we tested wrapper function","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"x = 1252.1518\nwrapper_new(Int64, x; type = ceil)\nwrapper_new(Int16, x; type = floor)\nwrapper_new(x; digits = 2)\nwrapper_new(x; sigdigits = 3)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_03/functions/#Anonymous-functions","page":"Functions","title":"Anonymous functions","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"It is also common to use anonymous functions, i.e. functions without specified name. Such a function can be defined in almost the same way as a normal function:","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"h1 = function (x)\n    x^2 + 2x - 1\nend\nh2 = x ->  x^2 + 2x - 1\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Those two function declarations create functions with automatically generated names. Then variables h1 and h2 only refers to these functions. The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is map function, which applies a function to each value of an array and returns a new array containing the resulting values:","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"map(x -> x^2 + 2x - 1, [1,3,-1])","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Julia also provides a reserved word do, that allows creating more complicated functions easily. In the following example, we apply map function to two arrays.  Using do block, we create an anonymous function, that prints the given values a return their sum","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"map([1,3,-1], [2,4,-2]) do x, y\n    println(\"x = $(x), y = $(y)\")\n    return x + y\nend","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Note, that the body of such a function is written in the same way as in the case of a normal function definition. The arguments of such function are defined after the do keyword. Usually, it is better to create an actual function and then use it in map function. The previous example can be rewritten as","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"function f(x, y)\n    println(\"x = $(x), y = $(y)\")\n    return x + y\nend\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"map(f, [1,3,-1], [2,4,-2])","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"There are many possible uses quite different from map, such as managing system state. For example, there is a version of open that runs code ensuring that the opened file is eventually closed","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"open(\"outfile\", \"w\") do io\n    write(io, data)\nend","category":"page"},{"location":"lecture_03/functions/#Dot-Syntax-for-Vectorizing-Functions","page":"Functions","title":"Dot Syntax for Vectorizing Functions","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In technical-computing languages, it is common to have vectorized versions of functions. Imagine, that we have a function f(x), then its vectorized version is a function, that applies function f to each element of an array A and returns a new array f(A). Such functions are especially useful in languages, where loops are slow and vectorized versions of functions are written in a low-level language (C, Fortran,...) and are much faster. As an example, we can mention Matlab.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In Julia, vectorized functions are not required for performance, and indeed it is often beneficial to write your own loops, but they can still be convenient. As an example, consider the sine function and imagine, that we want to compute its value for all following values [0, π/2, 3π/4]. Using the loops we can do it as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"x = [0, π/2, 3π/4];\nA = zeros(length(x));\n\nfor (i, xi) in enumerate(x)\n    A[i] = sin(xi)\nend\nA","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"or using list compherension","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"A = [sin(xi) for xi in x]","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"However, in this case, the most onvenient way is to use dot syntax for vectorizing functions as follows","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"A = sin.(x)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In Julia, it is possible to use this syntax for any function to apply it to each element of the given array. It is extremely useful since it allows us to write simple functions that accept for example only numbers as arguments and then we can easily apply them to whole arrays","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus(x::Real, y::Real) = x + y\nnothing # hide","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Here, we define a function, that accepts two real numbers and returns their sum. This function will work perfectly for two numbers","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus(1,3)\nplus(1.4,2.7)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"But, if we try to apply this function to arrays, an error will occur","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"x = [1,2,3,4]; # column vector\nplus(x, x)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"However, we can use dot syntax for vectorizing functions, to any function in Julia. Then the plus function will be applied to arrays x and y element-wise","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus.(x, x)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"More generally, if we have a function f and we use dot syntax f.(args...), then it is equivalent to calling the broadcast function  in the following way broadcast(f, args...)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"broadcast(plus, x, x)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"This allows us to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars. For more information see the section about broadcasting in the official documentation. In the following example, the plus function adds one to each element of the x array","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"plus.(x, 1)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Or we can apply the plus function to the column vector x and the row vector y. The result will be a matrix","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"y = [1 2 3 4]; # row vector\nplus.(x, y)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Some text that describes the exercise","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Solution","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_03/functions/#Function-composition-and-piping","page":"Functions","title":"Function composition and piping","text":"","category":"section"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"As in mathematics, functions in Julia can be composed. If we have two functions f mathcalX  rightarrow mathcalY and g mathcalY  rightarrow mathcalZ, then their composition can be mathematically written as","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"(g circ f)(x) = g(f(x)) quad forall x in mathcalX","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"In Julia, we can compose functions in a similar way using the function composition operator ∘ (can be typed as \\circ<tab>)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"(sqrt ∘ +)(3, 6) # equivalent to sqrt(3 + 6)","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"It is even possible to compose multiple functions at once","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"(sqrt ∘ abs ∘ sum)([-3, -6, -7])  # equivalent to sqrt(abs(sum([-3, -6, -7])))","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"There is also another concept, that allows to chain functions, which is sometimes called piping or using a pipe to send data to a subsequent function. This concept can be used to simply pass the output of one function as an input to another one. In Julia, it can be one by pipe operator |>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"[-3, -6, -7] |> sum |> abs |> sqrt","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"The pipe operator can be combined with broadcasting. In the following example, firstly we apply the abs function element-wise and then we apply the sqrt function element-wise.","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"[-4, 9, -16] .|> abs .|> sqrt","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Or as in the next example, we can use broadcasting in combination with the pipe operator to apply a different function to each element of the given vector","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"[\"a\", \"list\", \"of\", \"strings\"] .|> [uppercase, reverse, titlecase, length]","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Some text that describes the exercise","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"Solution","category":"page"},{"location":"lecture_03/functions/","page":"Functions","title":"Functions","text":"</p></details>","category":"page"},{"location":"lecture_01/data_structures/#Data-structures","page":"Data structures","title":"Data structures","text":"","category":"section"},{"location":"lecture_01/data_structures/#Tuples","page":"Data structures","title":"Tuples","text":"","category":"section"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"A tuple is an immutable, ordered, fixed-sized group of elements, i.e. it is not possible to add new elements or change the value of any element in a tuple. Tuples are created using the following syntax","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t = (1, 2.0, \"3\")","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"It is even possible to omit the brackets","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t = 1, 2.0, \"3\"","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"This syntax is used in a function definition to return multiple values at once. The type of a tuple is given by the types of all its elements","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"typeof(t)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"In this case, we can see, that we have a tuple that contains three elements, where the first one I of type Int64, the second one of type Float64, and the last one of type String.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"To access elements of a tuple, we can use the same syntax as for arrays","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t[1] # the first element\nt[end] # the last element\nt[1:2] # the first two elements","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"A very useful feature is that it is possible to unpack a tuple over many values","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"a, b, c = t\nprintln(\"The values stored in the tuple are: $a, $b and $c\")","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Note that this is also possible to do with arrays. Tuples are usually used for storing a small number of values and then this feature may be useful. On the other hand, arrays are usually large, so such a feature is not useful for arrays most of the time.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Tuples can be very handy for passing arguments to functions. Imagine the situation, that we have function arguments stored in a tuple and we want to call some function with them. The standard way how to do that is manually passed each element of the tuple to the function. As an example, we can use a tuple with two numbers and modulo function","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"args = (9, 5)\nmod(args[1], args[2])","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"or we can unpack the tuple to two variables and then pass these two variables to the function","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"a, b = args\nmod(a, b)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"In Julia, however, there is an even simpler way. It is possible to unpack a tuple and pass its arguments to a function directly with the triple dot (...) syntax","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"mod(args...)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"This is very useful, but also very addictive and it should be used carefully.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Create a tuple that contains odd numbers smaller than 10. Try to do that using range function, tuple function and triple-dot syntax ....","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Such a tuple can be created easily with the following syntax","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t = tuple(1:2:9...)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"or even in a simpler way without tuple function","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t = (1:2:9..., )","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"The comma after three dots is crucial because it says that we want to create a tuple. Without the comma, an error will occur.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t = (1:2:9...)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Note, that the same syntax can be also used to create a vector","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"v = [1:2:9..., ]","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"</p></details>","category":"page"},{"location":"lecture_01/data_structures/#Named-Tuples","page":"Data structures","title":"Named Tuples","text":"","category":"section"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Named tuples are similar to tuples, i.e. named tuple is an immutable, ordered, fixed-sized group of elements. The only difference is, that each element consists of a name (identifier) and value. Named tuples are created using the following syntax","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t = (a = 1, b = 2.0, c = \"3\")","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"or it is possible to create a named tuple directly from variables","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"a = 1;\nb = 2.0;\nc = \"3\";\nt = (; a, b, c)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Here the semicolon is mandatory, because without the semicolon the result will be a tuple instead of a named tuple. Similarly to tuples, the elements of a named tuple can be accessed via square brackets. However, in opposed to tuples, it is not possible to access multiple elements at once","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t[1] # the first element\nt[end] # the last element\nt[1:2] # error","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Moreover, it is possible to get elements of a named tuple via their names","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"t.a\nt.c","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Also unpacking and passing named tuple as argumnts into the function works in the same way as for tuples","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"args = (a = 9, b = 5)\na, b = args\nprintln(\"The values stored in the tuple are: a = $a, b = $b\")\nmod(args...)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Moreover, it is possible to use named tuples to store and reuse keyword arguments. It can be demonstrated on a range function","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"kwargs = (stop = 10, step = 2)\nrange(1; kwargs...)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Also here the semicolon is mandatory because without the semicolon the named tuple will be unpacked as positional arguments.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise:</header><p>","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Define a matrix using the following code","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"m = hcat(-2:2, -5:-1)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Use sort function to sort each column of the matrix in descending order based on the absolute value of each element. Use help to learn how the sort function works and what arguments accepts. Use named tuple with appropriate keys to pass keyword arguments to sort function.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"From the help, we can see that we need to set up the following three keyword arguments","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"dims: Index of dimension along which we want to sort given matrix. Since we want to sort columns, we have to set dims = 1.\nrev: Boolean that says if we want to use reverse ordering. By default values are sorted in ascending order, so we need to set rev = true.\nby: A function that is applied to each element before comparing. Since we want to sort elements based on their absolute values, we have to set by = abs.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Now we know what keyword arguments we have to use to get a correct result and we can create a named tuple","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"kwargs = (dims = 1, rev = true, by = abs)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"and then call sort function on the given matrix m","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"m = hcat(-2:2, -5:-1)\nsort(m; kwargs...)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"In this particular case, there is no benefit to use a named tuple to store keyword arguments and it is simpler to pass arguments directly to the sort function","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"sort(m; dims = 1, rev = true, by = abs)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"However, this approach can be very useful as we will see later.","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"</p></details>","category":"page"},{"location":"lecture_01/data_structures/#Dictionaries","page":"Data structures","title":"Dictionaries","text":"","category":"section"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Dictionaries are mutable, unordered (random order) collections of pairs of keys and values. The syntax for creating a dictionary is as follows","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"d = Dict(\"a\" => [1, 2, 3], \"b\" => 1)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"or using symbols instead of strings as keys","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"d = Dict(:a => [1, 2, 3], :b => 1)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"In fact, it is possible to use almost any type as a key in a dictionary. The elements of a dictionary can be accessed via square brackets and a key","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"d[:a]","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"If the key does not exist in the dictionary and we try to get it using the square brackets syntax, an error will occur","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"d[:c]","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"To avoid such errors, we can use get function. This function accepts three arguments: a dictionary, key, and a default value for this key, which is returned if the key does not exist in the given dictionary","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"get(d, :c, 42)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"There is also an in-place version of get function, which also add the default value to the dictionary if the key does not exist","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"get!(d, :c, 42)\nget!(d, :d, [\"hello\", \"world\"])\nd","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Sometimes it is useful to check if a dictionary has a specific key. For this purpose, there is a function  haskey","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"haskey(d, :d)\nhaskey(d, :e)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"It is also possible to remove unwanted keys from the dictionary. It can be done using delete! function, which removes the key from the dictionary","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"delete!(d, :d)\nhaskey(d, :d)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"or using pop! function, which removes the key from the dictionary and returns the value corresponding to this key","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"pop!(d, :c)\nhaskey(d, :c)","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"Optionally it is possible to add a default value for a given key to the pop! function, which is returned if the key does not exist in the given dictionary","category":"page"},{"location":"lecture_01/data_structures/","page":"Data structures","title":"Data structures","text":"haskey(d, :c)\npop!(d, :c, 444)","category":"page"},{"location":"#Numerical-computing-in-Julia","page":"Home","title":"Numerical computing in Julia","text":"","category":"section"},{"location":"#Goals","page":"Home","title":"Goals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main goals of the course are the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n\nTo teach you independence. The formulation of many exercises is very general. This simulates the situation when no step-by-step procedure is provided.","category":"page"},{"location":"#Requirements-for-the-course","page":"Home","title":"Requirements for the course","text":"","category":"section"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Official documentation\nThink Julia: How to Think Like a Computer Scientist\nFrom Zero to Julia!\nWikiBooks","category":"page"},{"location":"lecture_03/exercises/#Exercises","page":"Exercises","title":"Exercises","text":"","category":"section"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"<div class = \"exercise-body\">\n<header class = \"exercise-header\">Exercise 1:</header><p>","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"The goal of this exercise is to solve the following quadratic equation","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"ax^2 + bx + c = 0","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"where a b c in mathbbR Write a function quadratic that computes the value of the left hand side of the given equation. Then write a function findroots that computes roots of the quadratic equation based on the given coefficients a, b and c. Finally, test that the roots given by the findroots function are correct. Use the following four parameter settings","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"a = 2, b = 9 and c = 4\na = 0, b = 2 and c = 4\na = 1, b = 2 and c = 1\na = 1, b = 2 and c = 2","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"</p></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"To define the quadratic function, we can use the one-line syntax as follows","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"quadratic(x, a, b, c) = a*x^2 + b*x + c","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"The findroots function is a little bit more complicated. We know, that for a = 0 the equation is reduced to a linear equation with the following root","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"x = - fracbc","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"If a neq 0 the roots can be computed using discriminant that is defined as  Delta = b^2 - 4ac. Then there are three cases:","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"If the discriminant is zero, then there is exactly one real root","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"x = -fracb2a","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"If the discriminant is positive, then there are two unique real roots","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"x_1 = frac-b + sqrtDelta2a quad\nx_2 = frac-b - sqrtDelta2a","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"If the discriminant is negative, then there are two unique complex roots","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"x_1 = frac-b + isqrt-Delta2a quad\nx_2 = frac-b - isqrt-Delta2a","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"Now, we can simply use if conditions to define the findroots function","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"function findroots(a, b, c)\n    a == 0 && return -c/b\n\n    Δ = b^2 - 4*a*c\n    if Δ == 0\n        return -b/(2*a)\n    elseif Δ > 0\n        return (-b + sqrt(Δ))/(2*a), (-b - sqrt(Δ))/(2*a)\n    else\n        return (-b + im*sqrt(-Δ))/(2*a), (-b - im*sqrt(-Δ))/(2*a)\n    end\nend","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"Finally, we can test our functions","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"args = (2, 9, 4);\nquadratic.(findroots(args...), args...)\nargs = (0, 2, 4);\nquadratic.(findroots(args...), args...)\nargs = (1, 2, 1);\nquadratic.(findroots(args...), args...)\nargs = (1, 2, 2);\nquadratic.(findroots(args...), args...)","category":"page"},{"location":"lecture_03/exercises/","page":"Exercises","title":"Exercises","text":"</p></details>","category":"page"}]
}
