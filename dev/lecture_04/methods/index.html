<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Julia for Optimization and Learning</title><meta name="title" content="Methods · Julia for Optimization and Learning"/><meta property="og:title" content="Methods · Julia for Optimization and Learning"/><meta property="twitter:title" content="Methods · Julia for Optimization and Learning"/><meta name="description" content="Documentation for Julia for Optimization and Learning."/><meta property="og:description" content="Documentation for Julia for Optimization and Learning."/><meta property="twitter:description" content="Documentation for Julia for Optimization and Learning."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Optimization and Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Optimization and Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Julia for Optimization and Learning</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/vscode/">Julia + Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quickstart guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Data structures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_02/tuples/">Tuples and named tuples</a></li><li><a class="tocitem" href="../../lecture_02/dictionaries/">Dictionaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/conditions/">Conditional evaluations</a></li><li><a class="tocitem" href="../../lecture_03/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Soft local scope</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../functions/">Functions</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy"><span>Type hierarchy</span></a></li><li class="toplevel"><a class="tocitem" href="#output"><span>output</span></a></li><li class="toplevel"><a class="tocitem" href="#output-2"><span>output</span></a></li><li class="toplevel"><a class="tocitem" href="#output-3"><span>output</span></a></li></ul></li><li><a class="tocitem" href="../scope/">Scope of variables</a></li><li><a class="tocitem" href="../exceptions/">Exception handling</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../../lecture_05/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_05/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_05/otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../../lecture_05/interaction/">Interaction with other languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/compositetypes/">Abstract and composite types</a></li><li><a class="tocitem" href="../../lecture_06/currencies/">Generic programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Code organization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/modules/">Files and modules</a></li><li><a class="tocitem" href="../../lecture_07/pkg/">Package manager</a></li><li><a class="tocitem" href="../../lecture_07/develop/">Package development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_08/gradients/">Gradients</a></li><li><a class="tocitem" href="../../lecture_08/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_08/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Introduction to regression and classification</a></li><li><a class="tocitem" href="../../lecture_09/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_09/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">11: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_11/iris/">Introduction to Flux</a></li><li><a class="tocitem" href="../../lecture_11/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_11/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">12: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/sparse/">Linear regression with sparse constraints</a></li><li><a class="tocitem" href="../../lecture_12/monte/">Monte Carlo sampling</a></li><li><a class="tocitem" href="../../lecture_12/glm/">Linear regression revisited</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">13: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_13/theory/">Differential equations</a></li><li><a class="tocitem" href="../../lecture_13/ode/">Wave equation</a></li><li><a class="tocitem" href="../../lecture_13/diff_eq/">Julia package</a></li><li><a class="tocitem" href="../../lecture_13/optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">4: Functions and methods</a></li><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Julia-for-Optimization-and-Learning" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Julia-for-Optimization-and-Learning/blob/master/docs/src/lecture_04/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h1><p>So far, we defined all functions (with some exceptions) without annotating the types of input arguments. When the type annotation is omitted, the default behaviour in Julia is to allow values to be of any type. One can write many useful functions without stating the types. When additional expressiveness is needed, it is easy to introduce type annotations into previously <em>untyped</em> code.</p><p>In Julia, one function consists of multiple methods. A prime example is the <code>convert</code> function. When a user calls a function, the process of choosing which method to execute is called dispatch. The dispatch system in Julia decides which method to execute based on:</p><ul><li>the number of function arguments;</li><li>the types of function arguments.</li></ul><p>Using all function arguments to choose which method should be invoked is known as <strong>multiple dispatch</strong>.</p><p>As an example of multiple dispatch, we define the <code>product</code> function that computes the product of two numbers.</p><pre><code class="language-julia-repl hljs">julia&gt; product(x, y) = x * y
product (generic function with 1 method)</code></pre><p>In the REPL, we can see that the <code>product</code> function has only one method. In this case, we defined the method for any two input arguments without type specification.</p><pre><code class="language-julia-repl hljs">julia&gt; product(1, 4.5)
4.5

julia&gt; product(2.4, 3.1)
7.4399999999999995</code></pre><p>The <code>methods</code> function lists all methods for a function.</p><pre><code class="language-julia-repl hljs">julia&gt; methods(product)
# 1 method for generic function &quot;product&quot; from Main:
 [1] product(x, y)
     @ none:1</code></pre><p>Because we did not specify types of input arguments, the <code>product</code> function accepts arguments of all types. For some inputs, such as symbols, the <code>*</code> operator will not work.</p><pre><code class="language-julia-repl hljs">julia&gt; product(:a, :b)
ERROR: MethodError: no method matching *(::Symbol, ::Symbol)
[...]</code></pre><p>We can avoid such errors by specifying types of input arguments. Since we want to create a function that computes the product of two numbers, it makes sense to allow input arguments to be only numbers.</p><pre><code class="language-julia hljs">product(x::Number, y::Number) = x * y
product(x, y) = throw(ArgumentError(&quot;product is defined for numbers only.&quot;))</code></pre><p>The second line redefined the original definition of the <code>product</code> function. It now throws an error if <code>product</code> is called with non-numeric inputs.</p><pre><code class="language-julia-repl hljs">julia&gt; methods(product)
# 2 methods for generic function &quot;product&quot; from Main:
 [1] product(x::Number, y::Number)
     @ none:1
 [2] product(x, y)
     @ none:1</code></pre><p>Now, we have a function with two methods, that returns a product if the input arguments are numbers, and throws an error otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; product(1, 4.5)
4.5

julia&gt; product(:a, :b)
ERROR: ArgumentError: product is defined for numbers only.
[...]

julia&gt; product(&quot;a&quot;, &quot;b&quot;)
ERROR: ArgumentError: product is defined for numbers only.
[...]</code></pre><h2 id="Type-hierarchy"><a class="docs-heading-anchor" href="#Type-hierarchy">Type hierarchy</a><a id="Type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy" title="Permalink"></a></h2><p>It is always better to use abstract types like <code>Number</code> or <code>Real</code> instead of concrete types like <code>Float64</code>, <code>Float32</code>, or <code>Int64</code>. The reason is that if we use an abstract type, the function will work for all its subtypes. To find a supertype for a specific type, we can use the <code>supertype</code> function from the <code>InteractiveUtils</code> package.</p><pre><code class="language-julia-repl hljs">julia&gt; using InteractiveUtils: supertype

julia&gt; supertype(Float64)
AbstractFloat</code></pre><p>The problem with the <code>supertype</code> function is that it does not return the whole supertype hierarchy, but only the closest <em>larger</em> supertype. For <code>Float64</code> the closest larger supertype is <code>AbstractFloat</code>. However, as in the example above, we do not want to use this supertype, since then the function will only work for floating point numbers.</p><div class="admonition is-warning"><header class="admonition-header">Exercise:</header><div class="admonition-body"></div></div><p>Create a function <code>supertypes_tree</code> which prints the whole tree of all supertypes. If the input type <code>T</code> satisfies the following condition <code>T === Any</code>, then the function should do nothing. Use the following function declaration:</p><pre><code class="language-julia hljs">   function supertypes_tree(T::Type, level::Int = 0)
      # code
   end
   ```

   The optional argument `level` sets the printing indentation level.

   **Hints:**
   - Use the `supertype` function in combination with recursion.
   - Use the `repeat` function and string with white space `&quot;    &quot;` to create a proper indentation.

!!! details &quot;Solution:&quot;
   The `supertypes_tree` function can be defined by:

   ```jldoctest methods; output = false
   function supertypes_tree(T::Type, level::Int = 0)
      isequal(T, Any) &amp;&amp; return
      println(repeat(&quot;   &quot;, level), T)
      supertypes_tree(supertype(T), level + 1)
      return
   end

   # output
   supertypes_tree (generic function with 2 methods)
   ```

   The first line checks if the given input type is `Any`. If yes, then the function returns nothing. Otherwise, the function prints the type with a proper indentation provided by `repeat(&quot;   &quot;, level)`, i.e., four white-spaces repeated `level`-times. The third line calls the `supertypes_tree` function recursively for the supertype of the input type `T` and the level of indentation `level + 1`.

Now we can use the `supertypes_tree` function to get the whole supertype hierarchy for `Float64`.
</code></pre><p>julia julia&gt; supertypes_tree(Float64) Float64    AbstractFloat       Real          Number</p><pre><code class="nohighlight hljs">
We can check the type hierarchy by the `&lt;:` operator for comparing types: If `T1 &lt;: T2` is true, then `T1` is a subtype (or the same type) of `T2`.
</code></pre><p>jldoctest methods julia&gt; Float64 &lt;: AbstractFloat &lt;: Real &lt;: Number true</p><pre><code class="nohighlight hljs">
Similarly to the `supertype` function, there is the `subtypes` function that returns all subtypes for the given type.
</code></pre><p>julia julia&gt; using InteractiveUtils: subtypes</p><p>julia&gt; subtypes(Number) 2-element Vector{Any}:  Complex  Real</p><pre><code class="nohighlight hljs">
This function suffers from a similar disadvantage as the `supertype` function: It is impossible to get the whole hierarchy of all subtypes using only this function.

!!! warning &quot;Exercise:&quot;
   Create a function `subtypes_tree` which prints the whole tree of all subtypes for the given type. Use the following function declaration:

   ```@meta
   DocTestSetup = quote
      using InteractiveUtils: subtypes
   end
   ```

   ```julia
   function subtypes_tree(T::Type, level::Int = 0)
      # code
   end
   ```

   The optional argument `level` sets the printing indentation level.

   **Hints:**
   - Use the `subtypes` function in combination with recursion.
   - Use the `repeat` function and string with white space `&quot;    &quot;` to create a proper indentation.

!!! details &quot;Solution:&quot;
   The `subtypes_tree` function is similar to `supertypes_tree`. The only differences are that we do not need to check for the top level of `Any`, and that we need to call the vectorized version `subtypes_tree.` because `subtypes(T)` returns an array.

   ```jldoctest methods; output = false
   function subtypes_tree(T::Type, level::Int = 0)
      println(repeat(&quot;   &quot;, level), T)
      subtypes_tree.(subtypes(T), level + 1)
      return
   end

   # output
   subtypes_tree (generic function with 2 methods)
   ```

Now we can use the `subtypes_tree` function to get the whole subtypes hierarchy for the `Number` type.
</code></pre><p>julia julia&gt; subtypes_tree(Number) Number    Complex    Real       AbstractFloat          BigFloat          Float16          Float32          Float64       AbstractIrrational          Irrational       Integer          Bool          Signed             BigInt             Int128             Int16             Int32             Int64             Int8          Unsigned             UInt128             UInt16             UInt32             UInt64             UInt8       Rational</p><pre><code class="nohighlight hljs">
This tree shows the whole structure of Julia numerical types. If we want to define a function that accepts all numeric types, we should use inputs of type `Number`. However, many operations are restricted to only real numbers. In such a case, we want to use the `Real` type instead of `Number`.


## Multiple dispatch

Now we can go back to our example with the `product` function. The problem with this function is that it is too restrictive because the product of two strings is a legitimate operation that should return their concatenation. We should define a method for strings. To use the proper type, we can use the `supertypes_tree` function for the `String` type.
</code></pre><p>jldoctest methods julia&gt; supertypes_tree(String) String    AbstractString</p><pre><code class="nohighlight hljs">
We see that the *largest* supertype for `String` is `AbstractString`. This leads to
</code></pre><p>jldoctest methods; output = false product(x::AbstractString, y::AbstractString) = x * y product(x, y) = throw(ArgumentError(&quot;product is defined for numbers and strings only.&quot;))</p><h1 id="output"><a class="docs-heading-anchor" href="#output">output</a><a id="output-1"></a><a class="docs-heading-anchor-permalink" href="#output" title="Permalink"></a></h1><p>product (generic function with 3 methods)</p><pre><code class="nohighlight hljs">
We also redefined the original definition of the `product` function to throw an appropriate error.
</code></pre><p>jldoctest methods julia&gt; product(1, 4.5) 4.5</p><p>julia&gt; product(&quot;a&quot;, &quot;b&quot;) &quot;ab&quot;</p><p>julia&gt; product(:a, :b) ERROR: ArgumentError: product is defined for numbers and strings only. [...]</p><pre><code class="nohighlight hljs">
Sometimes, it may be complicated to guess which method is used for concrete inputs. In such a case, there is a useful macro `@which` that returns the method that is called for given arguments.
</code></pre><p>jldoctest methods julia&gt; using InteractiveUtils: @which</p><p>julia&gt; @which product(1, 4.5) product(x::Number, y::Number)      @ Main none:1</p><p>julia&gt; @which product(&quot;a&quot;, :a) product(x, y)      @ Main none:1</p><p>julia&gt; @which product(&quot;a&quot;, &quot;b&quot;) product(x::AbstractString, y::AbstractString)      @ Main none:1</p><pre><code class="nohighlight hljs">
The previous example with the `product` function shows how methods in Julia works. However, it is a good practice to use type annotation only if we want to have a specialized function or if we want to define a function, which does different things for different types of input arguments.
</code></pre><p>jldoctest methods; output = false g(x::Real) = x + 1 g(x::String) = repeat(x, 4)</p><h1 id="output-2"><a class="docs-heading-anchor" href="#output-2">output</a><a class="docs-heading-anchor-permalink" href="#output-2" title="Permalink"></a></h1><p>g (generic function with 2 methods)</p><pre><code class="nohighlight hljs">
For example, the `g` function returns `x + 1` if the input `x` is a real number or repeats four times the input argument if it is a string. Otherwise, it will throw a method error.
</code></pre><p>jldoctest methods julia&gt; g(1.2) 2.2</p><p>julia&gt; g(&quot;a&quot;) &quot;aaaa&quot;</p><p>julia&gt; g(:a) ERROR: MethodError: no method matching g(::Symbol)</p><p>Closest candidates are:   g(!Matched::String)    @ Main none:1   g(!Matched::Real)    @ Main none:1 [...]</p><pre><code class="nohighlight hljs">
!!! info &quot;Do not overuse type annotation:&quot;
   The `product` function should be defined without the type annotation. It is a good practice not to restrict input argument types unless necessary. The reason is that, in this case, there is no benefit of using the type annotation. It is better to define the function `product_new` by:

   ```jldoctest methods; output = false
   product_new(x, y) = x * y

   # output
   product_new (generic function with 1 method)
   ```

   Then we can apply this function to the same inputs as the original `product` function, and we will get the same results

   ```jldoctest methods
   julia&gt; product(1, 4.5)
   4.5

   julia&gt; product_new(1, 4.5)
   4.5

   julia&gt; product(&quot;a&quot;, &quot;b&quot;)
   &quot;ab&quot;

   julia&gt; product_new(&quot;a&quot;, &quot;b&quot;)
   &quot;ab&quot;
   ```

   with only one exception

   ```jldoctest methods
   julia&gt; product(&quot;a&quot;, :a)
   ERROR: ArgumentError: product is defined for numbers and strings only.
   [...]

   julia&gt; product_new(&quot;a&quot;, :a)
   ERROR: MethodError: no method matching *(::String, ::Symbol)
   [...]
   ```

   Here we get a different error. However, the error returned by the `product_new` function is more useful because it tells us what the real problem is. We can see that it is impossible to use the `*` operator to multiply a `String` and a `Symbol`. We can decide if this is the desired behaviour, and if not, we can define a method for the `*` operator that will fix it.

We show a simple example when the multiple dispatch is useful.

!!! warning &quot;Exercise:&quot;
   We define the abstract type `Student` and specific types `Master` and `Doctoral`. The latter two are defined as structures containing one and three fields, respectively.

   ```@example methods
   abstract type Student end

   struct Master &lt;: Student
      salary
   end

   struct Doctoral &lt;: Student
      salary
      exam_mid::Bool
      exam_english::Bool
   end

   nothing # hide
   ```

   We can check that the `subtypes_tree` works correctly on any type, including the type `Student` which we defined.

   ```julia
   julia&gt; subtypes_tree(Student)
   Student
      Doctoral
      Master
   ```

   We create instances of two students by providing values for the struct fields.

   ```@example methods
   s1 = Master(5000)
   s2 = Doctoral(30000, 1, 0)

   nothing # hide
   ```

   Write the `salary_yearly` function which computes the yearly salary for both student types. The monthly salary is computed from the base salary (which can be accessed via `s1.salary`). Monthly bonus for doctoral students is 2000 for the mid exam and 1000 for the English exam.

!!! details &quot;Solution:&quot;
   Julia prefers to write many simple functions. We write `salary_yearly` based on the not-yet-defined `salary_monthly` function.

   ```@example methods
   salary_yearly(s::Student) = 12*salary_monthly(s)

   nothing # hide
   ```

   We specified that the input to `salary_yearly` is any `Student`. Since `Student` is an abstract type, we can call `salary_yearly` with both `Master` and `Doctoral` student. Now we need to define the `salary_monthly` function. Since the salary is computed in different ways for both students, we write two methods.

   ```@example methods
   salary_monthly(s::Master) = s.salary
   salary_monthly(s::Doctoral) = s.salary + s.exam_mid*2000 + s.exam_english*1000

   nothing # hide
   ```

   Both methods have the same name (they are the same function) but have different inputs. While the first one is used for `Master` students, the second one for `Doctoral` students. Now we print the salary.

   ```@example methods
   println(&quot;The yearly salary is $(salary_yearly(s1)).&quot;)
   println(&quot;The yearly salary is $(salary_yearly(s2)).&quot;)

   nothing # hide
   ```

## Method ambiguities

It is possible to define a set of function methods with no most specific method applicable to some combinations of arguments.
</code></pre><p>jldoctest methods_amb; output = false f(x::Float64, y) = x * y f(x, y::Float64) = x + y</p><h1 id="output-3"><a class="docs-heading-anchor" href="#output-3">output</a><a class="docs-heading-anchor-permalink" href="#output-3" title="Permalink"></a></h1><p>f (generic function with 2 methods)</p><pre><code class="nohighlight hljs">
Here, `f` has two methods. The first method applies if the first argument is of type `Float64`, and the second method applies if the second argument is of type `Float64`.
</code></pre><p>jldoctest methods_amb julia&gt; f(2.0, 3) 6.0</p><p>julia&gt; f(2, 3.0) 5.0</p><pre><code class="nohighlight hljs">
Both methods can be used if both arguments are of type `Float64`. The problem is that neither method is more specific than the other. This results in `MethodError`.
</code></pre><p>jldoctest methods_amb julia&gt; f(2.0, 3.0) ERROR: MethodError: f(::Float64, ::Float64) is ambiguous.</p><p>Candidates:   f(x, y::Float64)     @ Main none:1   f(x::Float64, y)     @ Main none:1</p><p>Possible fix, define   f(::Float64, ::Float64) [...]</p><pre><code class="nohighlight hljs">
We can avoid method ambiguities by specifying an appropriate method for the intersection case.
</code></pre><p>jldoctest methods_amb julia&gt; f(x::Float64, y::Float64) = x - y f (generic function with 3 methods)</p><pre><code class="nohighlight hljs">
Now `f` has three methods.
</code></pre><p>jldoctest methods_amb julia&gt; f(2.0, 3.0) -1.0 ```</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Functions</a><a class="docs-footer-nextpage" href="../scope/">Scope of variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 13 September 2024 20:20">Friday 13 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
