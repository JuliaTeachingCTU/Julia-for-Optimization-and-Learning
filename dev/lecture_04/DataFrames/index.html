<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DataFrames.jl · Numerical computing in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Numerical computing in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Numerical computing in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit">Numerical computing in Julia</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../howto/">How to...</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Mathematical operations and Elementary functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional evaluation</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and iterators</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basics/">Package management</a></li><li><a class="tocitem" href="../standardlibrary/">Standard library</a></li><li><a class="tocitem" href="../Plots/">Plots.jl</a></li><li class="is-active"><a class="tocitem" href>DataFrames.jl</a></li><li><a class="tocitem" href="../otherpackages/">Other useful packages</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li></ul></li><li><span class="tocitem">5: Composite types and constructors</span></li><li><span class="tocitem">6: Modules and enviroments</span></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><span class="tocitem">11: Ordinary differential equations</span></li><li><span class="tocitem">12: Statistics I.</span></li><li><span class="tocitem">13: Statistics II.</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">4: Packages</a></li><li class="is-active"><a href>DataFrames.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DataFrames.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_04/DataFrames.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DataFrames.jl"><a class="docs-heading-anchor" href="#DataFrames.jl">DataFrames.jl</a><a id="DataFrames.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DataFrames.jl" title="Permalink"></a></h1><p><a href="https://dataframes.juliadata.org/stable/">DataFrames</a> is a package that provides a set of tools for working with tabular data in Julia. Its design and functionality are similar to those of <a href="https://pandas.pydata.org/">pandas</a> (in Python) and <code>data.frame</code>, <code>data.table</code> and dplyr (in R), making it a great general purpose data science tool, especially for those coming to Julia from R or Python.</p><h3 id="Creating-DataFrames"><a class="docs-heading-anchor" href="#Creating-DataFrames">Creating <code>DataFrame</code>s</a><a id="Creating-DataFrames-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-DataFrames" title="Permalink"></a></h3><p>The core of the package is the <code>DataFrame</code> that represents a data table. The simplest way of constructing a <code>DataFrame</code> is to pass column vectors using keyword arguments or pairs</p><pre><code class="language-julia">using DataFrames
df = DataFrame(A = 1:4, B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;], C = rand(4))</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>C</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th></tr></thead><tbody><p>4 rows × 3 columns</p><tr><th>1</th><td>1</td><td>M</td><td>0.761104</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.752123</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.168072</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.825091</td></tr></tbody></table><p>Since each column is stored in a <code>DataFrame</code> as a separate vector, it is possible to combine columns of a different element types. Column can be accesed directly without copying as follows</p><pre><code class="language-julia">df.A</code></pre><pre class="documenter-example-output">4-element Array{Int64,1}:
 1
 2
 3
 4</pre><p>or using indexing syntax which is similar to indexing syntax</p><pre><code class="language-julia">df[!, :A]</code></pre><pre class="documenter-example-output">4-element Array{Int64,1}:
 1
 2
 3
 4</pre><p>Note, that we use <code>!</code> to select all rows. If we use <code>:</code>,  then we get a copy of a column. Since vectors are mutable structures and accessing a column of <code>DataFrame</code> via syntax above does not make a copy, it is possible to change elements of the <code>DataFrame</code> as follows</p><pre><code class="language-julia">df.A[1] = 5
df</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>C</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th></tr></thead><tbody><p>4 rows × 3 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.761104</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.752123</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.168072</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.825091</td></tr></tbody></table><p>However, sometimes it is useful to get a copy of a column instead. To do that, we can use the following syntax</p><pre><code class="language-julia">col = df[:, :A]
col[1] = 4
df</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>C</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th></tr></thead><tbody><p>4 rows × 3 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.761104</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.752123</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.168072</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.825091</td></tr></tbody></table><div class = "info-body">
<header class = "info-header">Column names</header><p><p>DataFrames allows to use <code>Symbol</code>s (like <code>:A</code>) and strings (like <code>&quot;A&quot;</code>) for all column indexing operations for convenience. However, using <code>Symbol</code>s is slightly faster and should generally be preferred, if not generating them via string manipulation.</p></p></div><h3 id="Saving-and-loading"><a class="docs-heading-anchor" href="#Saving-and-loading">Saving and loading</a><a id="Saving-and-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-loading" title="Permalink"></a></h3><p>The standard format for storing table data is <code>csv</code> file format. The <a href="https://github.com/JuliaData/CSV.jl">CSV</a> package provides an interface for saving and loading <code>csv</code> files.</p><pre><code class="language-julia">using CSV
CSV.write(&quot;dataframe.csv&quot;, df)
table = CSV.read(&quot;dataframe.csv&quot;, DataFrame; header = true)</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>C</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th></tr></thead><tbody><p>4 rows × 3 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.761104</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.752123</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.168072</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.825091</td></tr></tbody></table><p>See the package <a href="https://csv.juliadata.org/stable/">documentation</a> for more information.</p><h3 id="Adding-columns-and-rows"><a class="docs-heading-anchor" href="#Adding-columns-and-rows">Adding columns and rows</a><a id="Adding-columns-and-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-columns-and-rows" title="Permalink"></a></h3><p>It is common for tables to be created column by column or row by row. <code>DataFrame</code>s provides an easy way to extend existing tables. To add a new column to a <code>DataFrame</code>, we can use a direct way as follows</p><pre><code class="language-julia">df.D = [:a, :b, :c, :d]
df</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th><th>Symbol</th></tr></thead><tbody><p>4 rows × 4 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.761104</td><td>a</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.752123</td><td>b</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.168072</td><td>c</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.825091</td><td>d</td></tr></tbody></table><p>Alternatively, we can use the <code>insertcols!</code> function. This feature allows you to insert multiple columns at once and also allows for other advanced options. For example, you can specify the column index into which the columns are to be inserted. For more information, see the <code>insertcols!</code> help</p><pre><code class="language-julia">insertcols!(df, 3, :B =&gt; rand(4), :B =&gt; 11:14; makeunique = true)</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>B_1</th><th>B_2</th><th>C</th><th>D</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th><th>Int64</th><th>Float64</th><th>Symbol</th></tr></thead><tbody><p>4 rows × 6 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.690949</td><td>11</td><td>0.761104</td><td>a</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.103873</td><td>12</td><td>0.752123</td><td>b</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.417709</td><td>13</td><td>0.168072</td><td>c</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.900176</td><td>14</td><td>0.825091</td><td>d</td></tr></tbody></table><p>New rows can be added to the existing <code>DataFrame</code> using the <code>push!</code> function. New rows can be in the form of a vector or tuple of the correct length or in the form of a dictionary with keys the same as the column names of the target table</p><pre><code class="language-julia">push!(df, [10, &quot;F&quot;, 0.1, 15, 0.235, :f])
push!(df, (10, &quot;F&quot;, 0.1, 15, 0.235, :f))
push!(df, Dict(:B_1 =&gt; 0.1, :B_2 =&gt; 15, :A =&gt; 10, :D =&gt; :f, :B =&gt; &quot;F&quot;, :C =&gt; 0.235))
df</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th><th>B_1</th><th>B_2</th><th>C</th><th>D</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th><th>Int64</th><th>Float64</th><th>Symbol</th></tr></thead><tbody><p>7 rows × 6 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.690949</td><td>11</td><td>0.761104</td><td>a</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.103873</td><td>12</td><td>0.752123</td><td>b</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.417709</td><td>13</td><td>0.168072</td><td>c</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.900176</td><td>14</td><td>0.825091</td><td>d</td></tr><tr><th>5</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>6</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>7</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr></tbody></table><p>It is possible to start with an empty <code>DataFrame</code>.  There is no problem when the <code>DataFrame</code> is constructed in a column by column manner</p><pre><code class="language-julia">using DataFrames
df_empty = DataFrame()
df_empty.A = 1:3
df_empty.B = [:a, :b, :c]
df_empty</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th></tr><tr><th></th><th>Int64</th><th>Symbol</th></tr></thead><tbody><p>3 rows × 2 columns</p><tr><th>1</th><td>1</td><td>a</td></tr><tr><th>2</th><td>2</td><td>b</td></tr><tr><th>3</th><td>3</td><td>c</td></tr></tbody></table><p>However, this approach will not work if the <code>DataFrame</code> is created row by row. In this case, the empty <code>DataFrame</code> must be initialized with empty columns with the correct element types</p><pre><code class="language-julia">df_empty = DataFrame(A = Int[], B = Symbol[])
push!(df_empty, [1, :a])
push!(df_empty, (2, :b))
push!(df_empty, Dict(:A =&gt; 3, :B =&gt; :c))
df_empty</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>B</th></tr><tr><th></th><th>Int64</th><th>Symbol</th></tr></thead><tbody><p>3 rows × 2 columns</p><tr><th>1</th><td>1</td><td>a</td></tr><tr><th>2</th><td>2</td><td>b</td></tr><tr><th>3</th><td>3</td><td>c</td></tr></tbody></table><h3 id="Renaming"><a class="docs-heading-anchor" href="#Renaming">Renaming</a><a id="Renaming-1"></a><a class="docs-heading-anchor-permalink" href="#Renaming" title="Permalink"></a></h3><p>Sometimes it is useful to get the names of all the columns. Two functions can be used for such a task. The first is the <code>names</code> function, which returns column names as a vector of <code>String</code>s. The <code>propertynames</code> function does the same thing but returns a vector of <code>Symbol</code>s</p><pre><code class="language-julia-repl">julia&gt; names(df)
6-element Array{String,1}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;B_1&quot;
 &quot;B_2&quot;
 &quot;C&quot;
 &quot;D&quot;

julia&gt; propertynames(df)
6-element Array{Symbol,1}:
 :A
 :B
 :B_1
 :B_2
 :C
 :D</code></pre><p>If we are not satisfied with the column names, we can simply change them using the <code>rename!</code> function. This function can be used to rename all columns at once</p><pre><code class="language-julia">rename!(df, [:a, :b, :c, :d, :e, :f])
df</code></pre><table class="data-frame"><thead><tr><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th><th>Int64</th><th>Float64</th><th>Symbol</th></tr></thead><tbody><p>7 rows × 6 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.690949</td><td>11</td><td>0.761104</td><td>a</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.103873</td><td>12</td><td>0.752123</td><td>b</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.417709</td><td>13</td><td>0.168072</td><td>c</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.900176</td><td>14</td><td>0.825091</td><td>d</td></tr><tr><th>5</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>6</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>7</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr></tbody></table><p>or to change the name of specific columns</p><pre><code class="language-julia">rename!(df, :a =&gt; :A, :f =&gt; :F)
df</code></pre><table class="data-frame"><thead><tr><th></th><th>A</th><th>b</th><th>c</th><th>d</th><th>e</th><th>F</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th><th>Int64</th><th>Float64</th><th>Symbol</th></tr></thead><tbody><p>7 rows × 6 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.690949</td><td>11</td><td>0.761104</td><td>a</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.103873</td><td>12</td><td>0.752123</td><td>b</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.417709</td><td>13</td><td>0.168072</td><td>c</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.900176</td><td>14</td><td>0.825091</td><td>d</td></tr><tr><th>5</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>6</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>7</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr></tbody></table><p>Moreover, it is possible to use a function to generate column names</p><pre><code class="language-julia">myname(x) = string(&quot;column_&quot;, uppercase(x))
rename!(myname, df)
df</code></pre><table class="data-frame"><thead><tr><th></th><th>column_A</th><th>column_B</th><th>column_C</th><th>column_D</th><th>column_E</th><th>column_F</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Float64</th><th>Int64</th><th>Float64</th><th>Symbol</th></tr></thead><tbody><p>7 rows × 6 columns</p><tr><th>1</th><td>5</td><td>M</td><td>0.690949</td><td>11</td><td>0.761104</td><td>a</td></tr><tr><th>2</th><td>2</td><td>F</td><td>0.103873</td><td>12</td><td>0.752123</td><td>b</td></tr><tr><th>3</th><td>3</td><td>F</td><td>0.417709</td><td>13</td><td>0.168072</td><td>c</td></tr><tr><th>4</th><td>4</td><td>M</td><td>0.900176</td><td>14</td><td>0.825091</td><td>d</td></tr><tr><th>5</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>6</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr><tr><th>7</th><td>10</td><td>F</td><td>0.1</td><td>15</td><td>0.235</td><td>f</td></tr></tbody></table><h3 id="Working-with-DataFrames"><a class="docs-heading-anchor" href="#Working-with-DataFrames">Working with <code>DataFrame</code>s</a><a id="Working-with-DataFrames-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-DataFrames" title="Permalink"></a></h3><p>In the next part of the lecture, we will use the <a href="https://github.com/JuliaStats/RDatasets.jl">RDatasets</a>. That package provides an easy way for Julia users to use most of the standard data sets that are available in the core of R programming language. For further examples, we will use <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set">Iris dataset</a></p><pre><code class="language-julia">using RDatasets, DataFrames
iris = dataset(&quot;datasets&quot;, &quot;iris&quot;)
first(iris, 6)</code></pre><table class="data-frame"><thead><tr><th></th><th>SepalLength</th><th>SepalWidth</th><th>PetalLength</th><th>PetalWidth</th><th>Species</th></tr><tr><th></th><th>Float64</th><th>Float64</th><th>Float64</th><th>Float64</th><th>Cat…</th></tr></thead><tbody><p>6 rows × 5 columns</p><tr><th>1</th><td>5.1</td><td>3.5</td><td>1.4</td><td>0.2</td><td>setosa</td></tr><tr><th>2</th><td>4.9</td><td>3.0</td><td>1.4</td><td>0.2</td><td>setosa</td></tr><tr><th>3</th><td>4.7</td><td>3.2</td><td>1.3</td><td>0.2</td><td>setosa</td></tr><tr><th>4</th><td>4.6</td><td>3.1</td><td>1.5</td><td>0.2</td><td>setosa</td></tr><tr><th>5</th><td>5.0</td><td>3.6</td><td>1.4</td><td>0.2</td><td>setosa</td></tr><tr><th>6</th><td>5.4</td><td>3.9</td><td>1.7</td><td>0.4</td><td>setosa</td></tr></tbody></table><p>Note, that we use the <code>first</code> function to print only the first <code>n = 6</code> rows of the given table. Similarly, the <code>last</code> function can be used to show the last <code>n</code> rows of the given table.</p><p>When we start to work with a new data table, that we are not familiar with, it is very useful to get some basic description of the dataset. DataFrames provides the <code>describe</code> function that returns descriptive statistics for each column of the given <code>DataFrame</code></p><pre><code class="language-julia">describe(iris)</code></pre><table class="data-frame"><thead><tr><th></th><th>variable</th><th>mean</th><th>min</th><th>median</th><th>max</th><th>nmissing</th><th>eltype</th></tr><tr><th></th><th>Symbol</th><th>Union…</th><th>Any</th><th>Union…</th><th>Any</th><th>Int64</th><th>DataType</th></tr></thead><tbody><p>5 rows × 7 columns</p><tr><th>1</th><td>SepalLength</td><td>5.84333</td><td>4.3</td><td>5.8</td><td>7.9</td><td>0</td><td>Float64</td></tr><tr><th>2</th><td>SepalWidth</td><td>3.05733</td><td>2.0</td><td>3.0</td><td>4.4</td><td>0</td><td>Float64</td></tr><tr><th>3</th><td>PetalLength</td><td>3.758</td><td>1.0</td><td>4.35</td><td>6.9</td><td>0</td><td>Float64</td></tr><tr><th>4</th><td>PetalWidth</td><td>1.19933</td><td>0.1</td><td>1.3</td><td>2.5</td><td>0</td><td>Float64</td></tr><tr><th>5</th><td>Species</td><td></td><td>setosa</td><td></td><td>virginica</td><td>0</td><td>CategoricalValue{String,UInt8}</td></tr></tbody></table><p>It is also possible to get a specific subset of a <code>DataFrame</code>. To do that, we can use indexing syntax which is similar to indexing syntax for matrices</p><pre><code class="language-julia">iris[2:4, [:SepalLength, :Species]]</code></pre><table class="data-frame"><thead><tr><th></th><th>SepalLength</th><th>Species</th></tr><tr><th></th><th>Float64</th><th>Cat…</th></tr></thead><tbody><p>3 rows × 2 columns</p><tr><th>1</th><td>4.9</td><td>setosa</td></tr><tr><th>2</th><td>4.7</td><td>setosa</td></tr><tr><th>3</th><td>4.6</td><td>setosa</td></tr></tbody></table><p>Additionally, DataFrames provides <code>Not</code>, <code>Between</code>, <code>Cols</code> and <code>All</code> selectors that can be used in more complex column selection scenarios</p><pre><code class="language-julia">iris[2:4, Not([:SepalLength, :Species])]</code></pre><table class="data-frame"><thead><tr><th></th><th>SepalWidth</th><th>PetalLength</th><th>PetalWidth</th></tr><tr><th></th><th>Float64</th><th>Float64</th><th>Float64</th></tr></thead><tbody><p>3 rows × 3 columns</p><tr><th>1</th><td>3.0</td><td>1.4</td><td>0.2</td></tr><tr><th>2</th><td>3.2</td><td>1.3</td><td>0.2</td></tr><tr><th>3</th><td>3.1</td><td>1.5</td><td>0.2</td></tr></tbody></table><p>The last thing, that we will present in this section, is the <a href="https://github.com/queryverse/Query.jl">Query</a> package, which allows simple advanced manipulation with <code>DataFrame</code>. For example, in the code below, we select only rows where <code>SepalLength &gt;= 6</code> and at the same time <code>SepalWidth &gt;= 3.4</code>. Then we create a new DataFrame, where for each of the selected rows we add corresponding Species, the sum of sepal length and width, and the sum of petal length and width</p><pre><code class="language-julia">using Query

table = @from row in iris begin
    @where row.SepalLength &gt;= 6 &amp;&amp; row.SepalWidth &gt;= 3.4
    @select {
        row.Species,
        SepalSum = row.SepalLength + row.SepalWidth,
        PetalSum = row.PetalLength + row.PetalWidth,
    }
    @collect DataFrame
end</code></pre><table class="data-frame"><thead><tr><th></th><th>Species</th><th>SepalSum</th><th>PetalSum</th></tr><tr><th></th><th>Cat…</th><th>Float64</th><th>Float64</th></tr></thead><tbody><p>6 rows × 3 columns</p><tr><th>1</th><td>versicolor</td><td>9.4</td><td>6.1</td></tr><tr><th>2</th><td>virginica</td><td>10.8</td><td>8.6</td></tr><tr><th>3</th><td>virginica</td><td>11.5</td><td>8.9</td></tr><tr><th>4</th><td>virginica</td><td>11.7</td><td>8.4</td></tr><tr><th>5</th><td>virginica</td><td>9.7</td><td>8.0</td></tr><tr><th>6</th><td>virginica</td><td>9.6</td><td>7.7</td></tr></tbody></table><p>There are tons of other topics related to DataFrames, however, there is no time to cover them all. Also, there is also no reason to do that, since DataFrames provides very good <a href="https://dataframes.juliadata.org/stable/">documentation</a> with a lof of examples</p><h3 id="Visualizing-using-StatsPlots"><a class="docs-heading-anchor" href="#Visualizing-using-StatsPlots">Visualizing using StatsPlots</a><a id="Visualizing-using-StatsPlots-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-using-StatsPlots" title="Permalink"></a></h3><p><a href="https://github.com/JuliaPlots/StatsPlots.jl">StatsPlots</a> provides recipes for plotting histograms, boxplots, violin plots, etc. This package also provides <code>@df</code> macro, which allows simple plotting of tabular data. As a simple example, we can create a scatter plot of <code>SepalLength</code> and <code>SepalWidth</code> grouped based on the <code>Species</code></p><pre><code class="language-julia">using StatsPlots
@df iris scatter(
    :SepalLength,
    :SepalWidth;
    xlabel = &quot;SepalLength&quot;,
    ylabel = &quot;SepalWidth&quot;,
    group = :Species,
    marker = ([:d :h :star7], 8),
)</code></pre><p><img src="../tables_1.svg" alt/></p><p>Note that keyword arguments can be used in the same way as usual.</p><p>StatsPlots provides a large amount of statistic related plots. As one example, we can mention <code>marginalkde</code> function for plotting marginal kernel density estimations. In statistics, <a href="https://en.wikipedia.org/wiki/Kernel_density_estimation">kernel density estimation (KDE)</a> is a non-parametric way to estimate the probability density function of a random variable. The <code>marginalkde</code> function can be used together with <code>@df</code> macro as follows</p><pre><code class="language-julia">@df iris marginalkde(
    :SepalLength,
    :SepalWidth;
    xlabel = &quot;SepalLength&quot;,
    ylabel = &quot;SepalWidth&quot;,
)</code></pre><p><img src="../tables_2.svg" alt/></p><p>Another example of a useful function for statistically related graphs is the <code>corrplot</code> function, which shows the correlation between input variables</p><pre><code class="language-julia">@df iris corrplot(
    cols(1:4);
    grid = false,
    nbins = 15,
    fillcolor = :viridis,
    markercolor = :viridis,
)</code></pre><p><img src="../tables_3.svg" alt/></p><p>Note, that in this case, we use <code>cols(1:4)</code> instead of the names of columns. The reason for that is simple: it is shorter. Anyway, it is possible to use a vector of column names too.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Plots/">« Plots.jl</a><a class="docs-footer-nextpage" href="../otherpackages/">Other useful packages »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 11 January 2021 16:41">Monday 11 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
