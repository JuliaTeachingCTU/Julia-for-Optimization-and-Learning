<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wave equation · Julia for Machine Learning</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Julia for Machine Learning logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Julia for Machine Learning logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia for Machine Learning</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../why/">Why Julia?</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Installation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../installation/julia/">Julia</a></li><li><a class="tocitem" href="../../installation/vscode/">Visual Studio Code</a></li><li><a class="tocitem" href="../../installation/git/">Git</a></li><li><a class="tocitem" href="../../installation/tutorial/">Quick Start Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Variables and basic operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/variables/">Variables</a></li><li><a class="tocitem" href="../../lecture_01/operators/">Elementary Functions</a></li><li><a class="tocitem" href="../../lecture_01/strings/">Strings</a></li><li><a class="tocitem" href="../../lecture_01/arrays/">Arrays</a></li><li><a class="tocitem" href="../../lecture_01/data_structures/">Data Structures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: Control flow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/conditions/">Conditional Evaluations</a></li><li><a class="tocitem" href="../../lecture_02/loops/">Loops and Iterators</a></li><li><a class="tocitem" href="../../lecture_02/scope/">Soft Local Scope</a></li><li><a class="tocitem" href="../../lecture_02/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Functions and methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/functions/">Functions</a></li><li><a class="tocitem" href="../../lecture_03/methods/">Methods</a></li><li><a class="tocitem" href="../../lecture_03/scope/">Scope of Variables</a></li><li><a class="tocitem" href="../../lecture_03/exceptions/">Exception Handling</a></li><li><a class="tocitem" href="../../lecture_03/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/standardlibrary/">Standard Library</a></li><li><a class="tocitem" href="../../lecture_04/Plots/">Plots.jl</a></li><li><a class="tocitem" href="../../lecture_04/DataFrames/">DataFrames.jl</a></li><li><a class="tocitem" href="../../lecture_04/otherpackages/">Other Useful Packages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Type system and generic programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/compositetypes/">Abstract and composit types</a></li><li><a class="tocitem" href="../../lecture_05/currencies/">Generic Programming</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Modules and packages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/modules/">Modules</a></li><li><a class="tocitem" href="../../lecture_06/pkg/">Package Manager</a></li><li><a class="tocitem" href="../../lecture_06/develop/">Package Development</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Course requirements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../final_project/homeworks/">Homework</a></li><li><a class="tocitem" href="../../final_project/project/">Final project</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">7: Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/theory/">Introduction to continuous optimization</a></li><li><a class="tocitem" href="../../lecture_07/unconstrained/">Unconstrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/constrained/">Constrained optimization</a></li><li><a class="tocitem" href="../../lecture_07/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">8: Regression and classification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/theory/">Theory of regression and classification</a></li><li><a class="tocitem" href="../../lecture_08/linear/">Linear regression</a></li><li><a class="tocitem" href="../../lecture_08/logistic/">Logistic regression</a></li><li><a class="tocitem" href="../../lecture_08/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">9: Neural networks I.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_09/nn/">Neural networks</a></li><li><a class="tocitem" href="../../lecture_09/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">10: Neural networks II.</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/theory/">Theory of neural networks</a></li><li><a class="tocitem" href="../../lecture_10/nn/">More complex networks</a></li><li><a class="tocitem" href="../../lecture_10/exercises/">Exercises</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">11: Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/theory/">Statistics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox" checked/><label class="tocitem" for="menuitem-16"><span class="docs-label">12: Ordinary differential equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../theory/">Differential equations</a></li><li class="is-active"><a class="tocitem" href>Wave equation</a><ul class="internal"><li><a class="tocitem" href="#Statement"><span>Statement</span></a></li><li><a class="tocitem" href="#Solving-the-wave-equation"><span>Solving the wave equation</span></a></li></ul></li><li><a class="tocitem" href="../diff_eq/">Julia package</a></li><li><a class="tocitem" href="../optimal_control/">Optimal control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">12: Ordinary differential equations</a></li><li class="is-active"><a href>Wave equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Wave equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VaclavMacha/JuliaCourse/blob/master/docs/src/lecture_12/ode.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Wave-equation"><a class="docs-heading-anchor" href="#Wave-equation">Wave equation</a><a id="Wave-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Wave-equation" title="Permalink"></a></h1><p><a href="https://en.wikipedia.org/wiki/Wave_equation">Wave equation</a> is one of the most important differential equation. It models propagation of waves and has numerous applications in acoustics, electromagnetics or fluid dynamics.</p><h2 id="Statement"><a class="docs-heading-anchor" href="#Statement">Statement</a><a id="Statement-1"></a><a class="docs-heading-anchor-permalink" href="#Statement" title="Permalink"></a></h2><p>We consider the simplest case of one-dimensional wave equation such as a string. The wave equation on <span>$t\in[0,T]$</span> has the form</p><p class="math-container">\[\frac{\partial^2 y(t,x)}{\partial t^2} = c^2 \frac{\partial^2 y(t,x)}{\partial x^2}.\]</p><p>The function <span>$y:[0,T]\times [0,L]\to\mathbb R$</span> describes the displacement of the string. To obtain a complete formulation, we need to add boundary (in space) and initial (in time) conditions. Assuming that the string is fixed on its edges, the boundary conditions</p><p class="math-container">\[y(\cdot,0) = y_0, \quad y(\cdot,L) = y_L\]</p><p>are time-independent. The initial conditions are prescribed by functions</p><p class="math-container">\[\begin{aligned}
y(0,\cdot) &amp;= f(\cdot), \\
\frac{\partial y(0,\cdot)}{\partial t} &amp;= g(\cdot),
\end{aligned}\]</p><p>which vary in space. For consistency, we need <span>$f(0)=y_0$</span> and <span>$f(L)=y_L$</span>.</p><h2 id="Solving-the-wave-equation"><a class="docs-heading-anchor" href="#Solving-the-wave-equation">Solving the wave equation</a><a id="Solving-the-wave-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-wave-equation" title="Permalink"></a></h2><p>The following few exercises show how to solve the wave equation via the <a href="../../lecture_07/unconstrained/#comp-grad">finite differences</a> technique.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Design a numerical method to solve the one-dimensional wave equation on <span>$[0,T]\times [0,L]$</span> by applying finite differences in time and space. Derive the formulas.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>To discretize, we need to choose stepsizes <span>$\Delta t$</span> and <span>$\Delta x$</span>. For simplicity, we assume that the discretization is uniform (the length of the interval <span>$T$</span> can be divided by the time step <span>$\Delta t$</span> and similarly for <span>$L$</span> and <span>$\Delta x$</span>). </p><p>The initial conditions prescribe the value</p><p class="math-container">\[y(0,x) = f(x)\]</p><p>for all <span>$x\in\{0,\Delta x,2\Delta x,\dots,L\}$</span>. For the values at <span>$\Delta t$</span>, we approximate the initial condition for the derivative by the finite difference and get </p><p class="math-container">\[y(\Delta t, x) = y(0, x) + \Delta t g(x).\]</p><p>Since the finite difference approximation of the first derivative is</p><p class="math-container">\[\frac{\partial y(t,x)}{\partial t} \approx \frac{y(t + \Delta t,x) - y(t,x)}{\Delta t},\]</p><p>the finite difference approximation of the second derivative can be obtained in the same way by</p><p class="math-container">\[\begin{aligned}
\frac{\partial^2 y(t,x)}{\partial t^2} &amp;= \frac{1}{\Delta t}\left(\frac{y(t + \Delta t,x) - y(t,x)}{\Delta t} - \frac{y(t,x) - y(t-\Delta t,x)}{\Delta t}\right) \\
&amp;= \frac{y(t+\Delta t,x) - 2y(t,x) + y(t-\Delta t,x)}{\Delta t^2}.
\end{aligned}\]</p><p>Doing the same discretization for <span>$x$</span> and plugging the result into the wave equation yields</p><p class="math-container">\[\frac{y(t+\Delta t,x) - 2y(t,x) + y(t-\Delta t,x)}{\Delta t^2} = c^2 \frac{y(t,x+\Delta x) - 2y(t,x) + y(t,x-\Delta x)}{\Delta x^2}.\]</p><p>The computation now is the same as for a normal ODE. We know the initial state <span>$y(\cdot,0)$</span>, then we compute <span>$y(\cdot,\Delta t)$</span>, then <span>$y(\cdot, 2\Delta t)$</span> and so on. These states can be computed by rearranging the previous formula to</p><p class="math-container">\[y(t + \Delta t,x) = \frac{c^2\Delta t^2}{\Delta x^2}  \Big(y(t,x + \Delta x) - 2y(t,x) + y(t,x - \Delta x)\Big) + 2y(t,x) - y(t - \Delta t,x).\]</p><p>This formula can be applied for <span>$t=2\Delta t, 3\Delta t, \dots,T$</span>.</p></p></details><p>Before writing any code, it may be a good idea to decide on its structure. The following exercise aims to do so.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write function declaration (function name, inputs and outputs) which will be needed to solve the wave equation and to plot the solution. Do not write any code.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Before we can solve the wave equation, we need to perform discretization of time and space. We write the <code>discretize</code> function, whose inputs are the limits <code>xlims</code>. We use optional keyword arguments, which may specify the stepsize or the number of discretized points. The output will be the discretization <code>xs</code>. Even though we denote all inputs and outputs with <span>$x$</span>, this function will be used for time as well.</p><pre><code class="language-julia">function discretize(xlims; kwargs...)
    ...
    return xs
end</code></pre><p>The simplest way to work with objects with lots of parameters, is to create a structure to save these parameters. We therefore create <code>struct Wave</code> with fields <code>f</code>, <code>g</code> and <code>c</code>. We do not use the boundary values <span>$y_0$</span> and <span>$y_L$</span> as they can be computed from <span>$f$</span>.</p><pre><code class="language-julia">struct Wave
    f
    g
    c
end</code></pre><p>The wave equation is solved in <code>solve_wave(ts, xs, wave::Wave)</code>. Its inputs are the time discretization <code>ts</code>, the space discretization <code>xs</code> and the wave parameters stored in <code>wave</code>. It returns a matrix <code>y</code> with dimensions equals the number of time and space points.</p><pre><code class="language-julia">function solve_wave(ts, xs, wave::Wave)
    ...
    return y
end</code></pre><p>Finally, to plot, we define <code>plot_wave</code> function, where the inputs are the computed wave equation <code>y</code> and a name file name <code>file_name</code> to save the animation to. The optional arguments can be the number of frames per second <code>fps</code> and any additional arguments used for plotting.</p><pre><code class="language-julia">function plot_wave(y, file_name; fps=60, kwargs...)
    ...
    return nothing
end</code></pre></p></details><p>The most difficult part is done. We have done the thinking and finished the code structure. Now we just need to do manual labour and fill the empty functions with code.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Write the functions from the previous exercise. Do not forget to include any pacakges needed.</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The discretization will use the <code>range</code> function. We pass to it the keyword arguments, which will usually be either the length of the sequence <code>length</code> or the discretization step <code>step</code>. To obtain an array, we use the <code>collect</code> function. If the step is specified, the last point of <code>xs</code> may be different from <code>xlims[2]</code>. In such a case, we add it and throw a warning.</p><pre><code class="language-julia">using Plots
using LinearAlgebra

function discretize(xlims; kwargs...)
    xs = range(xlims[1], xlims[2]; kwargs...) |&gt; collect
    if xs[end] != xlims[2]
        @warn &quot;Discretization not equidistant.&quot;
        push!(xs, xlims[2])
    end
    return xs
end</code></pre><p>To solve the wave equation, we first perform a check that both discretizations are uniform. The better way would be to write a function which admits a non-equidistant discretization but we did not derive the formulas for it. If <code>ts</code> is equidistant, then <code>diff(ts)</code> should be a vector of constants and therefore <code>diff(diff(ts))</code> should be a vector of zeros. </p><p>Then we initialize <code>y</code> with zeros and set the initial condition <code>y[1,:]</code> via <code>wave.f</code> and the boundary conditions <code>y[:,1]</code> and <code>y[:,end]</code> which are fixed and, therefore, the same as <code>y[1,1]</code> and <code>y[1,end]</code>, respectively. We recall that the formulas for computing the solution are</p><p class="math-container">\[\begin{aligned}
y(\Delta t, x) &amp;= y(0, x) + \Delta t g(x), \\
y(t + \Delta t,x) &amp;= \frac{c^2\Delta t^2}{\Delta x^2}  \Big(y(t,x + \Delta x) - 2y(t,x) + y(t,x - \Delta x)\Big) + 2y(t,x) - y(t - \Delta t,x).
\end{aligned}\]</p><p>Since the boundary conditions are prescribed, we set the first condition to <code>y[2,2:end-1]</code> and the other to <code>y[i+1,2:end-1]</code>.</p><pre><code class="language-julia">function solve_wave(ts, xs, wave::Wave)
    norm(diff(diff(ts))) &lt;= 1e-10 || error(&quot;Time discretization must be equidistant.&quot;)
    norm(diff(diff(xs))) &lt;= 1e-10 || error(&quot;Space discretization must be equidistant.&quot;)

    n_t = length(ts)
    n_x = length(xs)

    y = zeros(n_t, n_x)
    y[1,:] = wave.f.(xs)
    y[:,1] .= y[1,1]
    y[:,end] .= y[1,end]
    y[2,2:end-1] = y[1,2:end-1] + (ts[2]-ts[1])*wave.g.(xs[2:end-1])

    s = wave.c^2 * (ts[2]-ts[1])^2 / (xs[2]-xs[1])^2
    for i in 2:n_t-1
        y[i+1,2:end-1] .= s*(y[i,3:end]+y[i,1:end-2]) + 2*(1-s)*y[i,2:end-1] - y[i-1,2:end-1]
    end
    return y
end</code></pre><p>The best visualization of the wave equation is via an animation. Each frame will be a plot of a row of <code>y</code>. We use the keyword arguments <code>kwargs</code>. We run the for loop over all rows, create the animation via the <code>@animate</code> macro and save it into <code>anim</code>. To save the animation to the hard drive, we use the <code>gif</code> function, for which we specify fps.</p><pre><code class="language-julia">function plot_wave(y, file_name; fps=60, kwargs...)
    anim = @animate for y_row in eachrow(y)
        plot(y_row; kwargs...)
    end
    gif(anim, file_name, fps=fps)
    return nothing
end</code></pre></p></details><p>Now we can finally plot the solution.</p><div class = "exercise-body">
<header class = "exercise-header">Exercise:</header><p><p>Solve the wave equation for <span>$L=\frac32\pi$</span>, <span>$T=240$</span>, <span>$c=0.02$</span> and the initial conditions</p><p class="math-container">\[\begin{aligned}
f(x) &amp;= 2e^{-(x-\frac L2)^2} + \frac{y_L}{L}x, \\
g(x) &amp;= 0.
\end{aligned}\]</p><p>Do the time discretization with stepsize <span>$\Delta t=1$</span> and the space discretization with <span>$N_x=101$</span> and <span>$N_x=7$</span> steps (plot two graphs, each for one <span>$N_x$</span>).</p></p></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>First, we assign the parameters</p><pre><code class="language-julia">f(x,L,y_L) = 2*exp(-(x-L/2)^2) + y_L*x/L
g(x) = 0

L = 1.5*pi
T = 240
c = 0.02
y_L = 1</code></pre><p>Since we want to do the same task for two different <span>$N_x$</span>, we write a function <code>run_wave</code>, which performs the discretizations, creates the <code>Wave</code> structure, solves the wave equation and finally plots the wave. We use different keywords for the <code>discretize</code> function as we have stepsize for the temporal discretization and number of steps for the spatial discretization.</p><pre><code class="language-julia">function run_wave(L, T, Δ_t::Float64, N_x::Int64, file_name; kwargs...)
    ts = discretize((0,T); step=Δ_t)
    xs = discretize((0,L); length=N_x)
    wave = Wave(x -&gt; f(x,L,y_L), g, c)

    y = solve_wave(ts, xs, wave)
    plot_wave(y, file_name; kwargs...)
end</code></pre><p>Now we call this function with different values of <span>$N_x$</span>. All keyword arguments are passed to the <code>plot</code> function inside <code>plot_wave</code>.</p><pre><code class="language-julia">run_wave(L, T, 1., 101, &quot;wave1.gif&quot;; ylims=(-2,3), label=&quot;&quot;)
run_wave(L, T, 1., 7, &quot;wave2.gif&quot;; ylims=(-2,3), label=&quot;&quot;)</code></pre><pre class="documenter-example-output">┌ Info: Saved animation to
└   fn = &quot;/home/runner/work/JuliaCourse/JuliaCourse/docs/build/lecture_12/wave1.gif&quot;
┌ Info: Saved animation to
└   fn = &quot;/home/runner/work/JuliaCourse/JuliaCourse/docs/build/lecture_12/wave2.gif&quot;</pre></p></details><p><img src="../wave1.gif" alt/></p><p><img src="../wave2.gif" alt/></p><p>If you see these two waves in different phases (positions), please refresh the page (the animations have already run for some time and the error accumulated).</p><p>After the potential reload, the waves should start from the same location and move at the same speed. This is an important property of any physical system: it is consistent. If we use a different discretization, their behaviour should be <em>roughly</em> similar. Of course, the finer spatial discretization results in smoother lines but both waves have similar shapes and move at similar speeds. If we see that one moves two times faster, there is a mistake in the code.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Differential equations</a><a class="docs-footer-nextpage" href="../diff_eq/">Julia package »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 March 2021 20:49">Monday 1 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
